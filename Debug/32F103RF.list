
32F103RF.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00009cdc  080001e4  080001e4  000101e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000e58  08009ec0  08009ec0  00019ec0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800ad18  0800ad18  0001ad18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800ad1c  0800ad1c  0001ad1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000001ec  20000000  0800ad20  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000f42c  200001ec  0800af0c  000201ec  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  2000f618  0800af0c  0002f618  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  000201ec  2**0
                  CONTENTS, READONLY
  9 .debug_info   0003052b  00000000  00000000  00020215  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00005741  00000000  00000000  00050740  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0001a38a  00000000  00000000  00055e81  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001d70  00000000  00000000  00070210  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001d18  00000000  00000000  00071f80  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000f0bc  00000000  00000000  00073c98  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007c0b  00000000  00000000  00082d54  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007c  00000000  00000000  0008a95f  2**0
                  CONTENTS, READONLY
 17 .debug_frame  000056c8  00000000  00000000  0008a9dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001e4 <__do_global_dtors_aux>:
 80001e4:	b510      	push	{r4, lr}
 80001e6:	4c05      	ldr	r4, [pc, #20]	; (80001fc <__do_global_dtors_aux+0x18>)
 80001e8:	7823      	ldrb	r3, [r4, #0]
 80001ea:	b933      	cbnz	r3, 80001fa <__do_global_dtors_aux+0x16>
 80001ec:	4b04      	ldr	r3, [pc, #16]	; (8000200 <__do_global_dtors_aux+0x1c>)
 80001ee:	b113      	cbz	r3, 80001f6 <__do_global_dtors_aux+0x12>
 80001f0:	4804      	ldr	r0, [pc, #16]	; (8000204 <__do_global_dtors_aux+0x20>)
 80001f2:	f3af 8000 	nop.w
 80001f6:	2301      	movs	r3, #1
 80001f8:	7023      	strb	r3, [r4, #0]
 80001fa:	bd10      	pop	{r4, pc}
 80001fc:	200001ec 	.word	0x200001ec
 8000200:	00000000 	.word	0x00000000
 8000204:	08009ea8 	.word	0x08009ea8

08000208 <frame_dummy>:
 8000208:	b508      	push	{r3, lr}
 800020a:	4b03      	ldr	r3, [pc, #12]	; (8000218 <frame_dummy+0x10>)
 800020c:	b11b      	cbz	r3, 8000216 <frame_dummy+0xe>
 800020e:	4903      	ldr	r1, [pc, #12]	; (800021c <frame_dummy+0x14>)
 8000210:	4803      	ldr	r0, [pc, #12]	; (8000220 <frame_dummy+0x18>)
 8000212:	f3af 8000 	nop.w
 8000216:	bd08      	pop	{r3, pc}
 8000218:	00000000 	.word	0x00000000
 800021c:	200001f0 	.word	0x200001f0
 8000220:	08009ea8 	.word	0x08009ea8

08000224 <strlen>:
 8000224:	4603      	mov	r3, r0
 8000226:	f813 2b01 	ldrb.w	r2, [r3], #1
 800022a:	2a00      	cmp	r2, #0
 800022c:	d1fb      	bne.n	8000226 <strlen+0x2>
 800022e:	1a18      	subs	r0, r3, r0
 8000230:	3801      	subs	r0, #1
 8000232:	4770      	bx	lr

08000234 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000234:	b510      	push	{r4, lr}
 8000236:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000238:	4b0e      	ldr	r3, [pc, #56]	; (8000274 <HAL_InitTick+0x40>)
 800023a:	7818      	ldrb	r0, [r3, #0]
 800023c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000240:	fbb3 f3f0 	udiv	r3, r3, r0
 8000244:	4a0c      	ldr	r2, [pc, #48]	; (8000278 <HAL_InitTick+0x44>)
 8000246:	6810      	ldr	r0, [r2, #0]
 8000248:	fbb0 f0f3 	udiv	r0, r0, r3
 800024c:	f000 f8a2 	bl	8000394 <HAL_SYSTICK_Config>
 8000250:	b968      	cbnz	r0, 800026e <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000252:	2c0f      	cmp	r4, #15
 8000254:	d901      	bls.n	800025a <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 8000256:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 8000258:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800025a:	2200      	movs	r2, #0
 800025c:	4621      	mov	r1, r4
 800025e:	f04f 30ff 	mov.w	r0, #4294967295
 8000262:	f000 f857 	bl	8000314 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000266:	4b05      	ldr	r3, [pc, #20]	; (800027c <HAL_InitTick+0x48>)
 8000268:	601c      	str	r4, [r3, #0]
  return HAL_OK;
 800026a:	2000      	movs	r0, #0
 800026c:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800026e:	2001      	movs	r0, #1
 8000270:	bd10      	pop	{r4, pc}
 8000272:	bf00      	nop
 8000274:	20000000 	.word	0x20000000
 8000278:	20000124 	.word	0x20000124
 800027c:	20000004 	.word	0x20000004

08000280 <HAL_Init>:
{
 8000280:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000282:	4a07      	ldr	r2, [pc, #28]	; (80002a0 <HAL_Init+0x20>)
 8000284:	6813      	ldr	r3, [r2, #0]
 8000286:	f043 0310 	orr.w	r3, r3, #16
 800028a:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800028c:	2003      	movs	r0, #3
 800028e:	f000 f82f 	bl	80002f0 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000292:	2000      	movs	r0, #0
 8000294:	f7ff ffce 	bl	8000234 <HAL_InitTick>
  HAL_MspInit();
 8000298:	f008 f9ee 	bl	8008678 <HAL_MspInit>
}
 800029c:	2000      	movs	r0, #0
 800029e:	bd08      	pop	{r3, pc}
 80002a0:	40022000 	.word	0x40022000

080002a4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80002a4:	4a03      	ldr	r2, [pc, #12]	; (80002b4 <HAL_IncTick+0x10>)
 80002a6:	6811      	ldr	r1, [r2, #0]
 80002a8:	4b03      	ldr	r3, [pc, #12]	; (80002b8 <HAL_IncTick+0x14>)
 80002aa:	781b      	ldrb	r3, [r3, #0]
 80002ac:	440b      	add	r3, r1
 80002ae:	6013      	str	r3, [r2, #0]
 80002b0:	4770      	bx	lr
 80002b2:	bf00      	nop
 80002b4:	20000984 	.word	0x20000984
 80002b8:	20000000 	.word	0x20000000

080002bc <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80002bc:	4b01      	ldr	r3, [pc, #4]	; (80002c4 <HAL_GetTick+0x8>)
 80002be:	6818      	ldr	r0, [r3, #0]
}
 80002c0:	4770      	bx	lr
 80002c2:	bf00      	nop
 80002c4:	20000984 	.word	0x20000984

080002c8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80002c8:	b538      	push	{r3, r4, r5, lr}
 80002ca:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80002cc:	f7ff fff6 	bl	80002bc <HAL_GetTick>
 80002d0:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80002d2:	f1b4 3fff 	cmp.w	r4, #4294967295
 80002d6:	d002      	beq.n	80002de <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 80002d8:	4b04      	ldr	r3, [pc, #16]	; (80002ec <HAL_Delay+0x24>)
 80002da:	781b      	ldrb	r3, [r3, #0]
 80002dc:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80002de:	f7ff ffed 	bl	80002bc <HAL_GetTick>
 80002e2:	1b40      	subs	r0, r0, r5
 80002e4:	4284      	cmp	r4, r0
 80002e6:	d8fa      	bhi.n	80002de <HAL_Delay+0x16>
  {
  }
}
 80002e8:	bd38      	pop	{r3, r4, r5, pc}
 80002ea:	bf00      	nop
 80002ec:	20000000 	.word	0x20000000

080002f0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80002f0:	4a07      	ldr	r2, [pc, #28]	; (8000310 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80002f2:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80002f4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80002f8:	041b      	lsls	r3, r3, #16
 80002fa:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 80002fc:	0200      	lsls	r0, r0, #8
 80002fe:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000302:	4318      	orrs	r0, r3
  reg_value  =  (reg_value                                   |
 8000304:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000308:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 800030c:	60d0      	str	r0, [r2, #12]
 800030e:	4770      	bx	lr
 8000310:	e000ed00 	.word	0xe000ed00

08000314 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000314:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000316:	4b16      	ldr	r3, [pc, #88]	; (8000370 <HAL_NVIC_SetPriority+0x5c>)
 8000318:	68db      	ldr	r3, [r3, #12]
 800031a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800031e:	f1c3 0407 	rsb	r4, r3, #7
 8000322:	2c04      	cmp	r4, #4
 8000324:	bf28      	it	cs
 8000326:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000328:	1d1d      	adds	r5, r3, #4
 800032a:	2d06      	cmp	r5, #6
 800032c:	d917      	bls.n	800035e <HAL_NVIC_SetPriority+0x4a>
 800032e:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000330:	2501      	movs	r5, #1
 8000332:	fa05 f404 	lsl.w	r4, r5, r4
 8000336:	3c01      	subs	r4, #1
 8000338:	4021      	ands	r1, r4
 800033a:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800033c:	fa05 f303 	lsl.w	r3, r5, r3
 8000340:	3b01      	subs	r3, #1
 8000342:	4013      	ands	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000344:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8000346:	2800      	cmp	r0, #0
 8000348:	db0b      	blt.n	8000362 <HAL_NVIC_SetPriority+0x4e>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800034a:	0109      	lsls	r1, r1, #4
 800034c:	b2c9      	uxtb	r1, r1
 800034e:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000352:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000356:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800035a:	bc30      	pop	{r4, r5}
 800035c:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800035e:	2300      	movs	r3, #0
 8000360:	e7e6      	b.n	8000330 <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000362:	f000 000f 	and.w	r0, r0, #15
 8000366:	0109      	lsls	r1, r1, #4
 8000368:	b2c9      	uxtb	r1, r1
 800036a:	4b02      	ldr	r3, [pc, #8]	; (8000374 <HAL_NVIC_SetPriority+0x60>)
 800036c:	5419      	strb	r1, [r3, r0]
 800036e:	e7f4      	b.n	800035a <HAL_NVIC_SetPriority+0x46>
 8000370:	e000ed00 	.word	0xe000ed00
 8000374:	e000ed14 	.word	0xe000ed14

08000378 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000378:	2800      	cmp	r0, #0
 800037a:	db08      	blt.n	800038e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800037c:	0942      	lsrs	r2, r0, #5
 800037e:	f000 001f 	and.w	r0, r0, #31
 8000382:	2301      	movs	r3, #1
 8000384:	fa03 f000 	lsl.w	r0, r3, r0
 8000388:	4b01      	ldr	r3, [pc, #4]	; (8000390 <HAL_NVIC_EnableIRQ+0x18>)
 800038a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800038e:	4770      	bx	lr
 8000390:	e000e100 	.word	0xe000e100

08000394 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000394:	3801      	subs	r0, #1
 8000396:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800039a:	d20a      	bcs.n	80003b2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800039c:	4b06      	ldr	r3, [pc, #24]	; (80003b8 <HAL_SYSTICK_Config+0x24>)
 800039e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003a0:	21f0      	movs	r1, #240	; 0xf0
 80003a2:	4a06      	ldr	r2, [pc, #24]	; (80003bc <HAL_SYSTICK_Config+0x28>)
 80003a4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003a8:	2000      	movs	r0, #0
 80003aa:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003ac:	2207      	movs	r2, #7
 80003ae:	601a      	str	r2, [r3, #0]
 80003b0:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80003b2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80003b4:	4770      	bx	lr
 80003b6:	bf00      	nop
 80003b8:	e000e010 	.word	0xe000e010
 80003bc:	e000ed00 	.word	0xe000ed00

080003c0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80003c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80003c2:	b083      	sub	sp, #12
  uint32_t position = 0x00u;
  uint32_t ioposition;
  uint32_t iocurrent;
  uint32_t temp;
  uint32_t config = 0x00u;
 80003c4:	2600      	movs	r6, #0
  uint32_t position = 0x00u;
 80003c6:	4634      	mov	r4, r6
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80003c8:	e079      	b.n	80004be <HAL_GPIO_Init+0xfe>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 80003ca:	2d00      	cmp	r5, #0
 80003cc:	f000 80aa 	beq.w	8000524 <HAL_GPIO_Init+0x164>
 80003d0:	2d01      	cmp	r5, #1
 80003d2:	d100      	bne.n	80003d6 <HAL_GPIO_Init+0x16>
      {
        /* If we are configuring the pin in OUTPUT push-pull mode */
        case GPIO_MODE_OUTPUT_PP:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 80003d4:	68ce      	ldr	r6, [r1, #12]
          break;
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80003d6:	2bff      	cmp	r3, #255	; 0xff
 80003d8:	f200 80b8 	bhi.w	800054c <HAL_GPIO_Init+0x18c>
 80003dc:	4686      	mov	lr, r0
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80003de:	2bff      	cmp	r3, #255	; 0xff
 80003e0:	f200 80b7 	bhi.w	8000552 <HAL_GPIO_Init+0x192>
 80003e4:	00a5      	lsls	r5, r4, #2

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80003e6:	f8de 2000 	ldr.w	r2, [lr]
 80003ea:	270f      	movs	r7, #15
 80003ec:	40af      	lsls	r7, r5
 80003ee:	ea22 0207 	bic.w	r2, r2, r7
 80003f2:	fa06 f505 	lsl.w	r5, r6, r5
 80003f6:	432a      	orrs	r2, r5
 80003f8:	f8ce 2000 	str.w	r2, [lr]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80003fc:	684a      	ldr	r2, [r1, #4]
 80003fe:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 8000402:	d05b      	beq.n	80004bc <HAL_GPIO_Init+0xfc>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8000404:	4a68      	ldr	r2, [pc, #416]	; (80005a8 <HAL_GPIO_Init+0x1e8>)
 8000406:	6995      	ldr	r5, [r2, #24]
 8000408:	f045 0501 	orr.w	r5, r5, #1
 800040c:	6195      	str	r5, [r2, #24]
 800040e:	6992      	ldr	r2, [r2, #24]
 8000410:	f002 0201 	and.w	r2, r2, #1
 8000414:	9201      	str	r2, [sp, #4]
 8000416:	9a01      	ldr	r2, [sp, #4]
        temp = AFIO->EXTICR[position >> 2u];
 8000418:	08a2      	lsrs	r2, r4, #2
 800041a:	1c97      	adds	r7, r2, #2
 800041c:	4d63      	ldr	r5, [pc, #396]	; (80005ac <HAL_GPIO_Init+0x1ec>)
 800041e:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8000422:	f004 0703 	and.w	r7, r4, #3
 8000426:	ea4f 0e87 	mov.w	lr, r7, lsl #2
 800042a:	270f      	movs	r7, #15
 800042c:	fa07 f70e 	lsl.w	r7, r7, lr
 8000430:	ea25 0507 	bic.w	r5, r5, r7
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8000434:	4f5e      	ldr	r7, [pc, #376]	; (80005b0 <HAL_GPIO_Init+0x1f0>)
 8000436:	42b8      	cmp	r0, r7
 8000438:	f000 8091 	beq.w	800055e <HAL_GPIO_Init+0x19e>
 800043c:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8000440:	42b8      	cmp	r0, r7
 8000442:	f000 808e 	beq.w	8000562 <HAL_GPIO_Init+0x1a2>
 8000446:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800044a:	42b8      	cmp	r0, r7
 800044c:	f000 808b 	beq.w	8000566 <HAL_GPIO_Init+0x1a6>
 8000450:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8000454:	42b8      	cmp	r0, r7
 8000456:	f000 8088 	beq.w	800056a <HAL_GPIO_Init+0x1aa>
 800045a:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800045e:	42b8      	cmp	r0, r7
 8000460:	f000 8085 	beq.w	800056e <HAL_GPIO_Init+0x1ae>
 8000464:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8000468:	42b8      	cmp	r0, r7
 800046a:	d076      	beq.n	800055a <HAL_GPIO_Init+0x19a>
 800046c:	2706      	movs	r7, #6
 800046e:	fa07 f70e 	lsl.w	r7, r7, lr
 8000472:	433d      	orrs	r5, r7
        AFIO->EXTICR[position >> 2u] = temp;
 8000474:	3202      	adds	r2, #2
 8000476:	4f4d      	ldr	r7, [pc, #308]	; (80005ac <HAL_GPIO_Init+0x1ec>)
 8000478:	f847 5022 	str.w	r5, [r7, r2, lsl #2]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800047c:	684a      	ldr	r2, [r1, #4]
 800047e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 8000482:	d076      	beq.n	8000572 <HAL_GPIO_Init+0x1b2>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 8000484:	4d4b      	ldr	r5, [pc, #300]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 8000486:	682a      	ldr	r2, [r5, #0]
 8000488:	431a      	orrs	r2, r3
 800048a:	602a      	str	r2, [r5, #0]
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800048c:	684a      	ldr	r2, [r1, #4]
 800048e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8000492:	d074      	beq.n	800057e <HAL_GPIO_Init+0x1be>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 8000494:	4d47      	ldr	r5, [pc, #284]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 8000496:	686a      	ldr	r2, [r5, #4]
 8000498:	431a      	orrs	r2, r3
 800049a:	606a      	str	r2, [r5, #4]
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800049c:	684a      	ldr	r2, [r1, #4]
 800049e:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
 80004a2:	d072      	beq.n	800058a <HAL_GPIO_Init+0x1ca>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 80004a4:	4d43      	ldr	r5, [pc, #268]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 80004a6:	68aa      	ldr	r2, [r5, #8]
 80004a8:	431a      	orrs	r2, r3
 80004aa:	60aa      	str	r2, [r5, #8]
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80004ac:	684a      	ldr	r2, [r1, #4]
 80004ae:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
 80004b2:	d070      	beq.n	8000596 <HAL_GPIO_Init+0x1d6>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 80004b4:	4d3f      	ldr	r5, [pc, #252]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 80004b6:	68ea      	ldr	r2, [r5, #12]
 80004b8:	4313      	orrs	r3, r2
 80004ba:	60eb      	str	r3, [r5, #12]
          CLEAR_BIT(EXTI->FTSR, iocurrent);
        }
      }
    }

	position++;
 80004bc:	3401      	adds	r4, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80004be:	680b      	ldr	r3, [r1, #0]
 80004c0:	fa33 f204 	lsrs.w	r2, r3, r4
 80004c4:	d06d      	beq.n	80005a2 <HAL_GPIO_Init+0x1e2>
    ioposition = (0x01uL << position);
 80004c6:	2201      	movs	r2, #1
 80004c8:	40a2      	lsls	r2, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80004ca:	4013      	ands	r3, r2
    if (iocurrent == ioposition)
 80004cc:	429a      	cmp	r2, r3
 80004ce:	d1f5      	bne.n	80004bc <HAL_GPIO_Init+0xfc>
      switch (GPIO_Init->Mode)
 80004d0:	684d      	ldr	r5, [r1, #4]
 80004d2:	2d12      	cmp	r5, #18
 80004d4:	d030      	beq.n	8000538 <HAL_GPIO_Init+0x178>
 80004d6:	d80b      	bhi.n	80004f0 <HAL_GPIO_Init+0x130>
 80004d8:	2d02      	cmp	r5, #2
 80004da:	d02a      	beq.n	8000532 <HAL_GPIO_Init+0x172>
 80004dc:	f67f af75 	bls.w	80003ca <HAL_GPIO_Init+0xa>
 80004e0:	2d03      	cmp	r5, #3
 80004e2:	d02f      	beq.n	8000544 <HAL_GPIO_Init+0x184>
 80004e4:	2d11      	cmp	r5, #17
 80004e6:	f47f af76 	bne.w	80003d6 <HAL_GPIO_Init+0x16>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 80004ea:	68ce      	ldr	r6, [r1, #12]
 80004ec:	3604      	adds	r6, #4
          break;
 80004ee:	e772      	b.n	80003d6 <HAL_GPIO_Init+0x16>
      switch (GPIO_Init->Mode)
 80004f0:	4f31      	ldr	r7, [pc, #196]	; (80005b8 <HAL_GPIO_Init+0x1f8>)
 80004f2:	42bd      	cmp	r5, r7
 80004f4:	d016      	beq.n	8000524 <HAL_GPIO_Init+0x164>
 80004f6:	d90c      	bls.n	8000512 <HAL_GPIO_Init+0x152>
 80004f8:	4f30      	ldr	r7, [pc, #192]	; (80005bc <HAL_GPIO_Init+0x1fc>)
 80004fa:	42bd      	cmp	r5, r7
 80004fc:	d012      	beq.n	8000524 <HAL_GPIO_Init+0x164>
 80004fe:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 8000502:	42bd      	cmp	r5, r7
 8000504:	d00e      	beq.n	8000524 <HAL_GPIO_Init+0x164>
 8000506:	f5a7 1780 	sub.w	r7, r7, #1048576	; 0x100000
 800050a:	42bd      	cmp	r5, r7
 800050c:	f47f af63 	bne.w	80003d6 <HAL_GPIO_Init+0x16>
 8000510:	e008      	b.n	8000524 <HAL_GPIO_Init+0x164>
 8000512:	f5a7 1780 	sub.w	r7, r7, #1048576	; 0x100000
 8000516:	42bd      	cmp	r5, r7
 8000518:	d004      	beq.n	8000524 <HAL_GPIO_Init+0x164>
 800051a:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 800051e:	42bd      	cmp	r5, r7
 8000520:	f47f af59 	bne.w	80003d6 <HAL_GPIO_Init+0x16>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8000524:	688d      	ldr	r5, [r1, #8]
 8000526:	b17d      	cbz	r5, 8000548 <HAL_GPIO_Init+0x188>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8000528:	2d01      	cmp	r5, #1
 800052a:	d008      	beq.n	800053e <HAL_GPIO_Init+0x17e>
            GPIOx->BRR = ioposition;
 800052c:	6142      	str	r2, [r0, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800052e:	2608      	movs	r6, #8
 8000530:	e751      	b.n	80003d6 <HAL_GPIO_Init+0x16>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8000532:	68ce      	ldr	r6, [r1, #12]
 8000534:	3608      	adds	r6, #8
          break;
 8000536:	e74e      	b.n	80003d6 <HAL_GPIO_Init+0x16>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8000538:	68ce      	ldr	r6, [r1, #12]
 800053a:	360c      	adds	r6, #12
          break;
 800053c:	e74b      	b.n	80003d6 <HAL_GPIO_Init+0x16>
            GPIOx->BSRR = ioposition;
 800053e:	6102      	str	r2, [r0, #16]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8000540:	2608      	movs	r6, #8
 8000542:	e748      	b.n	80003d6 <HAL_GPIO_Init+0x16>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8000544:	2600      	movs	r6, #0
 8000546:	e746      	b.n	80003d6 <HAL_GPIO_Init+0x16>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8000548:	2604      	movs	r6, #4
 800054a:	e744      	b.n	80003d6 <HAL_GPIO_Init+0x16>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800054c:	f100 0e04 	add.w	lr, r0, #4
 8000550:	e745      	b.n	80003de <HAL_GPIO_Init+0x1e>
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8000552:	f1a4 0508 	sub.w	r5, r4, #8
 8000556:	00ad      	lsls	r5, r5, #2
 8000558:	e745      	b.n	80003e6 <HAL_GPIO_Init+0x26>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 800055a:	2705      	movs	r7, #5
 800055c:	e787      	b.n	800046e <HAL_GPIO_Init+0xae>
 800055e:	2700      	movs	r7, #0
 8000560:	e785      	b.n	800046e <HAL_GPIO_Init+0xae>
 8000562:	2701      	movs	r7, #1
 8000564:	e783      	b.n	800046e <HAL_GPIO_Init+0xae>
 8000566:	2702      	movs	r7, #2
 8000568:	e781      	b.n	800046e <HAL_GPIO_Init+0xae>
 800056a:	2703      	movs	r7, #3
 800056c:	e77f      	b.n	800046e <HAL_GPIO_Init+0xae>
 800056e:	2704      	movs	r7, #4
 8000570:	e77d      	b.n	800046e <HAL_GPIO_Init+0xae>
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8000572:	4d10      	ldr	r5, [pc, #64]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 8000574:	682a      	ldr	r2, [r5, #0]
 8000576:	ea22 0203 	bic.w	r2, r2, r3
 800057a:	602a      	str	r2, [r5, #0]
 800057c:	e786      	b.n	800048c <HAL_GPIO_Init+0xcc>
          CLEAR_BIT(EXTI->EMR, iocurrent);
 800057e:	4d0d      	ldr	r5, [pc, #52]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 8000580:	686a      	ldr	r2, [r5, #4]
 8000582:	ea22 0203 	bic.w	r2, r2, r3
 8000586:	606a      	str	r2, [r5, #4]
 8000588:	e788      	b.n	800049c <HAL_GPIO_Init+0xdc>
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 800058a:	4d0a      	ldr	r5, [pc, #40]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 800058c:	68aa      	ldr	r2, [r5, #8]
 800058e:	ea22 0203 	bic.w	r2, r2, r3
 8000592:	60aa      	str	r2, [r5, #8]
 8000594:	e78a      	b.n	80004ac <HAL_GPIO_Init+0xec>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8000596:	4d07      	ldr	r5, [pc, #28]	; (80005b4 <HAL_GPIO_Init+0x1f4>)
 8000598:	68ea      	ldr	r2, [r5, #12]
 800059a:	ea22 0303 	bic.w	r3, r2, r3
 800059e:	60eb      	str	r3, [r5, #12]
 80005a0:	e78c      	b.n	80004bc <HAL_GPIO_Init+0xfc>
  }
}
 80005a2:	b003      	add	sp, #12
 80005a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005a6:	bf00      	nop
 80005a8:	40021000 	.word	0x40021000
 80005ac:	40010000 	.word	0x40010000
 80005b0:	40010800 	.word	0x40010800
 80005b4:	40010400 	.word	0x40010400
 80005b8:	10210000 	.word	0x10210000
 80005bc:	10310000 	.word	0x10310000

080005c0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80005c0:	b912      	cbnz	r2, 80005c8 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 80005c2:	0409      	lsls	r1, r1, #16
 80005c4:	6101      	str	r1, [r0, #16]
 80005c6:	4770      	bx	lr
    GPIOx->BSRR = GPIO_Pin;
 80005c8:	6101      	str	r1, [r0, #16]
 80005ca:	4770      	bx	lr

080005cc <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != 0x00u)
 80005cc:	68c3      	ldr	r3, [r0, #12]
 80005ce:	420b      	tst	r3, r1
 80005d0:	d101      	bne.n	80005d6 <HAL_GPIO_TogglePin+0xa>
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80005d2:	6101      	str	r1, [r0, #16]
 80005d4:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80005d6:	6141      	str	r1, [r0, #20]
 80005d8:	4770      	bx	lr

080005da <I2C_IsAcknowledgeFailed>:
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80005da:	6803      	ldr	r3, [r0, #0]
 80005dc:	695a      	ldr	r2, [r3, #20]
 80005de:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80005e2:	d011      	beq.n	8000608 <I2C_IsAcknowledgeFailed+0x2e>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80005e4:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 80005e8:	615a      	str	r2, [r3, #20]

    hi2c->PreviousState       = I2C_STATE_NONE;
 80005ea:	2300      	movs	r3, #0
 80005ec:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State               = HAL_I2C_STATE_READY;
 80005ee:	2220      	movs	r2, #32
 80005f0:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    hi2c->Mode                = HAL_I2C_MODE_NONE;
 80005f4:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 80005f8:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80005fa:	f042 0204 	orr.w	r2, r2, #4
 80005fe:	6402      	str	r2, [r0, #64]	; 0x40

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8000600:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

    return HAL_ERROR;
 8000604:	2001      	movs	r0, #1
 8000606:	4770      	bx	lr
  }
  return HAL_OK;
 8000608:	2000      	movs	r0, #0
}
 800060a:	4770      	bx	lr

0800060c <I2C_WaitOnFlagUntilTimeout>:
{
 800060c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800060e:	4606      	mov	r6, r0
 8000610:	460c      	mov	r4, r1
 8000612:	4617      	mov	r7, r2
 8000614:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8000616:	e022      	b.n	800065e <I2C_WaitOnFlagUntilTimeout+0x52>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000618:	f7ff fe50 	bl	80002bc <HAL_GetTick>
 800061c:	9b06      	ldr	r3, [sp, #24]
 800061e:	1ac0      	subs	r0, r0, r3
 8000620:	4285      	cmp	r5, r0
 8000622:	d300      	bcc.n	8000626 <I2C_WaitOnFlagUntilTimeout+0x1a>
 8000624:	b9dd      	cbnz	r5, 800065e <I2C_WaitOnFlagUntilTimeout+0x52>
        hi2c->PreviousState     = I2C_STATE_NONE;
 8000626:	2300      	movs	r3, #0
 8000628:	6333      	str	r3, [r6, #48]	; 0x30
        hi2c->State             = HAL_I2C_STATE_READY;
 800062a:	2220      	movs	r2, #32
 800062c:	f886 203d 	strb.w	r2, [r6, #61]	; 0x3d
        hi2c->Mode              = HAL_I2C_MODE_NONE;
 8000630:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
        hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
 8000634:	6c32      	ldr	r2, [r6, #64]	; 0x40
 8000636:	f042 0220 	orr.w	r2, r2, #32
 800063a:	6432      	str	r2, [r6, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 800063c:	f886 303c 	strb.w	r3, [r6, #60]	; 0x3c
        return HAL_ERROR;
 8000640:	2001      	movs	r0, #1
 8000642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8000644:	6833      	ldr	r3, [r6, #0]
 8000646:	695b      	ldr	r3, [r3, #20]
 8000648:	ea24 0303 	bic.w	r3, r4, r3
 800064c:	b29b      	uxth	r3, r3
 800064e:	fab3 f383 	clz	r3, r3
 8000652:	095b      	lsrs	r3, r3, #5
 8000654:	42bb      	cmp	r3, r7
 8000656:	d10f      	bne.n	8000678 <I2C_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
 8000658:	f1b5 3fff 	cmp.w	r5, #4294967295
 800065c:	d1dc      	bne.n	8000618 <I2C_WaitOnFlagUntilTimeout+0xc>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800065e:	f3c4 4307 	ubfx	r3, r4, #16, #8
 8000662:	2b01      	cmp	r3, #1
 8000664:	d0ee      	beq.n	8000644 <I2C_WaitOnFlagUntilTimeout+0x38>
 8000666:	6833      	ldr	r3, [r6, #0]
 8000668:	699b      	ldr	r3, [r3, #24]
 800066a:	ea24 0303 	bic.w	r3, r4, r3
 800066e:	b29b      	uxth	r3, r3
 8000670:	fab3 f383 	clz	r3, r3
 8000674:	095b      	lsrs	r3, r3, #5
 8000676:	e7ed      	b.n	8000654 <I2C_WaitOnFlagUntilTimeout+0x48>
  return HAL_OK;
 8000678:	2000      	movs	r0, #0
}
 800067a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800067c <I2C_WaitOnMasterAddressFlagUntilTimeout>:
{
 800067c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800067e:	4604      	mov	r4, r0
 8000680:	460d      	mov	r5, r1
 8000682:	4616      	mov	r6, r2
 8000684:	461f      	mov	r7, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000686:	e03c      	b.n	8000702 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x86>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000688:	681a      	ldr	r2, [r3, #0]
 800068a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800068e:	601a      	str	r2, [r3, #0]
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000690:	6823      	ldr	r3, [r4, #0]
 8000692:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8000696:	615a      	str	r2, [r3, #20]
      hi2c->PreviousState       = I2C_STATE_NONE;
 8000698:	2300      	movs	r3, #0
 800069a:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State               = HAL_I2C_STATE_READY;
 800069c:	2220      	movs	r2, #32
 800069e:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
      hi2c->Mode                = HAL_I2C_MODE_NONE;
 80006a2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 80006a6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80006a8:	f042 0204 	orr.w	r2, r2, #4
 80006ac:	6422      	str	r2, [r4, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 80006ae:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
      return HAL_ERROR;
 80006b2:	2001      	movs	r0, #1
 80006b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80006b6:	f7ff fe01 	bl	80002bc <HAL_GetTick>
 80006ba:	1bc0      	subs	r0, r0, r7
 80006bc:	4286      	cmp	r6, r0
 80006be:	d300      	bcc.n	80006c2 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x46>
 80006c0:	b9fe      	cbnz	r6, 8000702 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x86>
        hi2c->PreviousState       = I2C_STATE_NONE;
 80006c2:	2300      	movs	r3, #0
 80006c4:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State               = HAL_I2C_STATE_READY;
 80006c6:	2220      	movs	r2, #32
 80006c8:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode                = HAL_I2C_MODE_NONE;
 80006cc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 80006d0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80006d2:	f042 0220 	orr.w	r2, r2, #32
 80006d6:	6422      	str	r2, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 80006d8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        return HAL_ERROR;
 80006dc:	2001      	movs	r0, #1
 80006de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 80006e0:	6823      	ldr	r3, [r4, #0]
 80006e2:	695b      	ldr	r3, [r3, #20]
 80006e4:	ea25 0303 	bic.w	r3, r5, r3
 80006e8:	b29b      	uxth	r3, r3
 80006ea:	3300      	adds	r3, #0
 80006ec:	bf18      	it	ne
 80006ee:	2301      	movne	r3, #1
 80006f0:	b1a3      	cbz	r3, 800071c <I2C_WaitOnMasterAddressFlagUntilTimeout+0xa0>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80006f2:	6823      	ldr	r3, [r4, #0]
 80006f4:	695a      	ldr	r2, [r3, #20]
 80006f6:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80006fa:	d1c5      	bne.n	8000688 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xc>
    if (Timeout != HAL_MAX_DELAY)
 80006fc:	f1b6 3fff 	cmp.w	r6, #4294967295
 8000700:	d1d9      	bne.n	80006b6 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x3a>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000702:	f3c5 4307 	ubfx	r3, r5, #16, #8
 8000706:	2b01      	cmp	r3, #1
 8000708:	d0ea      	beq.n	80006e0 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x64>
 800070a:	6823      	ldr	r3, [r4, #0]
 800070c:	699b      	ldr	r3, [r3, #24]
 800070e:	ea25 0303 	bic.w	r3, r5, r3
 8000712:	b29b      	uxth	r3, r3
 8000714:	3300      	adds	r3, #0
 8000716:	bf18      	it	ne
 8000718:	2301      	movne	r3, #1
 800071a:	e7e9      	b.n	80006f0 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x74>
  return HAL_OK;
 800071c:	2000      	movs	r0, #0
}
 800071e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000720 <I2C_MasterRequestWrite>:
{
 8000720:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000722:	b083      	sub	sp, #12
 8000724:	4604      	mov	r4, r0
 8000726:	460f      	mov	r7, r1
 8000728:	4615      	mov	r5, r2
 800072a:	461e      	mov	r6, r3
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 800072c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
 800072e:	2b08      	cmp	r3, #8
 8000730:	d00d      	beq.n	800074e <I2C_MasterRequestWrite+0x2e>
 8000732:	2b01      	cmp	r3, #1
 8000734:	d00b      	beq.n	800074e <I2C_MasterRequestWrite+0x2e>
 8000736:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 800073a:	d008      	beq.n	800074e <I2C_MasterRequestWrite+0x2e>
  else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
 800073c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800073e:	2b12      	cmp	r3, #18
 8000740:	d10a      	bne.n	8000758 <I2C_MasterRequestWrite+0x38>
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8000742:	6802      	ldr	r2, [r0, #0]
 8000744:	6813      	ldr	r3, [r2, #0]
 8000746:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800074a:	6013      	str	r3, [r2, #0]
 800074c:	e004      	b.n	8000758 <I2C_MasterRequestWrite+0x38>
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800074e:	6822      	ldr	r2, [r4, #0]
 8000750:	6813      	ldr	r3, [r2, #0]
 8000752:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000756:	6013      	str	r3, [r2, #0]
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 8000758:	9600      	str	r6, [sp, #0]
 800075a:	462b      	mov	r3, r5
 800075c:	2200      	movs	r2, #0
 800075e:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8000762:	4620      	mov	r0, r4
 8000764:	f7ff ff52 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000768:	bb18      	cbnz	r0, 80007b2 <I2C_MasterRequestWrite+0x92>
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800076a:	6923      	ldr	r3, [r4, #16]
 800076c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000770:	d011      	beq.n	8000796 <I2C_MasterRequestWrite+0x76>
    hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
 8000772:	6822      	ldr	r2, [r4, #0]
 8000774:	11fb      	asrs	r3, r7, #7
 8000776:	f003 0306 	and.w	r3, r3, #6
 800077a:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 800077e:	6113      	str	r3, [r2, #16]
    if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
 8000780:	4633      	mov	r3, r6
 8000782:	462a      	mov	r2, r5
 8000784:	490e      	ldr	r1, [pc, #56]	; (80007c0 <I2C_MasterRequestWrite+0xa0>)
 8000786:	4620      	mov	r0, r4
 8000788:	f7ff ff78 	bl	800067c <I2C_WaitOnMasterAddressFlagUntilTimeout>
 800078c:	b9a8      	cbnz	r0, 80007ba <I2C_MasterRequestWrite+0x9a>
    hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
 800078e:	6823      	ldr	r3, [r4, #0]
 8000790:	b2ff      	uxtb	r7, r7
 8000792:	611f      	str	r7, [r3, #16]
 8000794:	e003      	b.n	800079e <I2C_MasterRequestWrite+0x7e>
    hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 8000796:	6823      	ldr	r3, [r4, #0]
 8000798:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
 800079c:	611f      	str	r7, [r3, #16]
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 800079e:	4633      	mov	r3, r6
 80007a0:	462a      	mov	r2, r5
 80007a2:	4908      	ldr	r1, [pc, #32]	; (80007c4 <I2C_MasterRequestWrite+0xa4>)
 80007a4:	4620      	mov	r0, r4
 80007a6:	f7ff ff69 	bl	800067c <I2C_WaitOnMasterAddressFlagUntilTimeout>
 80007aa:	4603      	mov	r3, r0
 80007ac:	b110      	cbz	r0, 80007b4 <I2C_MasterRequestWrite+0x94>
    return HAL_ERROR;
 80007ae:	2301      	movs	r3, #1
 80007b0:	e000      	b.n	80007b4 <I2C_MasterRequestWrite+0x94>
    return HAL_ERROR;
 80007b2:	2301      	movs	r3, #1
}
 80007b4:	4618      	mov	r0, r3
 80007b6:	b003      	add	sp, #12
 80007b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return HAL_ERROR;
 80007ba:	2301      	movs	r3, #1
 80007bc:	e7fa      	b.n	80007b4 <I2C_MasterRequestWrite+0x94>
 80007be:	bf00      	nop
 80007c0:	00010008 	.word	0x00010008
 80007c4:	00010002 	.word	0x00010002

080007c8 <I2C_WaitOnTXEFlagUntilTimeout>:
{
 80007c8:	b570      	push	{r4, r5, r6, lr}
 80007ca:	4604      	mov	r4, r0
 80007cc:	460d      	mov	r5, r1
 80007ce:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80007d0:	6823      	ldr	r3, [r4, #0]
 80007d2:	695b      	ldr	r3, [r3, #20]
 80007d4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80007d8:	d11c      	bne.n	8000814 <I2C_WaitOnTXEFlagUntilTimeout+0x4c>
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 80007da:	4620      	mov	r0, r4
 80007dc:	f7ff fefd 	bl	80005da <I2C_IsAcknowledgeFailed>
 80007e0:	b9d0      	cbnz	r0, 8000818 <I2C_WaitOnTXEFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 80007e2:	f1b5 3fff 	cmp.w	r5, #4294967295
 80007e6:	d0f3      	beq.n	80007d0 <I2C_WaitOnTXEFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80007e8:	f7ff fd68 	bl	80002bc <HAL_GetTick>
 80007ec:	1b80      	subs	r0, r0, r6
 80007ee:	4285      	cmp	r5, r0
 80007f0:	d301      	bcc.n	80007f6 <I2C_WaitOnTXEFlagUntilTimeout+0x2e>
 80007f2:	2d00      	cmp	r5, #0
 80007f4:	d1ec      	bne.n	80007d0 <I2C_WaitOnTXEFlagUntilTimeout+0x8>
        hi2c->PreviousState       = I2C_STATE_NONE;
 80007f6:	2300      	movs	r3, #0
 80007f8:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State               = HAL_I2C_STATE_READY;
 80007fa:	2220      	movs	r2, #32
 80007fc:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode                = HAL_I2C_MODE_NONE;
 8000800:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8000804:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000806:	f042 0220 	orr.w	r2, r2, #32
 800080a:	6422      	str	r2, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 800080c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        return HAL_ERROR;
 8000810:	2001      	movs	r0, #1
 8000812:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8000814:	2000      	movs	r0, #0
 8000816:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8000818:	2001      	movs	r0, #1
}
 800081a:	bd70      	pop	{r4, r5, r6, pc}

0800081c <I2C_WaitOnBTFFlagUntilTimeout>:
{
 800081c:	b570      	push	{r4, r5, r6, lr}
 800081e:	4604      	mov	r4, r0
 8000820:	460d      	mov	r5, r1
 8000822:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8000824:	6823      	ldr	r3, [r4, #0]
 8000826:	695b      	ldr	r3, [r3, #20]
 8000828:	f013 0f04 	tst.w	r3, #4
 800082c:	d11c      	bne.n	8000868 <I2C_WaitOnBTFFlagUntilTimeout+0x4c>
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 800082e:	4620      	mov	r0, r4
 8000830:	f7ff fed3 	bl	80005da <I2C_IsAcknowledgeFailed>
 8000834:	b9d0      	cbnz	r0, 800086c <I2C_WaitOnBTFFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 8000836:	f1b5 3fff 	cmp.w	r5, #4294967295
 800083a:	d0f3      	beq.n	8000824 <I2C_WaitOnBTFFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800083c:	f7ff fd3e 	bl	80002bc <HAL_GetTick>
 8000840:	1b80      	subs	r0, r0, r6
 8000842:	4285      	cmp	r5, r0
 8000844:	d301      	bcc.n	800084a <I2C_WaitOnBTFFlagUntilTimeout+0x2e>
 8000846:	2d00      	cmp	r5, #0
 8000848:	d1ec      	bne.n	8000824 <I2C_WaitOnBTFFlagUntilTimeout+0x8>
        hi2c->PreviousState       = I2C_STATE_NONE;
 800084a:	2300      	movs	r3, #0
 800084c:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State               = HAL_I2C_STATE_READY;
 800084e:	2220      	movs	r2, #32
 8000850:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode                = HAL_I2C_MODE_NONE;
 8000854:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8000858:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800085a:	f042 0220 	orr.w	r2, r2, #32
 800085e:	6422      	str	r2, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 8000860:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        return HAL_ERROR;
 8000864:	2001      	movs	r0, #1
 8000866:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8000868:	2000      	movs	r0, #0
 800086a:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 800086c:	2001      	movs	r0, #1
}
 800086e:	bd70      	pop	{r4, r5, r6, pc}

08000870 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8000870:	2800      	cmp	r0, #0
 8000872:	f000 80be 	beq.w	80009f2 <HAL_I2C_Init+0x182>
{
 8000876:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000878:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800087a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800087e:	2b00      	cmp	r3, #0
 8000880:	d06b      	beq.n	800095a <HAL_I2C_Init+0xea>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000882:	2324      	movs	r3, #36	; 0x24
 8000884:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8000888:	6822      	ldr	r2, [r4, #0]
 800088a:	6813      	ldr	r3, [r2, #0]
 800088c:	f023 0301 	bic.w	r3, r3, #1
 8000890:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8000892:	f001 fa15 	bl	8001cc0 <HAL_RCC_GetPCLK1Freq>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8000896:	6862      	ldr	r2, [r4, #4]
 8000898:	4b58      	ldr	r3, [pc, #352]	; (80009fc <HAL_I2C_Init+0x18c>)
 800089a:	429a      	cmp	r2, r3
 800089c:	d862      	bhi.n	8000964 <HAL_I2C_Init+0xf4>
 800089e:	4b58      	ldr	r3, [pc, #352]	; (8000a00 <HAL_I2C_Init+0x190>)
 80008a0:	4298      	cmp	r0, r3
 80008a2:	bf8c      	ite	hi
 80008a4:	2300      	movhi	r3, #0
 80008a6:	2301      	movls	r3, #1
 80008a8:	2b00      	cmp	r3, #0
 80008aa:	f040 80a4 	bne.w	80009f6 <HAL_I2C_Init+0x186>
  freqrange = I2C_FREQRANGE(pclk1);
 80008ae:	4b55      	ldr	r3, [pc, #340]	; (8000a04 <HAL_I2C_Init+0x194>)
 80008b0:	fba3 2300 	umull	r2, r3, r3, r0
 80008b4:	0c9a      	lsrs	r2, r3, #18
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80008b6:	6821      	ldr	r1, [r4, #0]
 80008b8:	684b      	ldr	r3, [r1, #4]
 80008ba:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80008be:	4313      	orrs	r3, r2
 80008c0:	604b      	str	r3, [r1, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80008c2:	6825      	ldr	r5, [r4, #0]
 80008c4:	6a29      	ldr	r1, [r5, #32]
 80008c6:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80008ca:	6866      	ldr	r6, [r4, #4]
 80008cc:	4b4b      	ldr	r3, [pc, #300]	; (80009fc <HAL_I2C_Init+0x18c>)
 80008ce:	429e      	cmp	r6, r3
 80008d0:	d84e      	bhi.n	8000970 <HAL_I2C_Init+0x100>
 80008d2:	1c53      	adds	r3, r2, #1
 80008d4:	430b      	orrs	r3, r1
 80008d6:	622b      	str	r3, [r5, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80008d8:	6822      	ldr	r2, [r4, #0]
 80008da:	69d1      	ldr	r1, [r2, #28]
 80008dc:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 80008e0:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 80008e4:	6863      	ldr	r3, [r4, #4]
 80008e6:	4d45      	ldr	r5, [pc, #276]	; (80009fc <HAL_I2C_Init+0x18c>)
 80008e8:	42ab      	cmp	r3, r5
 80008ea:	d84b      	bhi.n	8000984 <HAL_I2C_Init+0x114>
 80008ec:	3801      	subs	r0, #1
 80008ee:	005b      	lsls	r3, r3, #1
 80008f0:	fbb0 f3f3 	udiv	r3, r0, r3
 80008f4:	3301      	adds	r3, #1
 80008f6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80008fa:	2b04      	cmp	r3, #4
 80008fc:	bf38      	it	cc
 80008fe:	2304      	movcc	r3, #4
 8000900:	430b      	orrs	r3, r1
 8000902:	61d3      	str	r3, [r2, #28]
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 8000904:	6821      	ldr	r1, [r4, #0]
 8000906:	680b      	ldr	r3, [r1, #0]
 8000908:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800090c:	69e2      	ldr	r2, [r4, #28]
 800090e:	6a20      	ldr	r0, [r4, #32]
 8000910:	4302      	orrs	r2, r0
 8000912:	4313      	orrs	r3, r2
 8000914:	600b      	str	r3, [r1, #0]
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 8000916:	6821      	ldr	r1, [r4, #0]
 8000918:	688b      	ldr	r3, [r1, #8]
 800091a:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 800091e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8000922:	6922      	ldr	r2, [r4, #16]
 8000924:	68e0      	ldr	r0, [r4, #12]
 8000926:	4302      	orrs	r2, r0
 8000928:	4313      	orrs	r3, r2
 800092a:	608b      	str	r3, [r1, #8]
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800092c:	6821      	ldr	r1, [r4, #0]
 800092e:	68cb      	ldr	r3, [r1, #12]
 8000930:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8000934:	6962      	ldr	r2, [r4, #20]
 8000936:	69a0      	ldr	r0, [r4, #24]
 8000938:	4302      	orrs	r2, r0
 800093a:	4313      	orrs	r3, r2
 800093c:	60cb      	str	r3, [r1, #12]
  __HAL_I2C_ENABLE(hi2c);
 800093e:	6822      	ldr	r2, [r4, #0]
 8000940:	6813      	ldr	r3, [r2, #0]
 8000942:	f043 0301 	orr.w	r3, r3, #1
 8000946:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000948:	2000      	movs	r0, #0
 800094a:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800094c:	2320      	movs	r3, #32
 800094e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8000952:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8000954:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  return HAL_OK;
 8000958:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Lock = HAL_UNLOCKED;
 800095a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 800095e:	f007 fead 	bl	80086bc <HAL_I2C_MspInit>
 8000962:	e78e      	b.n	8000882 <HAL_I2C_Init+0x12>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8000964:	4b28      	ldr	r3, [pc, #160]	; (8000a08 <HAL_I2C_Init+0x198>)
 8000966:	4298      	cmp	r0, r3
 8000968:	bf8c      	ite	hi
 800096a:	2300      	movhi	r3, #0
 800096c:	2301      	movls	r3, #1
 800096e:	e79b      	b.n	80008a8 <HAL_I2C_Init+0x38>
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8000970:	f44f 7396 	mov.w	r3, #300	; 0x12c
 8000974:	fb03 f302 	mul.w	r3, r3, r2
 8000978:	4a24      	ldr	r2, [pc, #144]	; (8000a0c <HAL_I2C_Init+0x19c>)
 800097a:	fba2 2303 	umull	r2, r3, r2, r3
 800097e:	099b      	lsrs	r3, r3, #6
 8000980:	3301      	adds	r3, #1
 8000982:	e7a7      	b.n	80008d4 <HAL_I2C_Init+0x64>
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 8000984:	68a6      	ldr	r6, [r4, #8]
 8000986:	b9be      	cbnz	r6, 80009b8 <HAL_I2C_Init+0x148>
 8000988:	1e45      	subs	r5, r0, #1
 800098a:	eb03 0743 	add.w	r7, r3, r3, lsl #1
 800098e:	fbb5 f5f7 	udiv	r5, r5, r7
 8000992:	3501      	adds	r5, #1
 8000994:	f3c5 050b 	ubfx	r5, r5, #0, #12
 8000998:	fab5 f585 	clz	r5, r5
 800099c:	096d      	lsrs	r5, r5, #5
 800099e:	bb35      	cbnz	r5, 80009ee <HAL_I2C_Init+0x17e>
 80009a0:	b9c6      	cbnz	r6, 80009d4 <HAL_I2C_Init+0x164>
 80009a2:	3801      	subs	r0, #1
 80009a4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80009a8:	fbb0 f3f3 	udiv	r3, r0, r3
 80009ac:	3301      	adds	r3, #1
 80009ae:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80009b2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80009b6:	e7a3      	b.n	8000900 <HAL_I2C_Init+0x90>
 80009b8:	1e45      	subs	r5, r0, #1
 80009ba:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 80009be:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 80009c2:	fbb5 f5f7 	udiv	r5, r5, r7
 80009c6:	3501      	adds	r5, #1
 80009c8:	f3c5 050b 	ubfx	r5, r5, #0, #12
 80009cc:	fab5 f585 	clz	r5, r5
 80009d0:	096d      	lsrs	r5, r5, #5
 80009d2:	e7e4      	b.n	800099e <HAL_I2C_Init+0x12e>
 80009d4:	3801      	subs	r0, #1
 80009d6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80009da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80009de:	fbb0 f3f3 	udiv	r3, r0, r3
 80009e2:	3301      	adds	r3, #1
 80009e4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80009e8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80009ec:	e788      	b.n	8000900 <HAL_I2C_Init+0x90>
 80009ee:	2301      	movs	r3, #1
 80009f0:	e786      	b.n	8000900 <HAL_I2C_Init+0x90>
    return HAL_ERROR;
 80009f2:	2001      	movs	r0, #1
 80009f4:	4770      	bx	lr
    return HAL_ERROR;
 80009f6:	2001      	movs	r0, #1
}
 80009f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80009fa:	bf00      	nop
 80009fc:	000186a0 	.word	0x000186a0
 8000a00:	001e847f 	.word	0x001e847f
 8000a04:	431bde83 	.word	0x431bde83
 8000a08:	003d08ff 	.word	0x003d08ff
 8000a0c:	10624dd3 	.word	0x10624dd3

08000a10 <HAL_I2C_Master_Transmit>:
{
 8000a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000a14:	b084      	sub	sp, #16
 8000a16:	4604      	mov	r4, r0
 8000a18:	460d      	mov	r5, r1
 8000a1a:	4690      	mov	r8, r2
 8000a1c:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
 8000a1e:	f7ff fc4d 	bl	80002bc <HAL_GetTick>
  if (hi2c->State == HAL_I2C_STATE_READY)
 8000a22:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8000a26:	b2db      	uxtb	r3, r3
 8000a28:	2b20      	cmp	r3, #32
 8000a2a:	d004      	beq.n	8000a36 <HAL_I2C_Master_Transmit+0x26>
    return HAL_BUSY;
 8000a2c:	2502      	movs	r5, #2
}
 8000a2e:	4628      	mov	r0, r5
 8000a30:	b004      	add	sp, #16
 8000a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a36:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 8000a38:	9000      	str	r0, [sp, #0]
 8000a3a:	2319      	movs	r3, #25
 8000a3c:	2201      	movs	r2, #1
 8000a3e:	494f      	ldr	r1, [pc, #316]	; (8000b7c <HAL_I2C_Master_Transmit+0x16c>)
 8000a40:	4620      	mov	r0, r4
 8000a42:	f7ff fde3 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000a46:	b108      	cbz	r0, 8000a4c <HAL_I2C_Master_Transmit+0x3c>
      return HAL_BUSY;
 8000a48:	2502      	movs	r5, #2
 8000a4a:	e7f0      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
    __HAL_LOCK(hi2c);
 8000a4c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8000a50:	2b01      	cmp	r3, #1
 8000a52:	f000 808e 	beq.w	8000b72 <HAL_I2C_Master_Transmit+0x162>
 8000a56:	2301      	movs	r3, #1
 8000a58:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8000a5c:	6823      	ldr	r3, [r4, #0]
 8000a5e:	681a      	ldr	r2, [r3, #0]
 8000a60:	f012 0f01 	tst.w	r2, #1
 8000a64:	d103      	bne.n	8000a6e <HAL_I2C_Master_Transmit+0x5e>
      __HAL_I2C_ENABLE(hi2c);
 8000a66:	681a      	ldr	r2, [r3, #0]
 8000a68:	f042 0201 	orr.w	r2, r2, #1
 8000a6c:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8000a6e:	6822      	ldr	r2, [r4, #0]
 8000a70:	6813      	ldr	r3, [r2, #0]
 8000a72:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000a76:	6013      	str	r3, [r2, #0]
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 8000a78:	2321      	movs	r3, #33	; 0x21
 8000a7a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 8000a7e:	2310      	movs	r3, #16
 8000a80:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 8000a84:	2300      	movs	r3, #0
 8000a86:	6423      	str	r3, [r4, #64]	; 0x40
    hi2c->pBuffPtr    = pData;
 8000a88:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
    hi2c->XferCount   = Size;
 8000a8c:	8567      	strh	r7, [r4, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 8000a8e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8000a90:	8523      	strh	r3, [r4, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8000a92:	4b3b      	ldr	r3, [pc, #236]	; (8000b80 <HAL_I2C_Master_Transmit+0x170>)
 8000a94:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
 8000a96:	4633      	mov	r3, r6
 8000a98:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000a9a:	4629      	mov	r1, r5
 8000a9c:	4620      	mov	r0, r4
 8000a9e:	f7ff fe3f 	bl	8000720 <I2C_MasterRequestWrite>
 8000aa2:	4605      	mov	r5, r0
 8000aa4:	2800      	cmp	r0, #0
 8000aa6:	d166      	bne.n	8000b76 <HAL_I2C_Master_Transmit+0x166>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000aa8:	2300      	movs	r3, #0
 8000aaa:	9303      	str	r3, [sp, #12]
 8000aac:	6823      	ldr	r3, [r4, #0]
 8000aae:	695a      	ldr	r2, [r3, #20]
 8000ab0:	9203      	str	r2, [sp, #12]
 8000ab2:	699b      	ldr	r3, [r3, #24]
 8000ab4:	9303      	str	r3, [sp, #12]
 8000ab6:	9b03      	ldr	r3, [sp, #12]
    while (hi2c->XferSize > 0U)
 8000ab8:	e012      	b.n	8000ae0 <HAL_I2C_Master_Transmit+0xd0>
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000aba:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000abc:	2b04      	cmp	r3, #4
 8000abe:	d001      	beq.n	8000ac4 <HAL_I2C_Master_Transmit+0xb4>
        return HAL_ERROR;
 8000ac0:	2501      	movs	r5, #1
 8000ac2:	e7b4      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000ac4:	6822      	ldr	r2, [r4, #0]
 8000ac6:	6813      	ldr	r3, [r2, #0]
 8000ac8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000acc:	6013      	str	r3, [r2, #0]
        return HAL_ERROR;
 8000ace:	2501      	movs	r5, #1
 8000ad0:	e7ad      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
      if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8000ad2:	4632      	mov	r2, r6
 8000ad4:	990a      	ldr	r1, [sp, #40]	; 0x28
 8000ad6:	4620      	mov	r0, r4
 8000ad8:	f7ff fea0 	bl	800081c <I2C_WaitOnBTFFlagUntilTimeout>
 8000adc:	2800      	cmp	r0, #0
 8000ade:	d12e      	bne.n	8000b3e <HAL_I2C_Master_Transmit+0x12e>
    while (hi2c->XferSize > 0U)
 8000ae0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8000ae2:	2b00      	cmp	r3, #0
 8000ae4:	d037      	beq.n	8000b56 <HAL_I2C_Master_Transmit+0x146>
      if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8000ae6:	4632      	mov	r2, r6
 8000ae8:	990a      	ldr	r1, [sp, #40]	; 0x28
 8000aea:	4620      	mov	r0, r4
 8000aec:	f7ff fe6c 	bl	80007c8 <I2C_WaitOnTXEFlagUntilTimeout>
 8000af0:	2800      	cmp	r0, #0
 8000af2:	d1e2      	bne.n	8000aba <HAL_I2C_Master_Transmit+0xaa>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8000af4:	6823      	ldr	r3, [r4, #0]
 8000af6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000af8:	7812      	ldrb	r2, [r2, #0]
 8000afa:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 8000afc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000afe:	1c4b      	adds	r3, r1, #1
 8000b00:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8000b02:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8000b04:	b29b      	uxth	r3, r3
 8000b06:	3b01      	subs	r3, #1
 8000b08:	b29b      	uxth	r3, r3
 8000b0a:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8000b0c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8000b0e:	3b01      	subs	r3, #1
 8000b10:	b29b      	uxth	r3, r3
 8000b12:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 8000b14:	6822      	ldr	r2, [r4, #0]
 8000b16:	6950      	ldr	r0, [r2, #20]
 8000b18:	f010 0f04 	tst.w	r0, #4
 8000b1c:	d0d9      	beq.n	8000ad2 <HAL_I2C_Master_Transmit+0xc2>
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d0d7      	beq.n	8000ad2 <HAL_I2C_Master_Transmit+0xc2>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8000b22:	784b      	ldrb	r3, [r1, #1]
 8000b24:	6113      	str	r3, [r2, #16]
        hi2c->pBuffPtr++;
 8000b26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000b28:	3301      	adds	r3, #1
 8000b2a:	6263      	str	r3, [r4, #36]	; 0x24
        hi2c->XferCount--;
 8000b2c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8000b2e:	b29b      	uxth	r3, r3
 8000b30:	3b01      	subs	r3, #1
 8000b32:	b29b      	uxth	r3, r3
 8000b34:	8563      	strh	r3, [r4, #42]	; 0x2a
        hi2c->XferSize--;
 8000b36:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8000b38:	3b01      	subs	r3, #1
 8000b3a:	8523      	strh	r3, [r4, #40]	; 0x28
 8000b3c:	e7c9      	b.n	8000ad2 <HAL_I2C_Master_Transmit+0xc2>
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000b3e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000b40:	2b04      	cmp	r3, #4
 8000b42:	d001      	beq.n	8000b48 <HAL_I2C_Master_Transmit+0x138>
        return HAL_ERROR;
 8000b44:	2501      	movs	r5, #1
 8000b46:	e772      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000b48:	6822      	ldr	r2, [r4, #0]
 8000b4a:	6813      	ldr	r3, [r2, #0]
 8000b4c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000b50:	6013      	str	r3, [r2, #0]
        return HAL_ERROR;
 8000b52:	2501      	movs	r5, #1
 8000b54:	e76b      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000b56:	6822      	ldr	r2, [r4, #0]
 8000b58:	6813      	ldr	r3, [r2, #0]
 8000b5a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000b5e:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8000b60:	2320      	movs	r3, #32
 8000b62:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8000b66:	2300      	movs	r3, #0
 8000b68:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    __HAL_UNLOCK(hi2c);
 8000b6c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    return HAL_OK;
 8000b70:	e75d      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
    __HAL_LOCK(hi2c);
 8000b72:	2502      	movs	r5, #2
 8000b74:	e75b      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
      return HAL_ERROR;
 8000b76:	2501      	movs	r5, #1
 8000b78:	e759      	b.n	8000a2e <HAL_I2C_Master_Transmit+0x1e>
 8000b7a:	bf00      	nop
 8000b7c:	00100002 	.word	0x00100002
 8000b80:	ffff0000 	.word	0xffff0000

08000b84 <HAL_I2C_IsDeviceReady>:
{
 8000b84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000b88:	b085      	sub	sp, #20
 8000b8a:	4604      	mov	r4, r0
 8000b8c:	460f      	mov	r7, r1
 8000b8e:	4690      	mov	r8, r2
 8000b90:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
 8000b92:	f7ff fb93 	bl	80002bc <HAL_GetTick>
  if (hi2c->State == HAL_I2C_STATE_READY)
 8000b96:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8000b9a:	b2db      	uxtb	r3, r3
 8000b9c:	2b20      	cmp	r3, #32
 8000b9e:	d004      	beq.n	8000baa <HAL_I2C_IsDeviceReady+0x26>
    return HAL_BUSY;
 8000ba0:	2302      	movs	r3, #2
}
 8000ba2:	4618      	mov	r0, r3
 8000ba4:	b005      	add	sp, #20
 8000ba6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000baa:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 8000bac:	9000      	str	r0, [sp, #0]
 8000bae:	2319      	movs	r3, #25
 8000bb0:	2201      	movs	r2, #1
 8000bb2:	4954      	ldr	r1, [pc, #336]	; (8000d04 <HAL_I2C_IsDeviceReady+0x180>)
 8000bb4:	4620      	mov	r0, r4
 8000bb6:	f7ff fd29 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000bba:	b108      	cbz	r0, 8000bc0 <HAL_I2C_IsDeviceReady+0x3c>
      return HAL_BUSY;
 8000bbc:	2302      	movs	r3, #2
 8000bbe:	e7f0      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
    __HAL_LOCK(hi2c);
 8000bc0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8000bc4:	2b01      	cmp	r3, #1
 8000bc6:	f000 8094 	beq.w	8000cf2 <HAL_I2C_IsDeviceReady+0x16e>
 8000bca:	2301      	movs	r3, #1
 8000bcc:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8000bd0:	6823      	ldr	r3, [r4, #0]
 8000bd2:	681a      	ldr	r2, [r3, #0]
 8000bd4:	f012 0f01 	tst.w	r2, #1
 8000bd8:	d103      	bne.n	8000be2 <HAL_I2C_IsDeviceReady+0x5e>
      __HAL_I2C_ENABLE(hi2c);
 8000bda:	681a      	ldr	r2, [r3, #0]
 8000bdc:	f042 0201 	orr.w	r2, r2, #1
 8000be0:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8000be2:	6822      	ldr	r2, [r4, #0]
 8000be4:	6813      	ldr	r3, [r2, #0]
 8000be6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000bea:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8000bec:	2324      	movs	r3, #36	; 0x24
 8000bee:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000bf2:	2300      	movs	r3, #0
 8000bf4:	6423      	str	r3, [r4, #64]	; 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8000bf6:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
 8000bfa:	62e3      	str	r3, [r4, #44]	; 0x2c
  uint32_t I2C_Trials = 1U;
 8000bfc:	f04f 0901 	mov.w	r9, #1
 8000c00:	e035      	b.n	8000c6e <HAL_I2C_IsDeviceReady+0xea>
          hi2c->State = HAL_I2C_STATE_TIMEOUT;
 8000c02:	23a0      	movs	r3, #160	; 0xa0
 8000c04:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
 8000c08:	6823      	ldr	r3, [r4, #0]
 8000c0a:	695a      	ldr	r2, [r3, #20]
 8000c0c:	f3c2 0240 	ubfx	r2, r2, #1, #1
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
 8000c10:	6959      	ldr	r1, [r3, #20]
 8000c12:	f3c1 2180 	ubfx	r1, r1, #10, #1
      while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
 8000c16:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8000c1a:	b2db      	uxtb	r3, r3
 8000c1c:	2ba0      	cmp	r3, #160	; 0xa0
 8000c1e:	d009      	beq.n	8000c34 <HAL_I2C_IsDeviceReady+0xb0>
 8000c20:	b942      	cbnz	r2, 8000c34 <HAL_I2C_IsDeviceReady+0xb0>
 8000c22:	b939      	cbnz	r1, 8000c34 <HAL_I2C_IsDeviceReady+0xb0>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8000c24:	f7ff fb4a 	bl	80002bc <HAL_GetTick>
 8000c28:	1b80      	subs	r0, r0, r6
 8000c2a:	4285      	cmp	r5, r0
 8000c2c:	d3e9      	bcc.n	8000c02 <HAL_I2C_IsDeviceReady+0x7e>
 8000c2e:	2d00      	cmp	r5, #0
 8000c30:	d1ea      	bne.n	8000c08 <HAL_I2C_IsDeviceReady+0x84>
 8000c32:	e7e6      	b.n	8000c02 <HAL_I2C_IsDeviceReady+0x7e>
      hi2c->State = HAL_I2C_STATE_READY;
 8000c34:	2320      	movs	r3, #32
 8000c36:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
 8000c3a:	6823      	ldr	r3, [r4, #0]
 8000c3c:	695a      	ldr	r2, [r3, #20]
 8000c3e:	f012 0f02 	tst.w	r2, #2
 8000c42:	d132      	bne.n	8000caa <HAL_I2C_IsDeviceReady+0x126>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000c44:	681a      	ldr	r2, [r3, #0]
 8000c46:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000c4a:	601a      	str	r2, [r3, #0]
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000c4c:	6823      	ldr	r3, [r4, #0]
 8000c4e:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8000c52:	615a      	str	r2, [r3, #20]
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 8000c54:	9600      	str	r6, [sp, #0]
 8000c56:	2319      	movs	r3, #25
 8000c58:	2201      	movs	r2, #1
 8000c5a:	492a      	ldr	r1, [pc, #168]	; (8000d04 <HAL_I2C_IsDeviceReady+0x180>)
 8000c5c:	4620      	mov	r0, r4
 8000c5e:	f7ff fcd5 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000c62:	2800      	cmp	r0, #0
 8000c64:	d14b      	bne.n	8000cfe <HAL_I2C_IsDeviceReady+0x17a>
      I2C_Trials++;
 8000c66:	f109 0901 	add.w	r9, r9, #1
    while (I2C_Trials < Trials);
 8000c6a:	45c1      	cmp	r9, r8
 8000c6c:	d239      	bcs.n	8000ce2 <HAL_I2C_IsDeviceReady+0x15e>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8000c6e:	6822      	ldr	r2, [r4, #0]
 8000c70:	6813      	ldr	r3, [r2, #0]
 8000c72:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000c76:	6013      	str	r3, [r2, #0]
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
 8000c78:	9600      	str	r6, [sp, #0]
 8000c7a:	462b      	mov	r3, r5
 8000c7c:	2200      	movs	r2, #0
 8000c7e:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8000c82:	4620      	mov	r0, r4
 8000c84:	f7ff fcc2 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000c88:	2800      	cmp	r0, #0
 8000c8a:	d134      	bne.n	8000cf6 <HAL_I2C_IsDeviceReady+0x172>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 8000c8c:	6823      	ldr	r3, [r4, #0]
 8000c8e:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
 8000c92:	611a      	str	r2, [r3, #16]
      tickstart = HAL_GetTick();
 8000c94:	f7ff fb12 	bl	80002bc <HAL_GetTick>
 8000c98:	4606      	mov	r6, r0
      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
 8000c9a:	6823      	ldr	r3, [r4, #0]
 8000c9c:	695a      	ldr	r2, [r3, #20]
 8000c9e:	f3c2 0240 	ubfx	r2, r2, #1, #1
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
 8000ca2:	6959      	ldr	r1, [r3, #20]
 8000ca4:	f3c1 2180 	ubfx	r1, r1, #10, #1
      while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
 8000ca8:	e7b5      	b.n	8000c16 <HAL_I2C_IsDeviceReady+0x92>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8000caa:	681a      	ldr	r2, [r3, #0]
 8000cac:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000cb0:	601a      	str	r2, [r3, #0]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000cb2:	2300      	movs	r3, #0
 8000cb4:	9303      	str	r3, [sp, #12]
 8000cb6:	6823      	ldr	r3, [r4, #0]
 8000cb8:	695a      	ldr	r2, [r3, #20]
 8000cba:	9203      	str	r2, [sp, #12]
 8000cbc:	699b      	ldr	r3, [r3, #24]
 8000cbe:	9303      	str	r3, [sp, #12]
 8000cc0:	9b03      	ldr	r3, [sp, #12]
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 8000cc2:	9600      	str	r6, [sp, #0]
 8000cc4:	2319      	movs	r3, #25
 8000cc6:	2201      	movs	r2, #1
 8000cc8:	490e      	ldr	r1, [pc, #56]	; (8000d04 <HAL_I2C_IsDeviceReady+0x180>)
 8000cca:	4620      	mov	r0, r4
 8000ccc:	f7ff fc9e 	bl	800060c <I2C_WaitOnFlagUntilTimeout>
 8000cd0:	4603      	mov	r3, r0
 8000cd2:	b990      	cbnz	r0, 8000cfa <HAL_I2C_IsDeviceReady+0x176>
        hi2c->State = HAL_I2C_STATE_READY;
 8000cd4:	2220      	movs	r2, #32
 8000cd6:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        __HAL_UNLOCK(hi2c);
 8000cda:	2200      	movs	r2, #0
 8000cdc:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        return HAL_OK;
 8000ce0:	e75f      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
 8000ce2:	2320      	movs	r3, #32
 8000ce4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    __HAL_UNLOCK(hi2c);
 8000ce8:	2300      	movs	r3, #0
 8000cea:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    return HAL_ERROR;
 8000cee:	2301      	movs	r3, #1
 8000cf0:	e757      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
    __HAL_LOCK(hi2c);
 8000cf2:	2302      	movs	r3, #2
 8000cf4:	e755      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
        return HAL_ERROR;
 8000cf6:	2301      	movs	r3, #1
 8000cf8:	e753      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
          return HAL_ERROR;
 8000cfa:	2301      	movs	r3, #1
 8000cfc:	e751      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
          return HAL_ERROR;
 8000cfe:	2301      	movs	r3, #1
 8000d00:	e74f      	b.n	8000ba2 <HAL_I2C_IsDeviceReady+0x1e>
 8000d02:	bf00      	nop
 8000d04:	00100002 	.word	0x00100002

08000d08 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8000d08:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d0a:	b087      	sub	sp, #28
  USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8000d0c:	2800      	cmp	r0, #0
 8000d0e:	d073      	beq.n	8000df8 <HAL_PCD_Init+0xf0>
 8000d10:	4604      	mov	r4, r0

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8000d12:	f890 3229 	ldrb.w	r3, [r0, #553]	; 0x229
 8000d16:	b1d3      	cbz	r3, 8000d4e <HAL_PCD_Init+0x46>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000d18:	2303      	movs	r3, #3
 8000d1a:	f884 3229 	strb.w	r3, [r4, #553]	; 0x229
    hpcd->Init.dma_enable = 0U;
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8000d1e:	6820      	ldr	r0, [r4, #0]
 8000d20:	f002 fec9 	bl	8003ab6 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8000d24:	4625      	mov	r5, r4
 8000d26:	f855 7b10 	ldr.w	r7, [r5], #16
 8000d2a:	466e      	mov	r6, sp
 8000d2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d2e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000d30:	682b      	ldr	r3, [r5, #0]
 8000d32:	6033      	str	r3, [r6, #0]
 8000d34:	1d23      	adds	r3, r4, #4
 8000d36:	cb0e      	ldmia	r3, {r1, r2, r3}
 8000d38:	4638      	mov	r0, r7
 8000d3a:	f002 feac 	bl	8003a96 <USB_CoreInit>
 8000d3e:	b158      	cbz	r0, 8000d58 <HAL_PCD_Init+0x50>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8000d40:	2302      	movs	r3, #2
 8000d42:	f884 3229 	strb.w	r3, [r4, #553]	; 0x229
    return HAL_ERROR;
 8000d46:	2501      	movs	r5, #1
  hpcd->USB_Address = 0U;
  hpcd->State = HAL_PCD_STATE_READY;
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 8000d48:	4628      	mov	r0, r5
 8000d4a:	b007      	add	sp, #28
 8000d4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 8000d4e:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
    HAL_PCD_MspInit(hpcd);
 8000d52:	f007 fe89 	bl	8008a68 <HAL_PCD_MspInit>
 8000d56:	e7df      	b.n	8000d18 <HAL_PCD_Init+0x10>
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 8000d58:	2100      	movs	r1, #0
 8000d5a:	6820      	ldr	r0, [r4, #0]
 8000d5c:	f002 feb5 	bl	8003aca <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000d60:	2300      	movs	r3, #0
 8000d62:	e011      	b.n	8000d88 <HAL_PCD_Init+0x80>
    hpcd->IN_ep[i].is_in = 1U;
 8000d64:	eb04 1243 	add.w	r2, r4, r3, lsl #5
 8000d68:	2101      	movs	r1, #1
 8000d6a:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
    hpcd->IN_ep[i].num = i;
 8000d6e:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    hpcd->IN_ep[i].tx_fifo_num = i;
 8000d72:	86d3      	strh	r3, [r2, #54]	; 0x36
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000d74:	2100      	movs	r1, #0
 8000d76:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
    hpcd->IN_ep[i].maxpacket = 0U;
 8000d7a:	6391      	str	r1, [r2, #56]	; 0x38
    hpcd->IN_ep[i].xfer_buff = 0U;
 8000d7c:	63d1      	str	r1, [r2, #60]	; 0x3c
    hpcd->IN_ep[i].xfer_len = 0U;
 8000d7e:	1c9a      	adds	r2, r3, #2
 8000d80:	0152      	lsls	r2, r2, #5
 8000d82:	50a1      	str	r1, [r4, r2]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000d84:	3301      	adds	r3, #1
 8000d86:	b2db      	uxtb	r3, r3
 8000d88:	6860      	ldr	r0, [r4, #4]
 8000d8a:	4283      	cmp	r3, r0
 8000d8c:	d3ea      	bcc.n	8000d64 <HAL_PCD_Init+0x5c>
 8000d8e:	2300      	movs	r3, #0
 8000d90:	e012      	b.n	8000db8 <HAL_PCD_Init+0xb0>
    hpcd->OUT_ep[i].is_in = 0U;
 8000d92:	eb04 1143 	add.w	r1, r4, r3, lsl #5
 8000d96:	2200      	movs	r2, #0
 8000d98:	f881 2129 	strb.w	r2, [r1, #297]	; 0x129
    hpcd->OUT_ep[i].num = i;
 8000d9c:	f881 3128 	strb.w	r3, [r1, #296]	; 0x128
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000da0:	f881 212b 	strb.w	r2, [r1, #299]	; 0x12b
    hpcd->OUT_ep[i].maxpacket = 0U;
 8000da4:	f8c1 2138 	str.w	r2, [r1, #312]	; 0x138
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8000da8:	f8c1 213c 	str.w	r2, [r1, #316]	; 0x13c
    hpcd->OUT_ep[i].xfer_len = 0U;
 8000dac:	f103 010a 	add.w	r1, r3, #10
 8000db0:	0149      	lsls	r1, r1, #5
 8000db2:	5062      	str	r2, [r4, r1]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000db4:	3301      	adds	r3, #1
 8000db6:	b2db      	uxtb	r3, r3
 8000db8:	4298      	cmp	r0, r3
 8000dba:	d8ea      	bhi.n	8000d92 <HAL_PCD_Init+0x8a>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8000dbc:	4625      	mov	r5, r4
 8000dbe:	f855 7b10 	ldr.w	r7, [r5], #16
 8000dc2:	466e      	mov	r6, sp
 8000dc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000dc6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000dc8:	682b      	ldr	r3, [r5, #0]
 8000dca:	6033      	str	r3, [r6, #0]
 8000dcc:	1d23      	adds	r3, r4, #4
 8000dce:	cb0e      	ldmia	r3, {r1, r2, r3}
 8000dd0:	4638      	mov	r0, r7
 8000dd2:	f002 fe7c 	bl	8003ace <USB_DevInit>
 8000dd6:	4605      	mov	r5, r0
 8000dd8:	b120      	cbz	r0, 8000de4 <HAL_PCD_Init+0xdc>
    hpcd->State = HAL_PCD_STATE_ERROR;
 8000dda:	2302      	movs	r3, #2
 8000ddc:	f884 3229 	strb.w	r3, [r4, #553]	; 0x229
    return HAL_ERROR;
 8000de0:	2501      	movs	r5, #1
 8000de2:	e7b1      	b.n	8000d48 <HAL_PCD_Init+0x40>
  hpcd->USB_Address = 0U;
 8000de4:	2300      	movs	r3, #0
 8000de6:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  hpcd->State = HAL_PCD_STATE_READY;
 8000dea:	2301      	movs	r3, #1
 8000dec:	f884 3229 	strb.w	r3, [r4, #553]	; 0x229
  (void)USB_DevDisconnect(hpcd->Instance);
 8000df0:	6820      	ldr	r0, [r4, #0]
 8000df2:	f003 f9aa 	bl	800414a <USB_DevDisconnect>
  return HAL_OK;
 8000df6:	e7a7      	b.n	8000d48 <HAL_PCD_Init+0x40>
    return HAL_ERROR;
 8000df8:	2501      	movs	r5, #1
 8000dfa:	e7a5      	b.n	8000d48 <HAL_PCD_Init+0x40>

08000dfc <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 8000dfc:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8000e00:	2b01      	cmp	r3, #1
 8000e02:	d101      	bne.n	8000e08 <HAL_PCD_Start+0xc>
 8000e04:	2002      	movs	r0, #2
 8000e06:	4770      	bx	lr
{
 8000e08:	b510      	push	{r4, lr}
 8000e0a:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8000e0c:	2101      	movs	r1, #1
 8000e0e:	f880 1228 	strb.w	r1, [r0, #552]	; 0x228
#if defined (USB)
  HAL_PCDEx_SetConnectionState(hpcd, 1U);
 8000e12:	f007 ff34 	bl	8008c7e <HAL_PCDEx_SetConnectionState>
#endif /* defined (USB) */
  (void)USB_DevConnect(hpcd->Instance);
 8000e16:	6820      	ldr	r0, [r4, #0]
 8000e18:	f003 f995 	bl	8004146 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8000e1c:	6820      	ldr	r0, [r4, #0]
 8000e1e:	f002 fe41 	bl	8003aa4 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 8000e22:	2000      	movs	r0, #0
 8000e24:	f884 0228 	strb.w	r0, [r4, #552]	; 0x228
  return HAL_OK;
 8000e28:	bd10      	pop	{r4, pc}

08000e2a <HAL_PCD_SetAddress>:
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd);
 8000e2a:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8000e2e:	2b01      	cmp	r3, #1
 8000e30:	d101      	bne.n	8000e36 <HAL_PCD_SetAddress+0xc>
 8000e32:	2002      	movs	r0, #2
 8000e34:	4770      	bx	lr
{
 8000e36:	b510      	push	{r4, lr}
 8000e38:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8000e3a:	2301      	movs	r3, #1
 8000e3c:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
  hpcd->USB_Address = address;
 8000e40:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8000e44:	6800      	ldr	r0, [r0, #0]
 8000e46:	f003 f978 	bl	800413a <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8000e4a:	2000      	movs	r0, #0
 8000e4c:	f884 0228 	strb.w	r0, [r4, #552]	; 0x228
  return HAL_OK;
 8000e50:	bd10      	pop	{r4, pc}

08000e52 <HAL_PCD_EP_Open>:
  * @param  ep_mps endpoint max packet size
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8000e52:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8000e54:	f011 0f80 	tst.w	r1, #128	; 0x80
 8000e58:	d119      	bne.n	8000e8e <HAL_PCD_EP_Open+0x3c>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 1U;
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8000e5a:	f001 0507 	and.w	r5, r1, #7
 8000e5e:	016d      	lsls	r5, r5, #5
 8000e60:	f505 7494 	add.w	r4, r5, #296	; 0x128
 8000e64:	4404      	add	r4, r0
    ep->is_in = 0U;
 8000e66:	4405      	add	r5, r0
 8000e68:	2600      	movs	r6, #0
 8000e6a:	f885 6129 	strb.w	r6, [r5, #297]	; 0x129
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8000e6e:	f001 0107 	and.w	r1, r1, #7
 8000e72:	7021      	strb	r1, [r4, #0]
  ep->maxpacket = ep_mps;
 8000e74:	6122      	str	r2, [r4, #16]
  ep->type = ep_type;
 8000e76:	70e3      	strb	r3, [r4, #3]

  if (ep->is_in != 0U)
 8000e78:	7862      	ldrb	r2, [r4, #1]
 8000e7a:	b102      	cbz	r2, 8000e7e <HAL_PCD_EP_Open+0x2c>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8000e7c:	81e1      	strh	r1, [r4, #14]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8000e7e:	2b02      	cmp	r3, #2
 8000e80:	d010      	beq.n	8000ea4 <HAL_PCD_EP_Open+0x52>
  {
    ep->data_pid_start = 0U;
  }

  __HAL_LOCK(hpcd);
 8000e82:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8000e86:	2b01      	cmp	r3, #1
 8000e88:	d10f      	bne.n	8000eaa <HAL_PCD_EP_Open+0x58>
 8000e8a:	2002      	movs	r0, #2
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
  __HAL_UNLOCK(hpcd);

  return ret;
}
 8000e8c:	bd70      	pop	{r4, r5, r6, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8000e8e:	f001 0507 	and.w	r5, r1, #7
 8000e92:	016d      	lsls	r5, r5, #5
 8000e94:	f105 0428 	add.w	r4, r5, #40	; 0x28
 8000e98:	4404      	add	r4, r0
    ep->is_in = 1U;
 8000e9a:	4405      	add	r5, r0
 8000e9c:	2601      	movs	r6, #1
 8000e9e:	f885 6029 	strb.w	r6, [r5, #41]	; 0x29
 8000ea2:	e7e4      	b.n	8000e6e <HAL_PCD_EP_Open+0x1c>
    ep->data_pid_start = 0U;
 8000ea4:	2300      	movs	r3, #0
 8000ea6:	7123      	strb	r3, [r4, #4]
 8000ea8:	e7eb      	b.n	8000e82 <HAL_PCD_EP_Open+0x30>
 8000eaa:	4605      	mov	r5, r0
  __HAL_LOCK(hpcd);
 8000eac:	2301      	movs	r3, #1
 8000eae:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8000eb2:	4621      	mov	r1, r4
 8000eb4:	6800      	ldr	r0, [r0, #0]
 8000eb6:	f002 fe20 	bl	8003afa <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8000eba:	2000      	movs	r0, #0
 8000ebc:	f885 0228 	strb.w	r0, [r5, #552]	; 0x228
  return ret;
 8000ec0:	bd70      	pop	{r4, r5, r6, pc}

08000ec2 <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8000ec2:	b510      	push	{r4, lr}
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8000ec4:	f011 0f80 	tst.w	r1, #128	; 0x80
 8000ec8:	d112      	bne.n	8000ef0 <HAL_PCD_EP_Close+0x2e>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 1U;
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8000eca:	f001 0307 	and.w	r3, r1, #7
 8000ece:	015b      	lsls	r3, r3, #5
 8000ed0:	f503 7294 	add.w	r2, r3, #296	; 0x128
 8000ed4:	4402      	add	r2, r0
    ep->is_in = 0U;
 8000ed6:	4403      	add	r3, r0
 8000ed8:	2400      	movs	r4, #0
 8000eda:	f883 4129 	strb.w	r4, [r3, #297]	; 0x129
  }
  ep->num   = ep_addr & EP_ADDR_MSK;
 8000ede:	f001 0307 	and.w	r3, r1, #7
 8000ee2:	7013      	strb	r3, [r2, #0]

  __HAL_LOCK(hpcd);
 8000ee4:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8000ee8:	2b01      	cmp	r3, #1
 8000eea:	d10c      	bne.n	8000f06 <HAL_PCD_EP_Close+0x44>
 8000eec:	2002      	movs	r0, #2
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
  __HAL_UNLOCK(hpcd);
  return HAL_OK;
}
 8000eee:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8000ef0:	f001 0307 	and.w	r3, r1, #7
 8000ef4:	015b      	lsls	r3, r3, #5
 8000ef6:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8000efa:	4402      	add	r2, r0
    ep->is_in = 1U;
 8000efc:	4403      	add	r3, r0
 8000efe:	2401      	movs	r4, #1
 8000f00:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
 8000f04:	e7eb      	b.n	8000ede <HAL_PCD_EP_Close+0x1c>
 8000f06:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8000f08:	2301      	movs	r3, #1
 8000f0a:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8000f0e:	4611      	mov	r1, r2
 8000f10:	6800      	ldr	r0, [r0, #0]
 8000f12:	f002 ffb2 	bl	8003e7a <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8000f16:	2000      	movs	r0, #0
 8000f18:	f884 0228 	strb.w	r0, [r4, #552]	; 0x228
  return HAL_OK;
 8000f1c:	bd10      	pop	{r4, pc}

08000f1e <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000f1e:	b570      	push	{r4, r5, r6, lr}
 8000f20:	f001 0507 	and.w	r5, r1, #7
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8000f24:	016c      	lsls	r4, r5, #5
 8000f26:	f504 7194 	add.w	r1, r4, #296	; 0x128
 8000f2a:	4401      	add	r1, r0

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8000f2c:	4404      	add	r4, r0
 8000f2e:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
  ep->xfer_len = len;
 8000f32:	f105 020a 	add.w	r2, r5, #10
 8000f36:	0152      	lsls	r2, r2, #5
 8000f38:	1886      	adds	r6, r0, r2
 8000f3a:	5083      	str	r3, [r0, r2]
  ep->xfer_count = 0U;
 8000f3c:	2300      	movs	r3, #0
 8000f3e:	6073      	str	r3, [r6, #4]
  ep->is_in = 0U;
 8000f40:	f884 3129 	strb.w	r3, [r4, #297]	; 0x129
  ep->num = ep_addr & EP_ADDR_MSK;
 8000f44:	f884 5128 	strb.w	r5, [r4, #296]	; 0x128

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8000f48:	b125      	cbz	r5, 8000f54 <HAL_PCD_EP_Receive+0x36>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8000f4a:	6800      	ldr	r0, [r0, #0]
 8000f4c:	f003 f91a 	bl	8004184 <USB_EPStartXfer>
  }

  return HAL_OK;
}
 8000f50:	2000      	movs	r0, #0
 8000f52:	bd70      	pop	{r4, r5, r6, pc}
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000f54:	6800      	ldr	r0, [r0, #0]
 8000f56:	f003 f915 	bl	8004184 <USB_EPStartXfer>
 8000f5a:	e7f9      	b.n	8000f50 <HAL_PCD_EP_Receive+0x32>

08000f5c <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8000f5c:	f001 0107 	and.w	r1, r1, #7
 8000f60:	310a      	adds	r1, #10
 8000f62:	eb00 1141 	add.w	r1, r0, r1, lsl #5
}
 8000f66:	6848      	ldr	r0, [r1, #4]
 8000f68:	4770      	bx	lr

08000f6a <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000f6a:	b570      	push	{r4, r5, r6, lr}
 8000f6c:	f001 0507 	and.w	r5, r1, #7
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8000f70:	016c      	lsls	r4, r5, #5
 8000f72:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8000f76:	4401      	add	r1, r0

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8000f78:	4404      	add	r4, r0
 8000f7a:	63e2      	str	r2, [r4, #60]	; 0x3c
  ep->xfer_len = len;
 8000f7c:	1caa      	adds	r2, r5, #2
 8000f7e:	0152      	lsls	r2, r2, #5
 8000f80:	1886      	adds	r6, r0, r2
 8000f82:	5083      	str	r3, [r0, r2]
  ep->xfer_count = 0U;
 8000f84:	2300      	movs	r3, #0
 8000f86:	6073      	str	r3, [r6, #4]
  ep->is_in = 1U;
 8000f88:	2301      	movs	r3, #1
 8000f8a:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  ep->num = ep_addr & EP_ADDR_MSK;
 8000f8e:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8000f92:	b125      	cbz	r5, 8000f9e <HAL_PCD_EP_Transmit+0x34>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8000f94:	6800      	ldr	r0, [r0, #0]
 8000f96:	f003 f8f5 	bl	8004184 <USB_EPStartXfer>
  }

  return HAL_OK;
}
 8000f9a:	2000      	movs	r0, #0
 8000f9c:	bd70      	pop	{r4, r5, r6, pc}
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8000f9e:	6800      	ldr	r0, [r0, #0]
 8000fa0:	f003 f8f0 	bl	8004184 <USB_EPStartXfer>
 8000fa4:	e7f9      	b.n	8000f9a <HAL_PCD_EP_Transmit+0x30>

08000fa6 <PCD_EP_ISR_Handler>:
  * @brief  This function handles PCD Endpoint interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
 8000fa6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000fa8:	4604      	mov	r4, r0
  uint16_t wIstr;
  uint16_t wEPVal;
  uint8_t epindex;

  /* stay in loop while pending interrupts */
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 8000faa:	e0ac      	b.n	8001106 <PCD_EP_ISR_Handler+0x160>
      {
        /* DIR = 0 */

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8000fac:	8803      	ldrh	r3, [r0, #0]
 8000fae:	b29b      	uxth	r3, r3
 8000fb0:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 8000fb4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000fb8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8000fbc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8000fc0:	b29b      	uxth	r3, r3
 8000fc2:	8003      	strh	r3, [r0, #0]
        ep = &hpcd->IN_ep[0];

        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000fc4:	6822      	ldr	r2, [r4, #0]
 8000fc6:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8000fca:	b29b      	uxth	r3, r3
 8000fcc:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8000fd0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8000fd4:	3302      	adds	r3, #2
 8000fd6:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8000fda:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 8000fde:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000fe2:	6463      	str	r3, [r4, #68]	; 0x44
        ep->xfer_buff += ep->xfer_count;
 8000fe4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000fe6:	4413      	add	r3, r2
 8000fe8:	63e3      	str	r3, [r4, #60]	; 0x3c

        /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataInStageCallback(hpcd, 0U);
#else
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 8000fea:	2100      	movs	r1, #0
 8000fec:	4620      	mov	r0, r4
 8000fee:	f007 fd6d 	bl	8008acc <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 8000ff2:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8000ff6:	2b00      	cmp	r3, #0
 8000ff8:	f000 8085 	beq.w	8001106 <PCD_EP_ISR_Handler+0x160>
 8000ffc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000ffe:	2b00      	cmp	r3, #0
 8001000:	f040 8081 	bne.w	8001106 <PCD_EP_ISR_Handler+0x160>
        {
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 8001004:	6822      	ldr	r2, [r4, #0]
 8001006:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800100a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800100e:	f8a2 304c 	strh.w	r3, [r2, #76]	; 0x4c
          hpcd->USB_Address = 0U;
 8001012:	2300      	movs	r3, #0
 8001014:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 8001018:	e075      	b.n	8001106 <PCD_EP_ISR_Handler+0x160>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);

        if ((wEPVal & USB_EP_SETUP) != 0U)
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800101a:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800101e:	b29b      	uxth	r3, r3
 8001020:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
 8001024:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001028:	3306      	adds	r3, #6
 800102a:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800102e:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 8001032:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001036:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144

          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800103a:	f8b4 212e 	ldrh.w	r2, [r4, #302]	; 0x12e
 800103e:	f504 710c 	add.w	r1, r4, #560	; 0x230
 8001042:	f003 fa47 	bl	80044d4 <USB_ReadPMA>
                      ep->pmaadress, (uint16_t)ep->xfer_count);

          /* SETUP bit kept frozen while CTR_RX = 1*/
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001046:	6822      	ldr	r2, [r4, #0]
 8001048:	8813      	ldrh	r3, [r2, #0]
 800104a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800104e:	051b      	lsls	r3, r3, #20
 8001050:	0d1b      	lsrs	r3, r3, #20
 8001052:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001056:	8013      	strh	r3, [r2, #0]

          /* Process SETUP Packet*/
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->SetupStageCallback(hpcd);
#else
          HAL_PCD_SetupStageCallback(hpcd);
 8001058:	4620      	mov	r0, r4
 800105a:	f007 fd25 	bl	8008aa8 <HAL_PCD_SetupStageCallback>
 800105e:	e052      	b.n	8001106 <PCD_EP_ISR_Handler+0x160>
#else
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }

          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001060:	2a3e      	cmp	r2, #62	; 0x3e
 8001062:	d809      	bhi.n	8001078 <PCD_EP_ISR_Handler+0xd2>
 8001064:	0851      	lsrs	r1, r2, #1
 8001066:	f012 0f01 	tst.w	r2, #1
 800106a:	d000      	beq.n	800106e <PCD_EP_ISR_Handler+0xc8>
 800106c:	3101      	adds	r1, #1
 800106e:	028a      	lsls	r2, r1, #10
 8001070:	b292      	uxth	r2, r2
 8001072:	f8a3 240c 	strh.w	r2, [r3, #1036]	; 0x40c
 8001076:	e0a7      	b.n	80011c8 <PCD_EP_ISR_Handler+0x222>
 8001078:	0951      	lsrs	r1, r2, #5
 800107a:	f012 0f1f 	tst.w	r2, #31
 800107e:	d100      	bne.n	8001082 <PCD_EP_ISR_Handler+0xdc>
 8001080:	3901      	subs	r1, #1
 8001082:	ea6f 62c1 	mvn.w	r2, r1, lsl #27
 8001086:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 800108a:	b292      	uxth	r2, r2
 800108c:	f8a3 240c 	strh.w	r2, [r3, #1036]	; 0x40c
 8001090:	e09a      	b.n	80011c8 <PCD_EP_ISR_Handler+0x222>
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 8001092:	f830 6025 	ldrh.w	r6, [r0, r5, lsl #2]
 8001096:	b2b6      	uxth	r6, r6
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8001098:	f416 4f00 	tst.w	r6, #32768	; 0x8000
 800109c:	f040 80a3 	bne.w	80011e6 <PCD_EP_ISR_Handler+0x240>
          (void)HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
        }

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 80010a0:	f016 0f80 	tst.w	r6, #128	; 0x80
 80010a4:	d02f      	beq.n	8001106 <PCD_EP_ISR_Handler+0x160>
      {
        ep = &hpcd->IN_ep[epindex];

        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 80010a6:	6822      	ldr	r2, [r4, #0]
 80010a8:	f832 3025 	ldrh.w	r3, [r2, r5, lsl #2]
 80010ac:	b29b      	uxth	r3, r3
 80010ae:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 80010b2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80010b6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80010ba:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80010be:	b29b      	uxth	r3, r3
 80010c0:	f822 3025 	strh.w	r3, [r2, r5, lsl #2]

        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80010c4:	6822      	ldr	r2, [r4, #0]
 80010c6:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 80010ca:	b29b      	uxth	r3, r3
 80010cc:	eb04 1045 	add.w	r0, r4, r5, lsl #5
 80010d0:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
 80010d4:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80010d8:	3302      	adds	r3, #2
 80010da:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80010de:	f8b3 2400 	ldrh.w	r2, [r3, #1024]	; 0x400
 80010e2:	f3c2 0209 	ubfx	r2, r2, #0, #10
 80010e6:	1cab      	adds	r3, r5, #2
 80010e8:	015b      	lsls	r3, r3, #5
 80010ea:	18e1      	adds	r1, r4, r3
 80010ec:	604a      	str	r2, [r1, #4]
        ep->xfer_buff += ep->xfer_count;
 80010ee:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 80010f0:	440a      	add	r2, r1
 80010f2:	63c2      	str	r2, [r0, #60]	; 0x3c

        /* Zero Length Packet? */
        if (ep->xfer_len == 0U)
 80010f4:	58e3      	ldr	r3, [r4, r3]
 80010f6:	2b00      	cmp	r3, #0
 80010f8:	f040 810f 	bne.w	800131a <PCD_EP_ISR_Handler+0x374>
        {
          /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataInStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80010fc:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
 8001100:	4620      	mov	r0, r4
 8001102:	f007 fce3 	bl	8008acc <HAL_PCD_DataInStageCallback>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 8001106:	6820      	ldr	r0, [r4, #0]
 8001108:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 800110c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001110:	f000 810b 	beq.w	800132a <PCD_EP_ISR_Handler+0x384>
    wIstr = hpcd->Instance->ISTR;
 8001114:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8001118:	b29b      	uxth	r3, r3
    if (epindex == 0U)
 800111a:	f013 050f 	ands.w	r5, r3, #15
 800111e:	d1b8      	bne.n	8001092 <PCD_EP_ISR_Handler+0xec>
      if ((wIstr & USB_ISTR_DIR) == 0U)
 8001120:	f013 0f10 	tst.w	r3, #16
 8001124:	f43f af42 	beq.w	8000fac <PCD_EP_ISR_Handler+0x6>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 8001128:	8803      	ldrh	r3, [r0, #0]
 800112a:	b29b      	uxth	r3, r3
        if ((wEPVal & USB_EP_SETUP) != 0U)
 800112c:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8001130:	f47f af73 	bne.w	800101a <PCD_EP_ISR_Handler+0x74>
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8001134:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001138:	d0e5      	beq.n	8001106 <PCD_EP_ISR_Handler+0x160>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800113a:	8803      	ldrh	r3, [r0, #0]
 800113c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001140:	051b      	lsls	r3, r3, #20
 8001142:	0d1b      	lsrs	r3, r3, #20
 8001144:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001148:	8003      	strh	r3, [r0, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800114a:	6820      	ldr	r0, [r4, #0]
 800114c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001150:	b29b      	uxth	r3, r3
 8001152:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
 8001156:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800115a:	3306      	adds	r3, #6
 800115c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001160:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 8001164:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001168:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800116c:	b18b      	cbz	r3, 8001192 <PCD_EP_ISR_Handler+0x1ec>
 800116e:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
 8001172:	b171      	cbz	r1, 8001192 <PCD_EP_ISR_Handler+0x1ec>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 8001174:	f8b4 212e 	ldrh.w	r2, [r4, #302]	; 0x12e
 8001178:	f003 f9ac 	bl	80044d4 <USB_ReadPMA>
            ep->xfer_buff += ep->xfer_count;
 800117c:	f8d4 2144 	ldr.w	r2, [r4, #324]	; 0x144
 8001180:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
 8001184:	4413      	add	r3, r2
 8001186:	f8c4 313c 	str.w	r3, [r4, #316]	; 0x13c
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800118a:	2100      	movs	r1, #0
 800118c:	4620      	mov	r0, r4
 800118e:	f007 fc93 	bl	8008ab8 <HAL_PCD_DataOutStageCallback>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001192:	6822      	ldr	r2, [r4, #0]
 8001194:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8001198:	b29b      	uxth	r3, r3
 800119a:	4413      	add	r3, r2
 800119c:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
 80011a0:	2a00      	cmp	r2, #0
 80011a2:	f47f af5d 	bne.w	8001060 <PCD_EP_ISR_Handler+0xba>
 80011a6:	f8b3 240c 	ldrh.w	r2, [r3, #1036]	; 0x40c
 80011aa:	b292      	uxth	r2, r2
 80011ac:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
 80011b0:	b292      	uxth	r2, r2
 80011b2:	f8a3 240c 	strh.w	r2, [r3, #1036]	; 0x40c
 80011b6:	f8b3 240c 	ldrh.w	r2, [r3, #1036]	; 0x40c
 80011ba:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 80011be:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 80011c2:	b292      	uxth	r2, r2
 80011c4:	f8a3 240c 	strh.w	r2, [r3, #1036]	; 0x40c
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 80011c8:	6822      	ldr	r2, [r4, #0]
 80011ca:	8813      	ldrh	r3, [r2, #0]
 80011cc:	b29b      	uxth	r3, r3
 80011ce:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80011d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80011d6:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80011da:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80011de:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80011e2:	8013      	strh	r3, [r2, #0]
 80011e4:	e78f      	b.n	8001106 <PCD_EP_ISR_Handler+0x160>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 80011e6:	f830 3025 	ldrh.w	r3, [r0, r5, lsl #2]
 80011ea:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80011ee:	051b      	lsls	r3, r3, #20
 80011f0:	0d1b      	lsrs	r3, r3, #20
 80011f2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80011f6:	f820 3025 	strh.w	r3, [r0, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 80011fa:	eb04 1345 	add.w	r3, r4, r5, lsl #5
 80011fe:	f893 3134 	ldrb.w	r3, [r3, #308]	; 0x134
 8001202:	b9db      	cbnz	r3, 800123c <PCD_EP_ISR_Handler+0x296>
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8001204:	6820      	ldr	r0, [r4, #0]
 8001206:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800120a:	b29b      	uxth	r3, r3
 800120c:	eb04 1245 	add.w	r2, r4, r5, lsl #5
 8001210:	f892 2128 	ldrb.w	r2, [r2, #296]	; 0x128
 8001214:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001218:	3306      	adds	r3, #6
 800121a:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800121e:	f8b3 7400 	ldrh.w	r7, [r3, #1024]	; 0x400
 8001222:	f3c7 0709 	ubfx	r7, r7, #0, #10
          if (count != 0U)
 8001226:	b397      	cbz	r7, 800128e <PCD_EP_ISR_Handler+0x2e8>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 8001228:	eb04 1145 	add.w	r1, r4, r5, lsl #5
 800122c:	463b      	mov	r3, r7
 800122e:	f8b1 212e 	ldrh.w	r2, [r1, #302]	; 0x12e
 8001232:	f8d1 113c 	ldr.w	r1, [r1, #316]	; 0x13c
 8001236:	f003 f94d 	bl	80044d4 <USB_ReadPMA>
 800123a:	e028      	b.n	800128e <PCD_EP_ISR_Handler+0x2e8>
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800123c:	6820      	ldr	r0, [r4, #0]
 800123e:	eb04 1345 	add.w	r3, r4, r5, lsl #5
 8001242:	f893 2128 	ldrb.w	r2, [r3, #296]	; 0x128
 8001246:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800124a:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 800124e:	d044      	beq.n	80012da <PCD_EP_ISR_Handler+0x334>
            count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001250:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001254:	b29b      	uxth	r3, r3
 8001256:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800125a:	3302      	adds	r3, #2
 800125c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001260:	f8b3 7400 	ldrh.w	r7, [r3, #1024]	; 0x400
 8001264:	f3c7 0709 	ubfx	r7, r7, #0, #10
            if (count != 0U)
 8001268:	bb6f      	cbnz	r7, 80012c6 <PCD_EP_ISR_Handler+0x320>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800126a:	6822      	ldr	r2, [r4, #0]
 800126c:	eb04 1345 	add.w	r3, r4, r5, lsl #5
 8001270:	f893 1128 	ldrb.w	r1, [r3, #296]	; 0x128
 8001274:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8001278:	b29b      	uxth	r3, r3
 800127a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800127e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001282:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001286:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800128a:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
        ep->xfer_count += count;
 800128e:	f105 030a 	add.w	r3, r5, #10
 8001292:	015b      	lsls	r3, r3, #5
 8001294:	18e1      	adds	r1, r4, r3
 8001296:	684a      	ldr	r2, [r1, #4]
 8001298:	443a      	add	r2, r7
 800129a:	604a      	str	r2, [r1, #4]
        ep->xfer_buff += count;
 800129c:	eb04 1145 	add.w	r1, r4, r5, lsl #5
 80012a0:	f8d1 213c 	ldr.w	r2, [r1, #316]	; 0x13c
 80012a4:	443a      	add	r2, r7
 80012a6:	f8c1 213c 	str.w	r2, [r1, #316]	; 0x13c
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 80012aa:	58e3      	ldr	r3, [r4, r3]
 80012ac:	b11b      	cbz	r3, 80012b6 <PCD_EP_ISR_Handler+0x310>
 80012ae:	f8d1 1138 	ldr.w	r1, [r1, #312]	; 0x138
 80012b2:	428f      	cmp	r7, r1
 80012b4:	d229      	bcs.n	800130a <PCD_EP_ISR_Handler+0x364>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80012b6:	eb04 1345 	add.w	r3, r4, r5, lsl #5
 80012ba:	f893 1128 	ldrb.w	r1, [r3, #296]	; 0x128
 80012be:	4620      	mov	r0, r4
 80012c0:	f007 fbfa 	bl	8008ab8 <HAL_PCD_DataOutStageCallback>
 80012c4:	e6ec      	b.n	80010a0 <PCD_EP_ISR_Handler+0xfa>
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 80012c6:	eb04 1145 	add.w	r1, r4, r5, lsl #5
 80012ca:	463b      	mov	r3, r7
 80012cc:	f8b1 2130 	ldrh.w	r2, [r1, #304]	; 0x130
 80012d0:	f8d1 113c 	ldr.w	r1, [r1, #316]	; 0x13c
 80012d4:	f003 f8fe 	bl	80044d4 <USB_ReadPMA>
 80012d8:	e7c7      	b.n	800126a <PCD_EP_ISR_Handler+0x2c4>
            count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80012da:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80012de:	b29b      	uxth	r3, r3
 80012e0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80012e4:	3306      	adds	r3, #6
 80012e6:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80012ea:	f8b3 7400 	ldrh.w	r7, [r3, #1024]	; 0x400
 80012ee:	f3c7 0709 	ubfx	r7, r7, #0, #10
            if (count != 0U)
 80012f2:	2f00      	cmp	r7, #0
 80012f4:	d0b9      	beq.n	800126a <PCD_EP_ISR_Handler+0x2c4>
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 80012f6:	eb04 1145 	add.w	r1, r4, r5, lsl #5
 80012fa:	463b      	mov	r3, r7
 80012fc:	f8b1 2132 	ldrh.w	r2, [r1, #306]	; 0x132
 8001300:	f8d1 113c 	ldr.w	r1, [r1, #316]	; 0x13c
 8001304:	f003 f8e6 	bl	80044d4 <USB_ReadPMA>
 8001308:	e7af      	b.n	800126a <PCD_EP_ISR_Handler+0x2c4>
          (void)HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 800130a:	eb04 1145 	add.w	r1, r4, r5, lsl #5
 800130e:	f891 1128 	ldrb.w	r1, [r1, #296]	; 0x128
 8001312:	4620      	mov	r0, r4
 8001314:	f7ff fe03 	bl	8000f1e <HAL_PCD_EP_Receive>
 8001318:	e6c2      	b.n	80010a0 <PCD_EP_ISR_Handler+0xfa>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          (void)HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 800131a:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 800131e:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 8001322:	4620      	mov	r0, r4
 8001324:	f7ff fe21 	bl	8000f6a <HAL_PCD_EP_Transmit>
 8001328:	e6ed      	b.n	8001106 <PCD_EP_ISR_Handler+0x160>
        }
      }
    }
  }
  return HAL_OK;
}
 800132a:	2000      	movs	r0, #0
 800132c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800132e <HAL_PCD_IRQHandler>:
{
 800132e:	b510      	push	{r4, lr}
 8001330:	4604      	mov	r4, r0
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_CTR))
 8001332:	6800      	ldr	r0, [r0, #0]
 8001334:	f002 ff0b 	bl	800414e <USB_ReadInterrupts>
 8001338:	f410 4f00 	tst.w	r0, #32768	; 0x8000
 800133c:	d145      	bne.n	80013ca <HAL_PCD_IRQHandler+0x9c>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
 800133e:	6820      	ldr	r0, [r4, #0]
 8001340:	f002 ff05 	bl	800414e <USB_ReadInterrupts>
 8001344:	f410 6f80 	tst.w	r0, #1024	; 0x400
 8001348:	d143      	bne.n	80013d2 <HAL_PCD_IRQHandler+0xa4>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_PMAOVR))
 800134a:	6820      	ldr	r0, [r4, #0]
 800134c:	f002 feff 	bl	800414e <USB_ReadInterrupts>
 8001350:	f410 4f80 	tst.w	r0, #16384	; 0x4000
 8001354:	d008      	beq.n	8001368 <HAL_PCD_IRQHandler+0x3a>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 8001356:	6822      	ldr	r2, [r4, #0]
 8001358:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 800135c:	b29b      	uxth	r3, r3
 800135e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001362:	b29b      	uxth	r3, r3
 8001364:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ERR))
 8001368:	6820      	ldr	r0, [r4, #0]
 800136a:	f002 fef0 	bl	800414e <USB_ReadInterrupts>
 800136e:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8001372:	d008      	beq.n	8001386 <HAL_PCD_IRQHandler+0x58>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 8001374:	6822      	ldr	r2, [r4, #0]
 8001376:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 800137a:	b29b      	uxth	r3, r3
 800137c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001380:	b29b      	uxth	r3, r3
 8001382:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_WKUP))
 8001386:	6820      	ldr	r0, [r4, #0]
 8001388:	f002 fee1 	bl	800414e <USB_ReadInterrupts>
 800138c:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 8001390:	d130      	bne.n	80013f4 <HAL_PCD_IRQHandler+0xc6>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SUSP))
 8001392:	6820      	ldr	r0, [r4, #0]
 8001394:	f002 fedb 	bl	800414e <USB_ReadInterrupts>
 8001398:	f410 6f00 	tst.w	r0, #2048	; 0x800
 800139c:	d149      	bne.n	8001432 <HAL_PCD_IRQHandler+0x104>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SOF))
 800139e:	6820      	ldr	r0, [r4, #0]
 80013a0:	f002 fed5 	bl	800414e <USB_ReadInterrupts>
 80013a4:	f410 7f00 	tst.w	r0, #512	; 0x200
 80013a8:	d16f      	bne.n	800148a <HAL_PCD_IRQHandler+0x15c>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ESOF))
 80013aa:	6820      	ldr	r0, [r4, #0]
 80013ac:	f002 fecf 	bl	800414e <USB_ReadInterrupts>
 80013b0:	f410 7f80 	tst.w	r0, #256	; 0x100
 80013b4:	d008      	beq.n	80013c8 <HAL_PCD_IRQHandler+0x9a>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 80013b6:	6822      	ldr	r2, [r4, #0]
 80013b8:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 80013bc:	b29b      	uxth	r3, r3
 80013be:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80013c2:	b29b      	uxth	r3, r3
 80013c4:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
 80013c8:	bd10      	pop	{r4, pc}
    (void)PCD_EP_ISR_Handler(hpcd);
 80013ca:	4620      	mov	r0, r4
 80013cc:	f7ff fdeb 	bl	8000fa6 <PCD_EP_ISR_Handler>
 80013d0:	e7b5      	b.n	800133e <HAL_PCD_IRQHandler+0x10>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 80013d2:	6822      	ldr	r2, [r4, #0]
 80013d4:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 80013d8:	b29b      	uxth	r3, r3
 80013da:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80013de:	b29b      	uxth	r3, r3
 80013e0:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 80013e4:	4620      	mov	r0, r4
 80013e6:	f007 fb80 	bl	8008aea <HAL_PCD_ResetCallback>
    (void)HAL_PCD_SetAddress(hpcd, 0U);
 80013ea:	2100      	movs	r1, #0
 80013ec:	4620      	mov	r0, r4
 80013ee:	f7ff fd1c 	bl	8000e2a <HAL_PCD_SetAddress>
 80013f2:	e7aa      	b.n	800134a <HAL_PCD_IRQHandler+0x1c>
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LP_MODE);
 80013f4:	6822      	ldr	r2, [r4, #0]
 80013f6:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 80013fa:	b29b      	uxth	r3, r3
 80013fc:	f023 0304 	bic.w	r3, r3, #4
 8001400:	b29b      	uxth	r3, r3
 8001402:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 8001406:	6822      	ldr	r2, [r4, #0]
 8001408:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 800140c:	b29b      	uxth	r3, r3
 800140e:	f023 0308 	bic.w	r3, r3, #8
 8001412:	b29b      	uxth	r3, r3
 8001414:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    HAL_PCD_ResumeCallback(hpcd);
 8001418:	4620      	mov	r0, r4
 800141a:	f007 fb87 	bl	8008b2c <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 800141e:	6822      	ldr	r2, [r4, #0]
 8001420:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001424:	b29b      	uxth	r3, r3
 8001426:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800142a:	b29b      	uxth	r3, r3
 800142c:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
 8001430:	e7af      	b.n	8001392 <HAL_PCD_IRQHandler+0x64>
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 8001432:	6822      	ldr	r2, [r4, #0]
 8001434:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 8001438:	b29b      	uxth	r3, r3
 800143a:	f043 0308 	orr.w	r3, r3, #8
 800143e:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 8001442:	6822      	ldr	r2, [r4, #0]
 8001444:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001448:	b29b      	uxth	r3, r3
 800144a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800144e:	b29b      	uxth	r3, r3
 8001450:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;
 8001454:	6822      	ldr	r2, [r4, #0]
 8001456:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 800145a:	b29b      	uxth	r3, r3
 800145c:	f043 0304 	orr.w	r3, r3, #4
 8001460:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_WKUP))
 8001464:	6820      	ldr	r0, [r4, #0]
 8001466:	f002 fe72 	bl	800414e <USB_ReadInterrupts>
 800146a:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 800146e:	d008      	beq.n	8001482 <HAL_PCD_IRQHandler+0x154>
       __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 8001470:	6822      	ldr	r2, [r4, #0]
 8001472:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001476:	b29b      	uxth	r3, r3
 8001478:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800147c:	b29b      	uxth	r3, r3
 800147e:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_SuspendCallback(hpcd);
 8001482:	4620      	mov	r0, r4
 8001484:	f007 fb42 	bl	8008b0c <HAL_PCD_SuspendCallback>
 8001488:	e789      	b.n	800139e <HAL_PCD_IRQHandler+0x70>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800148a:	6822      	ldr	r2, [r4, #0]
 800148c:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001490:	b29b      	uxth	r3, r3
 8001492:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001496:	b29b      	uxth	r3, r3
 8001498:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 800149c:	4620      	mov	r0, r4
 800149e:	f007 fb1e 	bl	8008ade <HAL_PCD_SOFCallback>
 80014a2:	e782      	b.n	80013aa <HAL_PCD_IRQHandler+0x7c>

080014a4 <HAL_PCD_EP_SetStall>:
{
 80014a4:	b538      	push	{r3, r4, r5, lr}
 80014a6:	f001 0507 	and.w	r5, r1, #7
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 80014aa:	6843      	ldr	r3, [r0, #4]
 80014ac:	429d      	cmp	r5, r3
 80014ae:	d82e      	bhi.n	800150e <HAL_PCD_EP_SetStall+0x6a>
  if ((0x80U & ep_addr) == 0x80U)
 80014b0:	f011 0f80 	tst.w	r1, #128	; 0x80
 80014b4:	d110      	bne.n	80014d8 <HAL_PCD_EP_SetStall+0x34>
    ep = &hpcd->OUT_ep[ep_addr];
 80014b6:	014b      	lsls	r3, r1, #5
 80014b8:	f503 7194 	add.w	r1, r3, #296	; 0x128
 80014bc:	4401      	add	r1, r0
    ep->is_in = 0U;
 80014be:	4403      	add	r3, r0
 80014c0:	2200      	movs	r2, #0
 80014c2:	f883 2129 	strb.w	r2, [r3, #297]	; 0x129
  ep->is_stall = 1U;
 80014c6:	2301      	movs	r3, #1
 80014c8:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 80014ca:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 80014cc:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 80014d0:	2b01      	cmp	r3, #1
 80014d2:	d10a      	bne.n	80014ea <HAL_PCD_EP_SetStall+0x46>
 80014d4:	2002      	movs	r0, #2
}
 80014d6:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80014d8:	016b      	lsls	r3, r5, #5
 80014da:	f103 0128 	add.w	r1, r3, #40	; 0x28
 80014de:	4401      	add	r1, r0
    ep->is_in = 1U;
 80014e0:	4403      	add	r3, r0
 80014e2:	2201      	movs	r2, #1
 80014e4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 80014e8:	e7ed      	b.n	80014c6 <HAL_PCD_EP_SetStall+0x22>
 80014ea:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 80014ec:	2301      	movs	r3, #1
 80014ee:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
  (void)USB_EPSetStall(hpcd->Instance, ep);
 80014f2:	6800      	ldr	r0, [r0, #0]
 80014f4:	f002 fdab 	bl	800404e <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 80014f8:	b11d      	cbz	r5, 8001502 <HAL_PCD_EP_SetStall+0x5e>
  __HAL_UNLOCK(hpcd);
 80014fa:	2000      	movs	r0, #0
 80014fc:	f884 0228 	strb.w	r0, [r4, #552]	; 0x228
  return HAL_OK;
 8001500:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8001502:	f504 710c 	add.w	r1, r4, #560	; 0x230
 8001506:	6820      	ldr	r0, [r4, #0]
 8001508:	f002 fe25 	bl	8004156 <USB_EP0_OutStart>
 800150c:	e7f5      	b.n	80014fa <HAL_PCD_EP_SetStall+0x56>
    return HAL_ERROR;
 800150e:	2001      	movs	r0, #1
 8001510:	bd38      	pop	{r3, r4, r5, pc}

08001512 <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8001512:	f001 020f 	and.w	r2, r1, #15
 8001516:	6843      	ldr	r3, [r0, #4]
 8001518:	429a      	cmp	r2, r3
 800151a:	d82f      	bhi.n	800157c <HAL_PCD_EP_ClrStall+0x6a>
{
 800151c:	b510      	push	{r4, lr}
  if ((0x80U & ep_addr) == 0x80U)
 800151e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001522:	d114      	bne.n	800154e <HAL_PCD_EP_ClrStall+0x3c>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001524:	f001 0307 	and.w	r3, r1, #7
 8001528:	015b      	lsls	r3, r3, #5
 800152a:	f503 7294 	add.w	r2, r3, #296	; 0x128
 800152e:	4402      	add	r2, r0
    ep->is_in = 0U;
 8001530:	4403      	add	r3, r0
 8001532:	2400      	movs	r4, #0
 8001534:	f883 4129 	strb.w	r4, [r3, #297]	; 0x129
  ep->is_stall = 0U;
 8001538:	2300      	movs	r3, #0
 800153a:	7093      	strb	r3, [r2, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800153c:	f001 0307 	and.w	r3, r1, #7
 8001540:	7013      	strb	r3, [r2, #0]
  __HAL_LOCK(hpcd);
 8001542:	f890 3228 	ldrb.w	r3, [r0, #552]	; 0x228
 8001546:	2b01      	cmp	r3, #1
 8001548:	d10c      	bne.n	8001564 <HAL_PCD_EP_ClrStall+0x52>
 800154a:	2002      	movs	r0, #2
}
 800154c:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800154e:	f001 0307 	and.w	r3, r1, #7
 8001552:	015b      	lsls	r3, r3, #5
 8001554:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8001558:	4402      	add	r2, r0
    ep->is_in = 1U;
 800155a:	4403      	add	r3, r0
 800155c:	2401      	movs	r4, #1
 800155e:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
 8001562:	e7e9      	b.n	8001538 <HAL_PCD_EP_ClrStall+0x26>
 8001564:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8001566:	2301      	movs	r3, #1
 8001568:	f880 3228 	strb.w	r3, [r0, #552]	; 0x228
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800156c:	4611      	mov	r1, r2
 800156e:	6800      	ldr	r0, [r0, #0]
 8001570:	f002 fd92 	bl	8004098 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8001574:	2000      	movs	r0, #0
 8001576:	f884 0228 	strb.w	r0, [r4, #552]	; 0x228
  return HAL_OK;
 800157a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800157c:	2001      	movs	r0, #1
 800157e:	4770      	bx	lr

08001580 <HAL_PCDEx_PMAConfig>:
                                       uint32_t pmaadress)
{
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 8001580:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001584:	d00c      	beq.n	80015a0 <HAL_PCDEx_PMAConfig+0x20>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001586:	f001 0107 	and.w	r1, r1, #7
 800158a:	0149      	lsls	r1, r1, #5
 800158c:	3128      	adds	r1, #40	; 0x28
 800158e:	4401      	add	r1, r0
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8001590:	b15a      	cbz	r2, 80015aa <HAL_PCDEx_PMAConfig+0x2a>
    ep->pmaadress = (uint16_t)pmaadress;
  }
  else /* USB_DBL_BUF */
  {
    /* Double Buffer Endpoint */
    ep->doublebuffer = 1U;
 8001592:	2201      	movs	r2, #1
 8001594:	730a      	strb	r2, [r1, #12]
    /* Configure the PMA */
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 8001596:	810b      	strh	r3, [r1, #8]
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
 8001598:	0c1b      	lsrs	r3, r3, #16
 800159a:	814b      	strh	r3, [r1, #10]
  }

  return HAL_OK;
}
 800159c:	2000      	movs	r0, #0
 800159e:	4770      	bx	lr
    ep = &hpcd->OUT_ep[ep_addr];
 80015a0:	0149      	lsls	r1, r1, #5
 80015a2:	f501 7194 	add.w	r1, r1, #296	; 0x128
 80015a6:	4401      	add	r1, r0
 80015a8:	e7f2      	b.n	8001590 <HAL_PCDEx_PMAConfig+0x10>
    ep->doublebuffer = 0U;
 80015aa:	730a      	strb	r2, [r1, #12]
    ep->pmaadress = (uint16_t)pmaadress;
 80015ac:	80cb      	strh	r3, [r1, #6]
 80015ae:	e7f5      	b.n	800159c <HAL_PCDEx_PMAConfig+0x1c>

080015b0 <RCC_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
 80015b0:	b082      	sub	sp, #8
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 80015b2:	4b08      	ldr	r3, [pc, #32]	; (80015d4 <RCC_Delay+0x24>)
 80015b4:	681b      	ldr	r3, [r3, #0]
 80015b6:	4a08      	ldr	r2, [pc, #32]	; (80015d8 <RCC_Delay+0x28>)
 80015b8:	fba2 2303 	umull	r2, r3, r2, r3
 80015bc:	0a5b      	lsrs	r3, r3, #9
 80015be:	fb00 f003 	mul.w	r0, r0, r3
 80015c2:	9001      	str	r0, [sp, #4]
  do
  {
    __NOP();
 80015c4:	bf00      	nop
  }
  while (Delay --);
 80015c6:	9b01      	ldr	r3, [sp, #4]
 80015c8:	1e5a      	subs	r2, r3, #1
 80015ca:	9201      	str	r2, [sp, #4]
 80015cc:	2b00      	cmp	r3, #0
 80015ce:	d1f9      	bne.n	80015c4 <RCC_Delay+0x14>
}
 80015d0:	b002      	add	sp, #8
 80015d2:	4770      	bx	lr
 80015d4:	20000124 	.word	0x20000124
 80015d8:	10624dd3 	.word	0x10624dd3

080015dc <HAL_RCC_DeInit>:
{
 80015dc:	b570      	push	{r4, r5, r6, lr}
  tickstart = HAL_GetTick();
 80015de:	f7fe fe6d 	bl	80002bc <HAL_GetTick>
 80015e2:	4604      	mov	r4, r0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 80015e4:	4a36      	ldr	r2, [pc, #216]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 80015e6:	6813      	ldr	r3, [r2, #0]
 80015e8:	f043 0301 	orr.w	r3, r3, #1
 80015ec:	6013      	str	r3, [r2, #0]
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80015ee:	4b34      	ldr	r3, [pc, #208]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 80015f0:	681b      	ldr	r3, [r3, #0]
 80015f2:	f013 0f02 	tst.w	r3, #2
 80015f6:	d107      	bne.n	8001608 <HAL_RCC_DeInit+0x2c>
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80015f8:	f7fe fe60 	bl	80002bc <HAL_GetTick>
 80015fc:	1b00      	subs	r0, r0, r4
 80015fe:	2802      	cmp	r0, #2
 8001600:	d9f5      	bls.n	80015ee <HAL_RCC_DeInit+0x12>
      return HAL_TIMEOUT;
 8001602:	2403      	movs	r4, #3
}
 8001604:	4620      	mov	r0, r4
 8001606:	bd70      	pop	{r4, r5, r6, pc}
  MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (0x10U << RCC_CR_HSITRIM_Pos));
 8001608:	4d2d      	ldr	r5, [pc, #180]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 800160a:	682b      	ldr	r3, [r5, #0]
 800160c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001610:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001614:	602b      	str	r3, [r5, #0]
  tickstart = HAL_GetTick();
 8001616:	f7fe fe51 	bl	80002bc <HAL_GetTick>
 800161a:	4604      	mov	r4, r0
  CLEAR_REG(RCC->CFGR);
 800161c:	2300      	movs	r3, #0
 800161e:	606b      	str	r3, [r5, #4]
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
 8001620:	4b27      	ldr	r3, [pc, #156]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 8001622:	685b      	ldr	r3, [r3, #4]
 8001624:	f013 0f0c 	tst.w	r3, #12
 8001628:	d008      	beq.n	800163c <HAL_RCC_DeInit+0x60>
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800162a:	f7fe fe47 	bl	80002bc <HAL_GetTick>
 800162e:	1b00      	subs	r0, r0, r4
 8001630:	f241 3388 	movw	r3, #5000	; 0x1388
 8001634:	4298      	cmp	r0, r3
 8001636:	d9f3      	bls.n	8001620 <HAL_RCC_DeInit+0x44>
      return HAL_TIMEOUT;
 8001638:	2403      	movs	r4, #3
 800163a:	e7e3      	b.n	8001604 <HAL_RCC_DeInit+0x28>
  SystemCoreClock = HSI_VALUE;
 800163c:	4a21      	ldr	r2, [pc, #132]	; (80016c4 <HAL_RCC_DeInit+0xe8>)
 800163e:	4b22      	ldr	r3, [pc, #136]	; (80016c8 <HAL_RCC_DeInit+0xec>)
 8001640:	601a      	str	r2, [r3, #0]
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8001642:	4b22      	ldr	r3, [pc, #136]	; (80016cc <HAL_RCC_DeInit+0xf0>)
 8001644:	6818      	ldr	r0, [r3, #0]
 8001646:	f7fe fdf5 	bl	8000234 <HAL_InitTick>
 800164a:	4604      	mov	r4, r0
 800164c:	b108      	cbz	r0, 8001652 <HAL_RCC_DeInit+0x76>
    return HAL_ERROR;
 800164e:	2401      	movs	r4, #1
 8001650:	e7d8      	b.n	8001604 <HAL_RCC_DeInit+0x28>
  tickstart = HAL_GetTick();
 8001652:	f7fe fe33 	bl	80002bc <HAL_GetTick>
 8001656:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8001658:	4a19      	ldr	r2, [pc, #100]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 800165a:	6813      	ldr	r3, [r2, #0]
 800165c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001660:	6013      	str	r3, [r2, #0]
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8001662:	4b17      	ldr	r3, [pc, #92]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 8001664:	681b      	ldr	r3, [r3, #0]
 8001666:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800166a:	d006      	beq.n	800167a <HAL_RCC_DeInit+0x9e>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800166c:	f7fe fe26 	bl	80002bc <HAL_GetTick>
 8001670:	1b40      	subs	r0, r0, r5
 8001672:	2802      	cmp	r0, #2
 8001674:	d9f5      	bls.n	8001662 <HAL_RCC_DeInit+0x86>
      return HAL_TIMEOUT;
 8001676:	2403      	movs	r4, #3
 8001678:	e7c4      	b.n	8001604 <HAL_RCC_DeInit+0x28>
  CLEAR_REG(RCC->CFGR);
 800167a:	4e11      	ldr	r6, [pc, #68]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 800167c:	2300      	movs	r3, #0
 800167e:	6073      	str	r3, [r6, #4]
  tickstart = HAL_GetTick();
 8001680:	f7fe fe1c 	bl	80002bc <HAL_GetTick>
 8001684:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);
 8001686:	6833      	ldr	r3, [r6, #0]
 8001688:	f423 2310 	bic.w	r3, r3, #589824	; 0x90000
 800168c:	6033      	str	r3, [r6, #0]
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 800168e:	4b0c      	ldr	r3, [pc, #48]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 8001690:	681b      	ldr	r3, [r3, #0]
 8001692:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001696:	d006      	beq.n	80016a6 <HAL_RCC_DeInit+0xca>
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001698:	f7fe fe10 	bl	80002bc <HAL_GetTick>
 800169c:	1b40      	subs	r0, r0, r5
 800169e:	2864      	cmp	r0, #100	; 0x64
 80016a0:	d9f5      	bls.n	800168e <HAL_RCC_DeInit+0xb2>
      return HAL_TIMEOUT;
 80016a2:	2403      	movs	r4, #3
 80016a4:	e7ae      	b.n	8001604 <HAL_RCC_DeInit+0x28>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80016a6:	4b06      	ldr	r3, [pc, #24]	; (80016c0 <HAL_RCC_DeInit+0xe4>)
 80016a8:	681a      	ldr	r2, [r3, #0]
 80016aa:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80016ae:	601a      	str	r2, [r3, #0]
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 80016b0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80016b2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80016b6:	625a      	str	r2, [r3, #36]	; 0x24
  CLEAR_REG(RCC->CIR);
 80016b8:	2200      	movs	r2, #0
 80016ba:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80016bc:	e7a2      	b.n	8001604 <HAL_RCC_DeInit+0x28>
 80016be:	bf00      	nop
 80016c0:	40021000 	.word	0x40021000
 80016c4:	007a1200 	.word	0x007a1200
 80016c8:	20000124 	.word	0x20000124
 80016cc:	20000004 	.word	0x20000004

080016d0 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 80016d0:	2800      	cmp	r0, #0
 80016d2:	f000 81f5 	beq.w	8001ac0 <HAL_RCC_OscConfig+0x3f0>
{
 80016d6:	b570      	push	{r4, r5, r6, lr}
 80016d8:	b082      	sub	sp, #8
 80016da:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80016dc:	6803      	ldr	r3, [r0, #0]
 80016de:	f013 0f01 	tst.w	r3, #1
 80016e2:	d03d      	beq.n	8001760 <HAL_RCC_OscConfig+0x90>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80016e4:	4bab      	ldr	r3, [pc, #684]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80016e6:	685b      	ldr	r3, [r3, #4]
 80016e8:	f003 030c 	and.w	r3, r3, #12
 80016ec:	2b04      	cmp	r3, #4
 80016ee:	d02e      	beq.n	800174e <HAL_RCC_OscConfig+0x7e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80016f0:	4ba8      	ldr	r3, [pc, #672]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80016f2:	685b      	ldr	r3, [r3, #4]
 80016f4:	f003 030c 	and.w	r3, r3, #12
 80016f8:	2b08      	cmp	r3, #8
 80016fa:	d023      	beq.n	8001744 <HAL_RCC_OscConfig+0x74>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80016fc:	6863      	ldr	r3, [r4, #4]
 80016fe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001702:	d051      	beq.n	80017a8 <HAL_RCC_OscConfig+0xd8>
 8001704:	2b00      	cmp	r3, #0
 8001706:	d155      	bne.n	80017b4 <HAL_RCC_OscConfig+0xe4>
 8001708:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800170c:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8001710:	681a      	ldr	r2, [r3, #0]
 8001712:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001716:	601a      	str	r2, [r3, #0]
 8001718:	681a      	ldr	r2, [r3, #0]
 800171a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800171e:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001720:	6863      	ldr	r3, [r4, #4]
 8001722:	2b00      	cmp	r3, #0
 8001724:	d060      	beq.n	80017e8 <HAL_RCC_OscConfig+0x118>
        tickstart = HAL_GetTick();
 8001726:	f7fe fdc9 	bl	80002bc <HAL_GetTick>
 800172a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800172c:	4b99      	ldr	r3, [pc, #612]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 800172e:	681b      	ldr	r3, [r3, #0]
 8001730:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001734:	d114      	bne.n	8001760 <HAL_RCC_OscConfig+0x90>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001736:	f7fe fdc1 	bl	80002bc <HAL_GetTick>
 800173a:	1b40      	subs	r0, r0, r5
 800173c:	2864      	cmp	r0, #100	; 0x64
 800173e:	d9f5      	bls.n	800172c <HAL_RCC_OscConfig+0x5c>
            return HAL_TIMEOUT;
 8001740:	2003      	movs	r0, #3
 8001742:	e1c2      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001744:	4b93      	ldr	r3, [pc, #588]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001746:	685b      	ldr	r3, [r3, #4]
 8001748:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 800174c:	d0d6      	beq.n	80016fc <HAL_RCC_OscConfig+0x2c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800174e:	4b91      	ldr	r3, [pc, #580]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001750:	681b      	ldr	r3, [r3, #0]
 8001752:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001756:	d003      	beq.n	8001760 <HAL_RCC_OscConfig+0x90>
 8001758:	6863      	ldr	r3, [r4, #4]
 800175a:	2b00      	cmp	r3, #0
 800175c:	f000 81b2 	beq.w	8001ac4 <HAL_RCC_OscConfig+0x3f4>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001760:	6823      	ldr	r3, [r4, #0]
 8001762:	f013 0f02 	tst.w	r3, #2
 8001766:	d065      	beq.n	8001834 <HAL_RCC_OscConfig+0x164>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8001768:	4b8a      	ldr	r3, [pc, #552]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 800176a:	685b      	ldr	r3, [r3, #4]
 800176c:	f013 0f0c 	tst.w	r3, #12
 8001770:	d04e      	beq.n	8001810 <HAL_RCC_OscConfig+0x140>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8001772:	4b88      	ldr	r3, [pc, #544]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001774:	685b      	ldr	r3, [r3, #4]
 8001776:	f003 030c 	and.w	r3, r3, #12
 800177a:	2b08      	cmp	r3, #8
 800177c:	d043      	beq.n	8001806 <HAL_RCC_OscConfig+0x136>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800177e:	6923      	ldr	r3, [r4, #16]
 8001780:	2b00      	cmp	r3, #0
 8001782:	d079      	beq.n	8001878 <HAL_RCC_OscConfig+0x1a8>
        __HAL_RCC_HSI_ENABLE();
 8001784:	2201      	movs	r2, #1
 8001786:	4b84      	ldr	r3, [pc, #528]	; (8001998 <HAL_RCC_OscConfig+0x2c8>)
 8001788:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800178a:	f7fe fd97 	bl	80002bc <HAL_GetTick>
 800178e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001790:	4b80      	ldr	r3, [pc, #512]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001792:	681b      	ldr	r3, [r3, #0]
 8001794:	f013 0f02 	tst.w	r3, #2
 8001798:	d165      	bne.n	8001866 <HAL_RCC_OscConfig+0x196>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800179a:	f7fe fd8f 	bl	80002bc <HAL_GetTick>
 800179e:	1b40      	subs	r0, r0, r5
 80017a0:	2802      	cmp	r0, #2
 80017a2:	d9f5      	bls.n	8001790 <HAL_RCC_OscConfig+0xc0>
            return HAL_TIMEOUT;
 80017a4:	2003      	movs	r0, #3
 80017a6:	e190      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80017a8:	4a7a      	ldr	r2, [pc, #488]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80017aa:	6813      	ldr	r3, [r2, #0]
 80017ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80017b0:	6013      	str	r3, [r2, #0]
 80017b2:	e7b5      	b.n	8001720 <HAL_RCC_OscConfig+0x50>
 80017b4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80017b8:	d009      	beq.n	80017ce <HAL_RCC_OscConfig+0xfe>
 80017ba:	4b76      	ldr	r3, [pc, #472]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80017bc:	681a      	ldr	r2, [r3, #0]
 80017be:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80017c2:	601a      	str	r2, [r3, #0]
 80017c4:	681a      	ldr	r2, [r3, #0]
 80017c6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80017ca:	601a      	str	r2, [r3, #0]
 80017cc:	e7a8      	b.n	8001720 <HAL_RCC_OscConfig+0x50>
 80017ce:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80017d2:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 80017d6:	681a      	ldr	r2, [r3, #0]
 80017d8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80017dc:	601a      	str	r2, [r3, #0]
 80017de:	681a      	ldr	r2, [r3, #0]
 80017e0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80017e4:	601a      	str	r2, [r3, #0]
 80017e6:	e79b      	b.n	8001720 <HAL_RCC_OscConfig+0x50>
        tickstart = HAL_GetTick();
 80017e8:	f7fe fd68 	bl	80002bc <HAL_GetTick>
 80017ec:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80017ee:	4b69      	ldr	r3, [pc, #420]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80017f0:	681b      	ldr	r3, [r3, #0]
 80017f2:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80017f6:	d0b3      	beq.n	8001760 <HAL_RCC_OscConfig+0x90>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80017f8:	f7fe fd60 	bl	80002bc <HAL_GetTick>
 80017fc:	1b40      	subs	r0, r0, r5
 80017fe:	2864      	cmp	r0, #100	; 0x64
 8001800:	d9f5      	bls.n	80017ee <HAL_RCC_OscConfig+0x11e>
            return HAL_TIMEOUT;
 8001802:	2003      	movs	r0, #3
 8001804:	e161      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8001806:	4b63      	ldr	r3, [pc, #396]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001808:	685b      	ldr	r3, [r3, #4]
 800180a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 800180e:	d1b6      	bne.n	800177e <HAL_RCC_OscConfig+0xae>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001810:	4b60      	ldr	r3, [pc, #384]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001812:	681b      	ldr	r3, [r3, #0]
 8001814:	f013 0f02 	tst.w	r3, #2
 8001818:	d004      	beq.n	8001824 <HAL_RCC_OscConfig+0x154>
 800181a:	6923      	ldr	r3, [r4, #16]
 800181c:	2b01      	cmp	r3, #1
 800181e:	d001      	beq.n	8001824 <HAL_RCC_OscConfig+0x154>
        return HAL_ERROR;
 8001820:	2001      	movs	r0, #1
 8001822:	e152      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001824:	4a5b      	ldr	r2, [pc, #364]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001826:	6813      	ldr	r3, [r2, #0]
 8001828:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800182c:	6961      	ldr	r1, [r4, #20]
 800182e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001832:	6013      	str	r3, [r2, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001834:	6823      	ldr	r3, [r4, #0]
 8001836:	f013 0f08 	tst.w	r3, #8
 800183a:	d032      	beq.n	80018a2 <HAL_RCC_OscConfig+0x1d2>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800183c:	69a3      	ldr	r3, [r4, #24]
 800183e:	2b00      	cmp	r3, #0
 8001840:	d06e      	beq.n	8001920 <HAL_RCC_OscConfig+0x250>
      __HAL_RCC_LSI_ENABLE();
 8001842:	2201      	movs	r2, #1
 8001844:	4b55      	ldr	r3, [pc, #340]	; (800199c <HAL_RCC_OscConfig+0x2cc>)
 8001846:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001848:	f7fe fd38 	bl	80002bc <HAL_GetTick>
 800184c:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800184e:	4b51      	ldr	r3, [pc, #324]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001850:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001852:	f013 0f02 	tst.w	r3, #2
 8001856:	d121      	bne.n	800189c <HAL_RCC_OscConfig+0x1cc>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001858:	f7fe fd30 	bl	80002bc <HAL_GetTick>
 800185c:	1b40      	subs	r0, r0, r5
 800185e:	2802      	cmp	r0, #2
 8001860:	d9f5      	bls.n	800184e <HAL_RCC_OscConfig+0x17e>
          return HAL_TIMEOUT;
 8001862:	2003      	movs	r0, #3
 8001864:	e131      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001866:	4a4b      	ldr	r2, [pc, #300]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001868:	6813      	ldr	r3, [r2, #0]
 800186a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800186e:	6961      	ldr	r1, [r4, #20]
 8001870:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001874:	6013      	str	r3, [r2, #0]
 8001876:	e7dd      	b.n	8001834 <HAL_RCC_OscConfig+0x164>
        __HAL_RCC_HSI_DISABLE();
 8001878:	2200      	movs	r2, #0
 800187a:	4b47      	ldr	r3, [pc, #284]	; (8001998 <HAL_RCC_OscConfig+0x2c8>)
 800187c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800187e:	f7fe fd1d 	bl	80002bc <HAL_GetTick>
 8001882:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001884:	4b43      	ldr	r3, [pc, #268]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001886:	681b      	ldr	r3, [r3, #0]
 8001888:	f013 0f02 	tst.w	r3, #2
 800188c:	d0d2      	beq.n	8001834 <HAL_RCC_OscConfig+0x164>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800188e:	f7fe fd15 	bl	80002bc <HAL_GetTick>
 8001892:	1b40      	subs	r0, r0, r5
 8001894:	2802      	cmp	r0, #2
 8001896:	d9f5      	bls.n	8001884 <HAL_RCC_OscConfig+0x1b4>
            return HAL_TIMEOUT;
 8001898:	2003      	movs	r0, #3
 800189a:	e116      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
      RCC_Delay(1);
 800189c:	2001      	movs	r0, #1
 800189e:	f7ff fe87 	bl	80015b0 <RCC_Delay>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80018a2:	6823      	ldr	r3, [r4, #0]
 80018a4:	f013 0f04 	tst.w	r3, #4
 80018a8:	f000 8098 	beq.w	80019dc <HAL_RCC_OscConfig+0x30c>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80018ac:	4b39      	ldr	r3, [pc, #228]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80018ae:	69db      	ldr	r3, [r3, #28]
 80018b0:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80018b4:	d146      	bne.n	8001944 <HAL_RCC_OscConfig+0x274>
      __HAL_RCC_PWR_CLK_ENABLE();
 80018b6:	4b37      	ldr	r3, [pc, #220]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 80018b8:	69da      	ldr	r2, [r3, #28]
 80018ba:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80018be:	61da      	str	r2, [r3, #28]
 80018c0:	69db      	ldr	r3, [r3, #28]
 80018c2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80018c6:	9301      	str	r3, [sp, #4]
 80018c8:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80018ca:	2501      	movs	r5, #1
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80018cc:	4b34      	ldr	r3, [pc, #208]	; (80019a0 <HAL_RCC_OscConfig+0x2d0>)
 80018ce:	681b      	ldr	r3, [r3, #0]
 80018d0:	f413 7f80 	tst.w	r3, #256	; 0x100
 80018d4:	d038      	beq.n	8001948 <HAL_RCC_OscConfig+0x278>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80018d6:	68e3      	ldr	r3, [r4, #12]
 80018d8:	2b01      	cmp	r3, #1
 80018da:	d049      	beq.n	8001970 <HAL_RCC_OscConfig+0x2a0>
 80018dc:	2b00      	cmp	r3, #0
 80018de:	d14d      	bne.n	800197c <HAL_RCC_OscConfig+0x2ac>
 80018e0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80018e4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80018e8:	6a1a      	ldr	r2, [r3, #32]
 80018ea:	f022 0201 	bic.w	r2, r2, #1
 80018ee:	621a      	str	r2, [r3, #32]
 80018f0:	6a1a      	ldr	r2, [r3, #32]
 80018f2:	f022 0204 	bic.w	r2, r2, #4
 80018f6:	621a      	str	r2, [r3, #32]
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80018f8:	68e3      	ldr	r3, [r4, #12]
 80018fa:	2b00      	cmp	r3, #0
 80018fc:	d05c      	beq.n	80019b8 <HAL_RCC_OscConfig+0x2e8>
      tickstart = HAL_GetTick();
 80018fe:	f7fe fcdd 	bl	80002bc <HAL_GetTick>
 8001902:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001904:	4b23      	ldr	r3, [pc, #140]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001906:	6a1b      	ldr	r3, [r3, #32]
 8001908:	f013 0f02 	tst.w	r3, #2
 800190c:	d165      	bne.n	80019da <HAL_RCC_OscConfig+0x30a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800190e:	f7fe fcd5 	bl	80002bc <HAL_GetTick>
 8001912:	1b80      	subs	r0, r0, r6
 8001914:	f241 3388 	movw	r3, #5000	; 0x1388
 8001918:	4298      	cmp	r0, r3
 800191a:	d9f3      	bls.n	8001904 <HAL_RCC_OscConfig+0x234>
          return HAL_TIMEOUT;
 800191c:	2003      	movs	r0, #3
 800191e:	e0d4      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
      __HAL_RCC_LSI_DISABLE();
 8001920:	2200      	movs	r2, #0
 8001922:	4b1e      	ldr	r3, [pc, #120]	; (800199c <HAL_RCC_OscConfig+0x2cc>)
 8001924:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001926:	f7fe fcc9 	bl	80002bc <HAL_GetTick>
 800192a:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800192c:	4b19      	ldr	r3, [pc, #100]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 800192e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001930:	f013 0f02 	tst.w	r3, #2
 8001934:	d0b5      	beq.n	80018a2 <HAL_RCC_OscConfig+0x1d2>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001936:	f7fe fcc1 	bl	80002bc <HAL_GetTick>
 800193a:	1b40      	subs	r0, r0, r5
 800193c:	2802      	cmp	r0, #2
 800193e:	d9f5      	bls.n	800192c <HAL_RCC_OscConfig+0x25c>
          return HAL_TIMEOUT;
 8001940:	2003      	movs	r0, #3
 8001942:	e0c2      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
    FlagStatus       pwrclkchanged = RESET;
 8001944:	2500      	movs	r5, #0
 8001946:	e7c1      	b.n	80018cc <HAL_RCC_OscConfig+0x1fc>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001948:	4a15      	ldr	r2, [pc, #84]	; (80019a0 <HAL_RCC_OscConfig+0x2d0>)
 800194a:	6813      	ldr	r3, [r2, #0]
 800194c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001950:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8001952:	f7fe fcb3 	bl	80002bc <HAL_GetTick>
 8001956:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001958:	4b11      	ldr	r3, [pc, #68]	; (80019a0 <HAL_RCC_OscConfig+0x2d0>)
 800195a:	681b      	ldr	r3, [r3, #0]
 800195c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001960:	d1b9      	bne.n	80018d6 <HAL_RCC_OscConfig+0x206>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001962:	f7fe fcab 	bl	80002bc <HAL_GetTick>
 8001966:	1b80      	subs	r0, r0, r6
 8001968:	2864      	cmp	r0, #100	; 0x64
 800196a:	d9f5      	bls.n	8001958 <HAL_RCC_OscConfig+0x288>
          return HAL_TIMEOUT;
 800196c:	2003      	movs	r0, #3
 800196e:	e0ac      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001970:	4a08      	ldr	r2, [pc, #32]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001972:	6a13      	ldr	r3, [r2, #32]
 8001974:	f043 0301 	orr.w	r3, r3, #1
 8001978:	6213      	str	r3, [r2, #32]
 800197a:	e7bd      	b.n	80018f8 <HAL_RCC_OscConfig+0x228>
 800197c:	2b05      	cmp	r3, #5
 800197e:	d011      	beq.n	80019a4 <HAL_RCC_OscConfig+0x2d4>
 8001980:	4b04      	ldr	r3, [pc, #16]	; (8001994 <HAL_RCC_OscConfig+0x2c4>)
 8001982:	6a1a      	ldr	r2, [r3, #32]
 8001984:	f022 0201 	bic.w	r2, r2, #1
 8001988:	621a      	str	r2, [r3, #32]
 800198a:	6a1a      	ldr	r2, [r3, #32]
 800198c:	f022 0204 	bic.w	r2, r2, #4
 8001990:	621a      	str	r2, [r3, #32]
 8001992:	e7b1      	b.n	80018f8 <HAL_RCC_OscConfig+0x228>
 8001994:	40021000 	.word	0x40021000
 8001998:	42420000 	.word	0x42420000
 800199c:	42420480 	.word	0x42420480
 80019a0:	40007000 	.word	0x40007000
 80019a4:	4b4c      	ldr	r3, [pc, #304]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 80019a6:	6a1a      	ldr	r2, [r3, #32]
 80019a8:	f042 0204 	orr.w	r2, r2, #4
 80019ac:	621a      	str	r2, [r3, #32]
 80019ae:	6a1a      	ldr	r2, [r3, #32]
 80019b0:	f042 0201 	orr.w	r2, r2, #1
 80019b4:	621a      	str	r2, [r3, #32]
 80019b6:	e79f      	b.n	80018f8 <HAL_RCC_OscConfig+0x228>
      tickstart = HAL_GetTick();
 80019b8:	f7fe fc80 	bl	80002bc <HAL_GetTick>
 80019bc:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80019be:	4b46      	ldr	r3, [pc, #280]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 80019c0:	6a1b      	ldr	r3, [r3, #32]
 80019c2:	f013 0f02 	tst.w	r3, #2
 80019c6:	d008      	beq.n	80019da <HAL_RCC_OscConfig+0x30a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80019c8:	f7fe fc78 	bl	80002bc <HAL_GetTick>
 80019cc:	1b80      	subs	r0, r0, r6
 80019ce:	f241 3388 	movw	r3, #5000	; 0x1388
 80019d2:	4298      	cmp	r0, r3
 80019d4:	d9f3      	bls.n	80019be <HAL_RCC_OscConfig+0x2ee>
          return HAL_TIMEOUT;
 80019d6:	2003      	movs	r0, #3
 80019d8:	e077      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
    if (pwrclkchanged == SET)
 80019da:	b9e5      	cbnz	r5, 8001a16 <HAL_RCC_OscConfig+0x346>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80019dc:	69e3      	ldr	r3, [r4, #28]
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d072      	beq.n	8001ac8 <HAL_RCC_OscConfig+0x3f8>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80019e2:	4a3d      	ldr	r2, [pc, #244]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 80019e4:	6852      	ldr	r2, [r2, #4]
 80019e6:	f002 020c 	and.w	r2, r2, #12
 80019ea:	2a08      	cmp	r2, #8
 80019ec:	d056      	beq.n	8001a9c <HAL_RCC_OscConfig+0x3cc>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80019ee:	2b02      	cmp	r3, #2
 80019f0:	d017      	beq.n	8001a22 <HAL_RCC_OscConfig+0x352>
        __HAL_RCC_PLL_DISABLE();
 80019f2:	2200      	movs	r2, #0
 80019f4:	4b39      	ldr	r3, [pc, #228]	; (8001adc <HAL_RCC_OscConfig+0x40c>)
 80019f6:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80019f8:	f7fe fc60 	bl	80002bc <HAL_GetTick>
 80019fc:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80019fe:	4b36      	ldr	r3, [pc, #216]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a00:	681b      	ldr	r3, [r3, #0]
 8001a02:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001a06:	d047      	beq.n	8001a98 <HAL_RCC_OscConfig+0x3c8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001a08:	f7fe fc58 	bl	80002bc <HAL_GetTick>
 8001a0c:	1b00      	subs	r0, r0, r4
 8001a0e:	2802      	cmp	r0, #2
 8001a10:	d9f5      	bls.n	80019fe <HAL_RCC_OscConfig+0x32e>
            return HAL_TIMEOUT;
 8001a12:	2003      	movs	r0, #3
 8001a14:	e059      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001a16:	4a30      	ldr	r2, [pc, #192]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a18:	69d3      	ldr	r3, [r2, #28]
 8001a1a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001a1e:	61d3      	str	r3, [r2, #28]
 8001a20:	e7dc      	b.n	80019dc <HAL_RCC_OscConfig+0x30c>
        __HAL_RCC_PLL_DISABLE();
 8001a22:	2200      	movs	r2, #0
 8001a24:	4b2d      	ldr	r3, [pc, #180]	; (8001adc <HAL_RCC_OscConfig+0x40c>)
 8001a26:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001a28:	f7fe fc48 	bl	80002bc <HAL_GetTick>
 8001a2c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8001a2e:	4b2a      	ldr	r3, [pc, #168]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a30:	681b      	ldr	r3, [r3, #0]
 8001a32:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001a36:	d006      	beq.n	8001a46 <HAL_RCC_OscConfig+0x376>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001a38:	f7fe fc40 	bl	80002bc <HAL_GetTick>
 8001a3c:	1b40      	subs	r0, r0, r5
 8001a3e:	2802      	cmp	r0, #2
 8001a40:	d9f5      	bls.n	8001a2e <HAL_RCC_OscConfig+0x35e>
            return HAL_TIMEOUT;
 8001a42:	2003      	movs	r0, #3
 8001a44:	e041      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8001a46:	6a23      	ldr	r3, [r4, #32]
 8001a48:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001a4c:	d01a      	beq.n	8001a84 <HAL_RCC_OscConfig+0x3b4>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001a4e:	4922      	ldr	r1, [pc, #136]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a50:	684b      	ldr	r3, [r1, #4]
 8001a52:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 8001a56:	6a22      	ldr	r2, [r4, #32]
 8001a58:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001a5a:	4302      	orrs	r2, r0
 8001a5c:	4313      	orrs	r3, r2
 8001a5e:	604b      	str	r3, [r1, #4]
        __HAL_RCC_PLL_ENABLE();
 8001a60:	2201      	movs	r2, #1
 8001a62:	4b1e      	ldr	r3, [pc, #120]	; (8001adc <HAL_RCC_OscConfig+0x40c>)
 8001a64:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001a66:	f7fe fc29 	bl	80002bc <HAL_GetTick>
 8001a6a:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8001a6c:	4b1a      	ldr	r3, [pc, #104]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a6e:	681b      	ldr	r3, [r3, #0]
 8001a70:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001a74:	d10e      	bne.n	8001a94 <HAL_RCC_OscConfig+0x3c4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001a76:	f7fe fc21 	bl	80002bc <HAL_GetTick>
 8001a7a:	1b00      	subs	r0, r0, r4
 8001a7c:	2802      	cmp	r0, #2
 8001a7e:	d9f5      	bls.n	8001a6c <HAL_RCC_OscConfig+0x39c>
            return HAL_TIMEOUT;
 8001a80:	2003      	movs	r0, #3
 8001a82:	e022      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8001a84:	4a14      	ldr	r2, [pc, #80]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001a86:	6853      	ldr	r3, [r2, #4]
 8001a88:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001a8c:	68a1      	ldr	r1, [r4, #8]
 8001a8e:	430b      	orrs	r3, r1
 8001a90:	6053      	str	r3, [r2, #4]
 8001a92:	e7dc      	b.n	8001a4e <HAL_RCC_OscConfig+0x37e>
  return HAL_OK;
 8001a94:	2000      	movs	r0, #0
 8001a96:	e018      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
 8001a98:	2000      	movs	r0, #0
 8001a9a:	e016      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8001a9c:	2b01      	cmp	r3, #1
 8001a9e:	d016      	beq.n	8001ace <HAL_RCC_OscConfig+0x3fe>
        pll_config = RCC->CFGR;
 8001aa0:	4b0d      	ldr	r3, [pc, #52]	; (8001ad8 <HAL_RCC_OscConfig+0x408>)
 8001aa2:	685b      	ldr	r3, [r3, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001aa4:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 8001aa8:	6a22      	ldr	r2, [r4, #32]
 8001aaa:	4291      	cmp	r1, r2
 8001aac:	d001      	beq.n	8001ab2 <HAL_RCC_OscConfig+0x3e2>
          return HAL_ERROR;
 8001aae:	2001      	movs	r0, #1
 8001ab0:	e00b      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 8001ab2:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8001ab6:	6a62      	ldr	r2, [r4, #36]	; 0x24
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001ab8:	4293      	cmp	r3, r2
 8001aba:	d00a      	beq.n	8001ad2 <HAL_RCC_OscConfig+0x402>
          return HAL_ERROR;
 8001abc:	2001      	movs	r0, #1
 8001abe:	e004      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
    return HAL_ERROR;
 8001ac0:	2001      	movs	r0, #1
 8001ac2:	4770      	bx	lr
        return HAL_ERROR;
 8001ac4:	2001      	movs	r0, #1
 8001ac6:	e000      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
  return HAL_OK;
 8001ac8:	2000      	movs	r0, #0
}
 8001aca:	b002      	add	sp, #8
 8001acc:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8001ace:	2001      	movs	r0, #1
 8001ad0:	e7fb      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
  return HAL_OK;
 8001ad2:	2000      	movs	r0, #0
 8001ad4:	e7f9      	b.n	8001aca <HAL_RCC_OscConfig+0x3fa>
 8001ad6:	bf00      	nop
 8001ad8:	40021000 	.word	0x40021000
 8001adc:	42420060 	.word	0x42420060

08001ae0 <HAL_RCC_GetSysClockFreq>:
{
 8001ae0:	b510      	push	{r4, lr}
 8001ae2:	b086      	sub	sp, #24
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8001ae4:	4c15      	ldr	r4, [pc, #84]	; (8001b3c <HAL_RCC_GetSysClockFreq+0x5c>)
 8001ae6:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001aea:	f10d 0e18 	add.w	lr, sp, #24
 8001aee:	e90e 000f 	stmdb	lr, {r0, r1, r2, r3}
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8001af2:	8a23      	ldrh	r3, [r4, #16]
 8001af4:	f8ad 3004 	strh.w	r3, [sp, #4]
  tmpreg = RCC->CFGR;
 8001af8:	4b11      	ldr	r3, [pc, #68]	; (8001b40 <HAL_RCC_GetSysClockFreq+0x60>)
 8001afa:	685b      	ldr	r3, [r3, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8001afc:	f003 020c 	and.w	r2, r3, #12
 8001b00:	2a08      	cmp	r2, #8
 8001b02:	d118      	bne.n	8001b36 <HAL_RCC_GetSysClockFreq+0x56>
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8001b04:	f3c3 4283 	ubfx	r2, r3, #18, #4
 8001b08:	4472      	add	r2, lr
 8001b0a:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8001b0e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8001b12:	d103      	bne.n	8001b1c <HAL_RCC_GetSysClockFreq+0x3c>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8001b14:	480b      	ldr	r0, [pc, #44]	; (8001b44 <HAL_RCC_GetSysClockFreq+0x64>)
 8001b16:	fb00 f002 	mul.w	r0, r0, r2
 8001b1a:	e00d      	b.n	8001b38 <HAL_RCC_GetSysClockFreq+0x58>
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8001b1c:	4b08      	ldr	r3, [pc, #32]	; (8001b40 <HAL_RCC_GetSysClockFreq+0x60>)
 8001b1e:	685b      	ldr	r3, [r3, #4]
 8001b20:	f3c3 4340 	ubfx	r3, r3, #17, #1
 8001b24:	4473      	add	r3, lr
 8001b26:	f813 3c14 	ldrb.w	r3, [r3, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8001b2a:	4807      	ldr	r0, [pc, #28]	; (8001b48 <HAL_RCC_GetSysClockFreq+0x68>)
 8001b2c:	fb00 f002 	mul.w	r0, r0, r2
 8001b30:	fbb0 f0f3 	udiv	r0, r0, r3
 8001b34:	e000      	b.n	8001b38 <HAL_RCC_GetSysClockFreq+0x58>
      sysclockfreq = HSE_VALUE;
 8001b36:	4804      	ldr	r0, [pc, #16]	; (8001b48 <HAL_RCC_GetSysClockFreq+0x68>)
}
 8001b38:	b006      	add	sp, #24
 8001b3a:	bd10      	pop	{r4, pc}
 8001b3c:	08009ec0 	.word	0x08009ec0
 8001b40:	40021000 	.word	0x40021000
 8001b44:	003d0900 	.word	0x003d0900
 8001b48:	007a1200 	.word	0x007a1200

08001b4c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8001b4c:	2800      	cmp	r0, #0
 8001b4e:	f000 80a3 	beq.w	8001c98 <HAL_RCC_ClockConfig+0x14c>
{
 8001b52:	b570      	push	{r4, r5, r6, lr}
 8001b54:	4604      	mov	r4, r0
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001b56:	4b52      	ldr	r3, [pc, #328]	; (8001ca0 <HAL_RCC_ClockConfig+0x154>)
 8001b58:	681b      	ldr	r3, [r3, #0]
 8001b5a:	f003 0307 	and.w	r3, r3, #7
 8001b5e:	428b      	cmp	r3, r1
 8001b60:	d20c      	bcs.n	8001b7c <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001b62:	4a4f      	ldr	r2, [pc, #316]	; (8001ca0 <HAL_RCC_ClockConfig+0x154>)
 8001b64:	6813      	ldr	r3, [r2, #0]
 8001b66:	f023 0307 	bic.w	r3, r3, #7
 8001b6a:	430b      	orrs	r3, r1
 8001b6c:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001b6e:	6813      	ldr	r3, [r2, #0]
 8001b70:	f003 0307 	and.w	r3, r3, #7
 8001b74:	4299      	cmp	r1, r3
 8001b76:	d001      	beq.n	8001b7c <HAL_RCC_ClockConfig+0x30>
    return HAL_ERROR;
 8001b78:	2001      	movs	r0, #1
 8001b7a:	bd70      	pop	{r4, r5, r6, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001b7c:	6823      	ldr	r3, [r4, #0]
 8001b7e:	f013 0f02 	tst.w	r3, #2
 8001b82:	d017      	beq.n	8001bb4 <HAL_RCC_ClockConfig+0x68>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001b84:	f013 0f04 	tst.w	r3, #4
 8001b88:	d004      	beq.n	8001b94 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8001b8a:	4a46      	ldr	r2, [pc, #280]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001b8c:	6853      	ldr	r3, [r2, #4]
 8001b8e:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 8001b92:	6053      	str	r3, [r2, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001b94:	6823      	ldr	r3, [r4, #0]
 8001b96:	f013 0f08 	tst.w	r3, #8
 8001b9a:	d004      	beq.n	8001ba6 <HAL_RCC_ClockConfig+0x5a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8001b9c:	4a41      	ldr	r2, [pc, #260]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001b9e:	6853      	ldr	r3, [r2, #4]
 8001ba0:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8001ba4:	6053      	str	r3, [r2, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001ba6:	4a3f      	ldr	r2, [pc, #252]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001ba8:	6853      	ldr	r3, [r2, #4]
 8001baa:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001bae:	68a0      	ldr	r0, [r4, #8]
 8001bb0:	4303      	orrs	r3, r0
 8001bb2:	6053      	str	r3, [r2, #4]
 8001bb4:	460d      	mov	r5, r1
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001bb6:	6823      	ldr	r3, [r4, #0]
 8001bb8:	f013 0f01 	tst.w	r3, #1
 8001bbc:	d031      	beq.n	8001c22 <HAL_RCC_ClockConfig+0xd6>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001bbe:	6863      	ldr	r3, [r4, #4]
 8001bc0:	2b01      	cmp	r3, #1
 8001bc2:	d020      	beq.n	8001c06 <HAL_RCC_ClockConfig+0xba>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001bc4:	2b02      	cmp	r3, #2
 8001bc6:	d025      	beq.n	8001c14 <HAL_RCC_ClockConfig+0xc8>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001bc8:	4a36      	ldr	r2, [pc, #216]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001bca:	6812      	ldr	r2, [r2, #0]
 8001bcc:	f012 0f02 	tst.w	r2, #2
 8001bd0:	d064      	beq.n	8001c9c <HAL_RCC_ClockConfig+0x150>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001bd2:	4934      	ldr	r1, [pc, #208]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001bd4:	684a      	ldr	r2, [r1, #4]
 8001bd6:	f022 0203 	bic.w	r2, r2, #3
 8001bda:	4313      	orrs	r3, r2
 8001bdc:	604b      	str	r3, [r1, #4]
    tickstart = HAL_GetTick();
 8001bde:	f7fe fb6d 	bl	80002bc <HAL_GetTick>
 8001be2:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001be4:	4b2f      	ldr	r3, [pc, #188]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001be6:	685b      	ldr	r3, [r3, #4]
 8001be8:	f003 030c 	and.w	r3, r3, #12
 8001bec:	6862      	ldr	r2, [r4, #4]
 8001bee:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001bf2:	d016      	beq.n	8001c22 <HAL_RCC_ClockConfig+0xd6>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001bf4:	f7fe fb62 	bl	80002bc <HAL_GetTick>
 8001bf8:	1b80      	subs	r0, r0, r6
 8001bfa:	f241 3388 	movw	r3, #5000	; 0x1388
 8001bfe:	4298      	cmp	r0, r3
 8001c00:	d9f0      	bls.n	8001be4 <HAL_RCC_ClockConfig+0x98>
        return HAL_TIMEOUT;
 8001c02:	2003      	movs	r0, #3
 8001c04:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001c06:	4a27      	ldr	r2, [pc, #156]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001c08:	6812      	ldr	r2, [r2, #0]
 8001c0a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001c0e:	d1e0      	bne.n	8001bd2 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001c10:	2001      	movs	r0, #1
 8001c12:	bd70      	pop	{r4, r5, r6, pc}
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001c14:	4a23      	ldr	r2, [pc, #140]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001c16:	6812      	ldr	r2, [r2, #0]
 8001c18:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001c1c:	d1d9      	bne.n	8001bd2 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001c1e:	2001      	movs	r0, #1
 8001c20:	bd70      	pop	{r4, r5, r6, pc}
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8001c22:	4b1f      	ldr	r3, [pc, #124]	; (8001ca0 <HAL_RCC_ClockConfig+0x154>)
 8001c24:	681b      	ldr	r3, [r3, #0]
 8001c26:	f003 0307 	and.w	r3, r3, #7
 8001c2a:	429d      	cmp	r5, r3
 8001c2c:	d20c      	bcs.n	8001c48 <HAL_RCC_ClockConfig+0xfc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001c2e:	4a1c      	ldr	r2, [pc, #112]	; (8001ca0 <HAL_RCC_ClockConfig+0x154>)
 8001c30:	6813      	ldr	r3, [r2, #0]
 8001c32:	f023 0307 	bic.w	r3, r3, #7
 8001c36:	432b      	orrs	r3, r5
 8001c38:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001c3a:	6813      	ldr	r3, [r2, #0]
 8001c3c:	f003 0307 	and.w	r3, r3, #7
 8001c40:	429d      	cmp	r5, r3
 8001c42:	d001      	beq.n	8001c48 <HAL_RCC_ClockConfig+0xfc>
    return HAL_ERROR;
 8001c44:	2001      	movs	r0, #1
}
 8001c46:	bd70      	pop	{r4, r5, r6, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001c48:	6823      	ldr	r3, [r4, #0]
 8001c4a:	f013 0f04 	tst.w	r3, #4
 8001c4e:	d006      	beq.n	8001c5e <HAL_RCC_ClockConfig+0x112>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001c50:	4a14      	ldr	r2, [pc, #80]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001c52:	6853      	ldr	r3, [r2, #4]
 8001c54:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001c58:	68e1      	ldr	r1, [r4, #12]
 8001c5a:	430b      	orrs	r3, r1
 8001c5c:	6053      	str	r3, [r2, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001c5e:	6823      	ldr	r3, [r4, #0]
 8001c60:	f013 0f08 	tst.w	r3, #8
 8001c64:	d007      	beq.n	8001c76 <HAL_RCC_ClockConfig+0x12a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001c66:	4a0f      	ldr	r2, [pc, #60]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001c68:	6853      	ldr	r3, [r2, #4]
 8001c6a:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001c6e:	6921      	ldr	r1, [r4, #16]
 8001c70:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001c74:	6053      	str	r3, [r2, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001c76:	f7ff ff33 	bl	8001ae0 <HAL_RCC_GetSysClockFreq>
 8001c7a:	4b0a      	ldr	r3, [pc, #40]	; (8001ca4 <HAL_RCC_ClockConfig+0x158>)
 8001c7c:	685b      	ldr	r3, [r3, #4]
 8001c7e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001c82:	4a09      	ldr	r2, [pc, #36]	; (8001ca8 <HAL_RCC_ClockConfig+0x15c>)
 8001c84:	5cd3      	ldrb	r3, [r2, r3]
 8001c86:	40d8      	lsrs	r0, r3
 8001c88:	4b08      	ldr	r3, [pc, #32]	; (8001cac <HAL_RCC_ClockConfig+0x160>)
 8001c8a:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 8001c8c:	4b08      	ldr	r3, [pc, #32]	; (8001cb0 <HAL_RCC_ClockConfig+0x164>)
 8001c8e:	6818      	ldr	r0, [r3, #0]
 8001c90:	f7fe fad0 	bl	8000234 <HAL_InitTick>
  return HAL_OK;
 8001c94:	2000      	movs	r0, #0
 8001c96:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8001c98:	2001      	movs	r0, #1
 8001c9a:	4770      	bx	lr
        return HAL_ERROR;
 8001c9c:	2001      	movs	r0, #1
 8001c9e:	bd70      	pop	{r4, r5, r6, pc}
 8001ca0:	40022000 	.word	0x40022000
 8001ca4:	40021000 	.word	0x40021000
 8001ca8:	0800ac84 	.word	0x0800ac84
 8001cac:	20000124 	.word	0x20000124
 8001cb0:	20000004 	.word	0x20000004

08001cb4 <HAL_RCC_GetHCLKFreq>:
}
 8001cb4:	4b01      	ldr	r3, [pc, #4]	; (8001cbc <HAL_RCC_GetHCLKFreq+0x8>)
 8001cb6:	6818      	ldr	r0, [r3, #0]
 8001cb8:	4770      	bx	lr
 8001cba:	bf00      	nop
 8001cbc:	20000124 	.word	0x20000124

08001cc0 <HAL_RCC_GetPCLK1Freq>:
{
 8001cc0:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8001cc2:	f7ff fff7 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8001cc6:	4b04      	ldr	r3, [pc, #16]	; (8001cd8 <HAL_RCC_GetPCLK1Freq+0x18>)
 8001cc8:	685b      	ldr	r3, [r3, #4]
 8001cca:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8001cce:	4a03      	ldr	r2, [pc, #12]	; (8001cdc <HAL_RCC_GetPCLK1Freq+0x1c>)
 8001cd0:	5cd3      	ldrb	r3, [r2, r3]
}
 8001cd2:	40d8      	lsrs	r0, r3
 8001cd4:	bd08      	pop	{r3, pc}
 8001cd6:	bf00      	nop
 8001cd8:	40021000 	.word	0x40021000
 8001cdc:	0800ac94 	.word	0x0800ac94

08001ce0 <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001ce0:	b570      	push	{r4, r5, r6, lr}
 8001ce2:	b082      	sub	sp, #8
 8001ce4:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8001ce6:	6803      	ldr	r3, [r0, #0]
 8001ce8:	f013 0f01 	tst.w	r3, #1
 8001cec:	d034      	beq.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x78>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001cee:	4b3e      	ldr	r3, [pc, #248]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001cf0:	69db      	ldr	r3, [r3, #28]
 8001cf2:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8001cf6:	d148      	bne.n	8001d8a <HAL_RCCEx_PeriphCLKConfig+0xaa>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001cf8:	4b3b      	ldr	r3, [pc, #236]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001cfa:	69da      	ldr	r2, [r3, #28]
 8001cfc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001d00:	61da      	str	r2, [r3, #28]
 8001d02:	69db      	ldr	r3, [r3, #28]
 8001d04:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001d08:	9301      	str	r3, [sp, #4]
 8001d0a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001d0c:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001d0e:	4b37      	ldr	r3, [pc, #220]	; (8001dec <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8001d10:	681b      	ldr	r3, [r3, #0]
 8001d12:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001d16:	d03a      	beq.n	8001d8e <HAL_RCCEx_PeriphCLKConfig+0xae>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8001d18:	4b33      	ldr	r3, [pc, #204]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001d1a:	6a1b      	ldr	r3, [r3, #32]
    if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001d1c:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001d20:	d011      	beq.n	8001d46 <HAL_RCCEx_PeriphCLKConfig+0x66>
 8001d22:	6862      	ldr	r2, [r4, #4]
 8001d24:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001d28:	4293      	cmp	r3, r2
 8001d2a:	d00c      	beq.n	8001d46 <HAL_RCCEx_PeriphCLKConfig+0x66>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8001d2c:	4a2e      	ldr	r2, [pc, #184]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001d2e:	6a13      	ldr	r3, [r2, #32]
 8001d30:	f423 7040 	bic.w	r0, r3, #768	; 0x300
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8001d34:	492e      	ldr	r1, [pc, #184]	; (8001df0 <HAL_RCCEx_PeriphCLKConfig+0x110>)
 8001d36:	2601      	movs	r6, #1
 8001d38:	600e      	str	r6, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001d3a:	2600      	movs	r6, #0
 8001d3c:	600e      	str	r6, [r1, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 8001d3e:	6210      	str	r0, [r2, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8001d40:	f013 0f01 	tst.w	r3, #1
 8001d44:	d137      	bne.n	8001db6 <HAL_RCCEx_PeriphCLKConfig+0xd6>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001d46:	4a28      	ldr	r2, [pc, #160]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001d48:	6a13      	ldr	r3, [r2, #32]
 8001d4a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001d4e:	6861      	ldr	r1, [r4, #4]
 8001d50:	430b      	orrs	r3, r1
 8001d52:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 8001d54:	2d00      	cmp	r5, #0
 8001d56:	d13f      	bne.n	8001dd8 <HAL_RCCEx_PeriphCLKConfig+0xf8>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8001d58:	6823      	ldr	r3, [r4, #0]
 8001d5a:	f013 0f02 	tst.w	r3, #2
 8001d5e:	d006      	beq.n	8001d6e <HAL_RCCEx_PeriphCLKConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001d60:	4a21      	ldr	r2, [pc, #132]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001d62:	6853      	ldr	r3, [r2, #4]
 8001d64:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8001d68:	68a1      	ldr	r1, [r4, #8]
 8001d6a:	430b      	orrs	r3, r1
 8001d6c:	6053      	str	r3, [r2, #4]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8001d6e:	6823      	ldr	r3, [r4, #0]
 8001d70:	f013 0f10 	tst.w	r3, #16
 8001d74:	d035      	beq.n	8001de2 <HAL_RCCEx_PeriphCLKConfig+0x102>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));

    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001d76:	4a1c      	ldr	r2, [pc, #112]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001d78:	6853      	ldr	r3, [r2, #4]
 8001d7a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001d7e:	6961      	ldr	r1, [r4, #20]
 8001d80:	430b      	orrs	r3, r1
 8001d82:	6053      	str	r3, [r2, #4]
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 8001d84:	2000      	movs	r0, #0
}
 8001d86:	b002      	add	sp, #8
 8001d88:	bd70      	pop	{r4, r5, r6, pc}
    FlagStatus       pwrclkchanged = RESET;
 8001d8a:	2500      	movs	r5, #0
 8001d8c:	e7bf      	b.n	8001d0e <HAL_RCCEx_PeriphCLKConfig+0x2e>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001d8e:	4a17      	ldr	r2, [pc, #92]	; (8001dec <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8001d90:	6813      	ldr	r3, [r2, #0]
 8001d92:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001d96:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8001d98:	f7fe fa90 	bl	80002bc <HAL_GetTick>
 8001d9c:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001d9e:	4b13      	ldr	r3, [pc, #76]	; (8001dec <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8001da0:	681b      	ldr	r3, [r3, #0]
 8001da2:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001da6:	d1b7      	bne.n	8001d18 <HAL_RCCEx_PeriphCLKConfig+0x38>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001da8:	f7fe fa88 	bl	80002bc <HAL_GetTick>
 8001dac:	1b80      	subs	r0, r0, r6
 8001dae:	2864      	cmp	r0, #100	; 0x64
 8001db0:	d9f5      	bls.n	8001d9e <HAL_RCCEx_PeriphCLKConfig+0xbe>
          return HAL_TIMEOUT;
 8001db2:	2003      	movs	r0, #3
 8001db4:	e7e7      	b.n	8001d86 <HAL_RCCEx_PeriphCLKConfig+0xa6>
        tickstart = HAL_GetTick();
 8001db6:	f7fe fa81 	bl	80002bc <HAL_GetTick>
 8001dba:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001dbc:	4b0a      	ldr	r3, [pc, #40]	; (8001de8 <HAL_RCCEx_PeriphCLKConfig+0x108>)
 8001dbe:	6a1b      	ldr	r3, [r3, #32]
 8001dc0:	f013 0f02 	tst.w	r3, #2
 8001dc4:	d1bf      	bne.n	8001d46 <HAL_RCCEx_PeriphCLKConfig+0x66>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001dc6:	f7fe fa79 	bl	80002bc <HAL_GetTick>
 8001dca:	1b80      	subs	r0, r0, r6
 8001dcc:	f241 3388 	movw	r3, #5000	; 0x1388
 8001dd0:	4298      	cmp	r0, r3
 8001dd2:	d9f3      	bls.n	8001dbc <HAL_RCCEx_PeriphCLKConfig+0xdc>
            return HAL_TIMEOUT;
 8001dd4:	2003      	movs	r0, #3
 8001dd6:	e7d6      	b.n	8001d86 <HAL_RCCEx_PeriphCLKConfig+0xa6>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001dd8:	69d3      	ldr	r3, [r2, #28]
 8001dda:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001dde:	61d3      	str	r3, [r2, #28]
 8001de0:	e7ba      	b.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x78>
  return HAL_OK;
 8001de2:	2000      	movs	r0, #0
 8001de4:	e7cf      	b.n	8001d86 <HAL_RCCEx_PeriphCLKConfig+0xa6>
 8001de6:	bf00      	nop
 8001de8:	40021000 	.word	0x40021000
 8001dec:	40007000 	.word	0x40007000
 8001df0:	42420440 	.word	0x42420440

08001df4 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
 8001df4:	b570      	push	{r4, r5, r6, lr}
 8001df6:	b082      	sub	sp, #8
 8001df8:	4604      	mov	r4, r0
  __IO uint32_t count = 0U;
 8001dfa:	2300      	movs	r3, #0
 8001dfc:	9301      	str	r3, [sp, #4]
  uint32_t response = 0U, validvoltage = 0U;
  uint32_t errorstate;

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8001dfe:	6800      	ldr	r0, [r0, #0]
 8001e00:	f001 fd64 	bl	80038cc <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001e04:	4606      	mov	r6, r0
 8001e06:	b110      	cbz	r0, 8001e0e <SD_PowerON+0x1a>
    hsd->SdCard.CardType = CARD_SDSC;
  }


  return HAL_SD_ERROR_NONE;
}
 8001e08:	4630      	mov	r0, r6
 8001e0a:	b002      	add	sp, #8
 8001e0c:	bd70      	pop	{r4, r5, r6, pc}
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 8001e0e:	6820      	ldr	r0, [r4, #0]
 8001e10:	f001 fd6f 	bl	80038f2 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001e14:	b938      	cbnz	r0, 8001e26 <SD_PowerON+0x32>
    hsd->SdCard.CardVersion = CARD_V2_X;
 8001e16:	2301      	movs	r3, #1
 8001e18:	64a3      	str	r3, [r4, #72]	; 0x48
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 8001e1a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e1c:	2b01      	cmp	r3, #1
 8001e1e:	d00b      	beq.n	8001e38 <SD_PowerON+0x44>
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8001e20:	4635      	mov	r5, r6
 8001e22:	4630      	mov	r0, r6
 8001e24:	e014      	b.n	8001e50 <SD_PowerON+0x5c>
    hsd->SdCard.CardVersion = CARD_V1_X;
 8001e26:	2300      	movs	r3, #0
 8001e28:	64a3      	str	r3, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8001e2a:	6820      	ldr	r0, [r4, #0]
 8001e2c:	f001 fd4e 	bl	80038cc <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001e30:	2800      	cmp	r0, #0
 8001e32:	d0f2      	beq.n	8001e1a <SD_PowerON+0x26>
      return errorstate;
 8001e34:	4606      	mov	r6, r0
 8001e36:	e7e7      	b.n	8001e08 <SD_PowerON+0x14>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8001e38:	2100      	movs	r1, #0
 8001e3a:	6820      	ldr	r0, [r4, #0]
 8001e3c:	f001 fd70 	bl	8003920 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001e40:	2800      	cmp	r0, #0
 8001e42:	d0ed      	beq.n	8001e20 <SD_PowerON+0x2c>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8001e44:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8001e48:	e7de      	b.n	8001e08 <SD_PowerON+0x14>
    count++;
 8001e4a:	9b01      	ldr	r3, [sp, #4]
 8001e4c:	3301      	adds	r3, #1
 8001e4e:	9301      	str	r3, [sp, #4]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8001e50:	9a01      	ldr	r2, [sp, #4]
 8001e52:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8001e56:	429a      	cmp	r2, r3
 8001e58:	d813      	bhi.n	8001e82 <SD_PowerON+0x8e>
 8001e5a:	b995      	cbnz	r5, 8001e82 <SD_PowerON+0x8e>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8001e5c:	2100      	movs	r1, #0
 8001e5e:	6820      	ldr	r0, [r4, #0]
 8001e60:	f001 fd5e 	bl	8003920 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001e64:	b9f0      	cbnz	r0, 8001ea4 <SD_PowerON+0xb0>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 8001e66:	4912      	ldr	r1, [pc, #72]	; (8001eb0 <SD_PowerON+0xbc>)
 8001e68:	6820      	ldr	r0, [r4, #0]
 8001e6a:	f001 fd71 	bl	8003950 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8001e6e:	4605      	mov	r5, r0
 8001e70:	b9d0      	cbnz	r0, 8001ea8 <SD_PowerON+0xb4>
    response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8001e72:	2100      	movs	r1, #0
 8001e74:	6820      	ldr	r0, [r4, #0]
 8001e76:	f001 fb6b 	bl	8003550 <SDIO_GetResponse>
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8001e7a:	0fc3      	lsrs	r3, r0, #31
 8001e7c:	d0e5      	beq.n	8001e4a <SD_PowerON+0x56>
 8001e7e:	461d      	mov	r5, r3
 8001e80:	e7e3      	b.n	8001e4a <SD_PowerON+0x56>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 8001e82:	9a01      	ldr	r2, [sp, #4]
 8001e84:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8001e88:	429a      	cmp	r2, r3
 8001e8a:	d902      	bls.n	8001e92 <SD_PowerON+0x9e>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8001e8c:	f04f 7680 	mov.w	r6, #16777216	; 0x1000000
 8001e90:	e7ba      	b.n	8001e08 <SD_PowerON+0x14>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8001e92:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8001e96:	d102      	bne.n	8001e9e <SD_PowerON+0xaa>
    hsd->SdCard.CardType = CARD_SDSC;
 8001e98:	2300      	movs	r3, #0
 8001e9a:	6463      	str	r3, [r4, #68]	; 0x44
 8001e9c:	e7b4      	b.n	8001e08 <SD_PowerON+0x14>
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 8001e9e:	2301      	movs	r3, #1
 8001ea0:	6463      	str	r3, [r4, #68]	; 0x44
 8001ea2:	e7b1      	b.n	8001e08 <SD_PowerON+0x14>
      return errorstate;
 8001ea4:	4606      	mov	r6, r0
 8001ea6:	e7af      	b.n	8001e08 <SD_PowerON+0x14>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8001ea8:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8001eac:	e7ac      	b.n	8001e08 <SD_PowerON+0x14>
 8001eae:	bf00      	nop
 8001eb0:	c1100000 	.word	0xc1100000

08001eb4 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8001eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001eb8:	b088      	sub	sp, #32
 8001eba:	4604      	mov	r4, r0
 8001ebc:	460f      	mov	r7, r1
  SDIO_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8001ebe:	f7fe f9fd 	bl	80002bc <HAL_GetTick>
 8001ec2:	4606      	mov	r6, r0
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8001ec4:	2300      	movs	r3, #0
 8001ec6:	9300      	str	r3, [sp, #0]
 8001ec8:	9301      	str	r3, [sp, #4]
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8001eca:	2108      	movs	r1, #8
 8001ecc:	6820      	ldr	r0, [r4, #0]
 8001ece:	f001 fc53 	bl	8003778 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001ed2:	4605      	mov	r5, r0
 8001ed4:	b118      	cbz	r0, 8001ede <SD_FindSCR+0x2a>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 8001ed6:	4628      	mov	r0, r5
 8001ed8:	b008      	add	sp, #32
 8001eda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8001ede:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001ee0:	0409      	lsls	r1, r1, #16
 8001ee2:	6820      	ldr	r0, [r4, #0]
 8001ee4:	f001 fd1c 	bl	8003920 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001ee8:	4605      	mov	r5, r0
 8001eea:	2800      	cmp	r0, #0
 8001eec:	d1f3      	bne.n	8001ed6 <SD_FindSCR+0x22>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8001eee:	f04f 33ff 	mov.w	r3, #4294967295
 8001ef2:	9302      	str	r3, [sp, #8]
  config.DataLength    = 8U;
 8001ef4:	2308      	movs	r3, #8
 8001ef6:	9303      	str	r3, [sp, #12]
  config.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 8001ef8:	2330      	movs	r3, #48	; 0x30
 8001efa:	9304      	str	r3, [sp, #16]
  config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8001efc:	2302      	movs	r3, #2
 8001efe:	9305      	str	r3, [sp, #20]
  config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8001f00:	2300      	movs	r3, #0
 8001f02:	9306      	str	r3, [sp, #24]
  config.DPSM          = SDIO_DPSM_ENABLE;
 8001f04:	2301      	movs	r3, #1
 8001f06:	9307      	str	r3, [sp, #28]
  (void)SDIO_ConfigData(hsd->Instance, &config);
 8001f08:	a902      	add	r1, sp, #8
 8001f0a:	6820      	ldr	r0, [r4, #0]
 8001f0c:	f001 fc22 	bl	8003754 <SDIO_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8001f10:	6820      	ldr	r0, [r4, #0]
 8001f12:	f001 fd4e 	bl	80039b2 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001f16:	4605      	mov	r5, r0
 8001f18:	2800      	cmp	r0, #0
 8001f1a:	d1dc      	bne.n	8001ed6 <SD_FindSCR+0x22>
 8001f1c:	4680      	mov	r8, r0
 8001f1e:	e005      	b.n	8001f2c <SD_FindSCR+0x78>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8001f20:	f7fe f9cc 	bl	80002bc <HAL_GetTick>
 8001f24:	1b80      	subs	r0, r0, r6
 8001f26:	f1b0 3fff 	cmp.w	r0, #4294967295
 8001f2a:	d043      	beq.n	8001fb4 <SD_FindSCR+0x100>
  while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
 8001f2c:	6820      	ldr	r0, [r4, #0]
 8001f2e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001f30:	f240 432a 	movw	r3, #1066	; 0x42a
 8001f34:	421a      	tst	r2, r3
 8001f36:	d10a      	bne.n	8001f4e <SD_FindSCR+0x9a>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8001f38:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001f3a:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8001f3e:	d0ef      	beq.n	8001f20 <SD_FindSCR+0x6c>
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8001f40:	f001 fadd 	bl	80034fe <SDIO_ReadFIFO>
 8001f44:	f84d 0028 	str.w	r0, [sp, r8, lsl #2]
      index++;
 8001f48:	f108 0801 	add.w	r8, r8, #1
 8001f4c:	e7e8      	b.n	8001f20 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8001f4e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001f50:	f013 0f08 	tst.w	r3, #8
 8001f54:	d002      	beq.n	8001f5c <SD_FindSCR+0xa8>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8001f56:	2508      	movs	r5, #8
 8001f58:	6385      	str	r5, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8001f5a:	e7bc      	b.n	8001ed6 <SD_FindSCR+0x22>
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8001f5c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001f5e:	f013 0f02 	tst.w	r3, #2
 8001f62:	d002      	beq.n	8001f6a <SD_FindSCR+0xb6>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8001f64:	2502      	movs	r5, #2
 8001f66:	6385      	str	r5, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8001f68:	e7b5      	b.n	8001ed6 <SD_FindSCR+0x22>
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8001f6a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001f6c:	f013 0f20 	tst.w	r3, #32
 8001f70:	d002      	beq.n	8001f78 <SD_FindSCR+0xc4>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8001f72:	2520      	movs	r5, #32
 8001f74:	6385      	str	r5, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 8001f76:	e7ae      	b.n	8001ed6 <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 8001f78:	f240 533a 	movw	r3, #1338	; 0x53a
 8001f7c:	6383      	str	r3, [r0, #56]	; 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8001f7e:	9a01      	ldr	r2, [sp, #4]
 8001f80:	0213      	lsls	r3, r2, #8
 8001f82:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8001f86:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
 8001f8a:	0a11      	lsrs	r1, r2, #8
 8001f8c:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8001f90:	430b      	orrs	r3, r1
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
 8001f92:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8001f96:	603b      	str	r3, [r7, #0]
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8001f98:	9a00      	ldr	r2, [sp, #0]
 8001f9a:	0213      	lsls	r3, r2, #8
 8001f9c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8001fa0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
 8001fa4:	0a11      	lsrs	r1, r2, #8
 8001fa6:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8001faa:	430b      	orrs	r3, r1
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
 8001fac:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8001fb0:	607b      	str	r3, [r7, #4]
  return HAL_SD_ERROR_NONE;
 8001fb2:	e790      	b.n	8001ed6 <SD_FindSCR+0x22>
      return HAL_SD_ERROR_TIMEOUT;
 8001fb4:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 8001fb8:	e78d      	b.n	8001ed6 <SD_FindSCR+0x22>

08001fba <SD_WideBus_Enable>:
{
 8001fba:	b510      	push	{r4, lr}
 8001fbc:	b082      	sub	sp, #8
 8001fbe:	4604      	mov	r4, r0
  uint32_t scr[2U] = {0U, 0U};
 8001fc0:	2100      	movs	r1, #0
 8001fc2:	9100      	str	r1, [sp, #0]
 8001fc4:	9101      	str	r1, [sp, #4]
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8001fc6:	6800      	ldr	r0, [r0, #0]
 8001fc8:	f001 fac2 	bl	8003550 <SDIO_GetResponse>
 8001fcc:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 8001fd0:	d004      	beq.n	8001fdc <SD_WideBus_Enable+0x22>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8001fd2:	f44f 6300 	mov.w	r3, #2048	; 0x800
}
 8001fd6:	4618      	mov	r0, r3
 8001fd8:	b002      	add	sp, #8
 8001fda:	bd10      	pop	{r4, pc}
  errorstate = SD_FindSCR(hsd, scr);
 8001fdc:	4669      	mov	r1, sp
 8001fde:	4620      	mov	r0, r4
 8001fe0:	f7ff ff68 	bl	8001eb4 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8001fe4:	4603      	mov	r3, r0
 8001fe6:	2800      	cmp	r0, #0
 8001fe8:	d1f5      	bne.n	8001fd6 <SD_WideBus_Enable+0x1c>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8001fea:	9b01      	ldr	r3, [sp, #4]
 8001fec:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001ff0:	d102      	bne.n	8001ff8 <SD_WideBus_Enable+0x3e>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8001ff2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8001ff6:	e7ee      	b.n	8001fd6 <SD_WideBus_Enable+0x1c>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8001ff8:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001ffa:	0409      	lsls	r1, r1, #16
 8001ffc:	6820      	ldr	r0, [r4, #0]
 8001ffe:	f001 fc8f 	bl	8003920 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002002:	4603      	mov	r3, r0
 8002004:	2800      	cmp	r0, #0
 8002006:	d1e6      	bne.n	8001fd6 <SD_WideBus_Enable+0x1c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 8002008:	2102      	movs	r1, #2
 800200a:	6820      	ldr	r0, [r4, #0]
 800200c:	f001 fcb9 	bl	8003982 <SDMMC_CmdBusWidth>
 8002010:	4603      	mov	r3, r0
 8002012:	e7e0      	b.n	8001fd6 <SD_WideBus_Enable+0x1c>

08002014 <SD_WideBus_Disable>:
{
 8002014:	b510      	push	{r4, lr}
 8002016:	b082      	sub	sp, #8
 8002018:	4604      	mov	r4, r0
  uint32_t scr[2U] = {0U, 0U};
 800201a:	2100      	movs	r1, #0
 800201c:	9100      	str	r1, [sp, #0]
 800201e:	9101      	str	r1, [sp, #4]
  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8002020:	6800      	ldr	r0, [r0, #0]
 8002022:	f001 fa95 	bl	8003550 <SDIO_GetResponse>
 8002026:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 800202a:	d004      	beq.n	8002036 <SD_WideBus_Disable+0x22>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800202c:	f44f 6300 	mov.w	r3, #2048	; 0x800
}
 8002030:	4618      	mov	r0, r3
 8002032:	b002      	add	sp, #8
 8002034:	bd10      	pop	{r4, pc}
  errorstate = SD_FindSCR(hsd, scr);
 8002036:	4669      	mov	r1, sp
 8002038:	4620      	mov	r0, r4
 800203a:	f7ff ff3b 	bl	8001eb4 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800203e:	4603      	mov	r3, r0
 8002040:	2800      	cmp	r0, #0
 8002042:	d1f5      	bne.n	8002030 <SD_WideBus_Disable+0x1c>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8002044:	9b01      	ldr	r3, [sp, #4]
 8002046:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 800204a:	d102      	bne.n	8002052 <SD_WideBus_Disable+0x3e>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800204c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8002050:	e7ee      	b.n	8002030 <SD_WideBus_Disable+0x1c>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002052:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8002054:	0409      	lsls	r1, r1, #16
 8002056:	6820      	ldr	r0, [r4, #0]
 8002058:	f001 fc62 	bl	8003920 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800205c:	4603      	mov	r3, r0
 800205e:	2800      	cmp	r0, #0
 8002060:	d1e6      	bne.n	8002030 <SD_WideBus_Disable+0x1c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 8002062:	2100      	movs	r1, #0
 8002064:	6820      	ldr	r0, [r4, #0]
 8002066:	f001 fc8c 	bl	8003982 <SDMMC_CmdBusWidth>
 800206a:	4603      	mov	r3, r0
 800206c:	e7e0      	b.n	8002030 <SD_WideBus_Disable+0x1c>

0800206e <SD_SendStatus>:
{
 800206e:	b570      	push	{r4, r5, r6, lr}
  if(pCardStatus == NULL)
 8002070:	b171      	cbz	r1, 8002090 <SD_SendStatus+0x22>
 8002072:	460d      	mov	r5, r1
 8002074:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002076:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8002078:	0409      	lsls	r1, r1, #16
 800207a:	6800      	ldr	r0, [r0, #0]
 800207c:	f001 fcf3 	bl	8003a66 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 8002080:	4606      	mov	r6, r0
 8002082:	b938      	cbnz	r0, 8002094 <SD_SendStatus+0x26>
  *pCardStatus = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8002084:	2100      	movs	r1, #0
 8002086:	6820      	ldr	r0, [r4, #0]
 8002088:	f001 fa62 	bl	8003550 <SDIO_GetResponse>
 800208c:	6028      	str	r0, [r5, #0]
  return HAL_SD_ERROR_NONE;
 800208e:	e001      	b.n	8002094 <SD_SendStatus+0x26>
    return HAL_SD_ERROR_PARAM;
 8002090:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
}
 8002094:	4630      	mov	r0, r6
 8002096:	bd70      	pop	{r4, r5, r6, pc}

08002098 <HAL_SD_ReadBlocks>:
{
 8002098:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800209c:	b086      	sub	sp, #24
 800209e:	4605      	mov	r5, r0
 80020a0:	460c      	mov	r4, r1
 80020a2:	4616      	mov	r6, r2
 80020a4:	4699      	mov	r9, r3
  uint32_t tickstart = HAL_GetTick();
 80020a6:	f7fe f909 	bl	80002bc <HAL_GetTick>
  if(NULL == pData)
 80020aa:	b16c      	cbz	r4, 80020c8 <HAL_SD_ReadBlocks+0x30>
 80020ac:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
 80020ae:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 80020b2:	b2db      	uxtb	r3, r3
 80020b4:	2b01      	cmp	r3, #1
 80020b6:	d00d      	beq.n	80020d4 <HAL_SD_ReadBlocks+0x3c>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 80020b8:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80020ba:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80020be:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 80020c0:	2001      	movs	r0, #1
}
 80020c2:	b006      	add	sp, #24
 80020c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80020c8:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80020ca:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80020ce:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 80020d0:	2001      	movs	r0, #1
 80020d2:	e7f6      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80020d4:	2300      	movs	r3, #0
 80020d6:	63ab      	str	r3, [r5, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 80020d8:	eb06 0309 	add.w	r3, r6, r9
 80020dc:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 80020de:	4293      	cmp	r3, r2
 80020e0:	d81a      	bhi.n	8002118 <HAL_SD_ReadBlocks+0x80>
    hsd->State = HAL_SD_STATE_BUSY;
 80020e2:	2303      	movs	r3, #3
 80020e4:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 80020e8:	682b      	ldr	r3, [r5, #0]
 80020ea:	2200      	movs	r2, #0
 80020ec:	62da      	str	r2, [r3, #44]	; 0x2c
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 80020ee:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80020f0:	2b01      	cmp	r3, #1
 80020f2:	d000      	beq.n	80020f6 <HAL_SD_ReadBlocks+0x5e>
      add *= 512U;
 80020f4:	0276      	lsls	r6, r6, #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80020f6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80020fa:	6828      	ldr	r0, [r5, #0]
 80020fc:	f001 fb3c 	bl	8003778 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002100:	4603      	mov	r3, r0
 8002102:	b178      	cbz	r0, 8002124 <HAL_SD_ReadBlocks+0x8c>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002104:	682a      	ldr	r2, [r5, #0]
 8002106:	497c      	ldr	r1, [pc, #496]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 8002108:	6391      	str	r1, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 800210a:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800210c:	4313      	orrs	r3, r2
 800210e:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8002110:	2001      	movs	r0, #1
 8002112:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      return HAL_ERROR;
 8002116:	e7d4      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8002118:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800211a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800211e:	63ab      	str	r3, [r5, #56]	; 0x38
      return HAL_ERROR;
 8002120:	2001      	movs	r0, #1
 8002122:	e7ce      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8002124:	f04f 33ff 	mov.w	r3, #4294967295
 8002128:	9300      	str	r3, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800212a:	ea4f 2349 	mov.w	r3, r9, lsl #9
 800212e:	9301      	str	r3, [sp, #4]
    config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8002130:	2390      	movs	r3, #144	; 0x90
 8002132:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8002134:	2302      	movs	r3, #2
 8002136:	9303      	str	r3, [sp, #12]
    config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8002138:	2300      	movs	r3, #0
 800213a:	9304      	str	r3, [sp, #16]
    config.DPSM          = SDIO_DPSM_ENABLE;
 800213c:	2301      	movs	r3, #1
 800213e:	9305      	str	r3, [sp, #20]
    (void)SDIO_ConfigData(hsd->Instance, &config);
 8002140:	4669      	mov	r1, sp
 8002142:	6828      	ldr	r0, [r5, #0]
 8002144:	f001 fb06 	bl	8003754 <SDIO_ConfigData>
    if(NumberOfBlocks > 1U)
 8002148:	f1b9 0f01 	cmp.w	r9, #1
 800214c:	d90b      	bls.n	8002166 <HAL_SD_ReadBlocks+0xce>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 800214e:	2302      	movs	r3, #2
 8002150:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8002152:	4631      	mov	r1, r6
 8002154:	6828      	ldr	r0, [r5, #0]
 8002156:	f001 fb3f 	bl	80037d8 <SDMMC_CmdReadMultiBlock>
 800215a:	4682      	mov	sl, r0
    if(errorstate != HAL_SD_ERROR_NONE)
 800215c:	f1ba 0f00 	cmp.w	sl, #0
 8002160:	d109      	bne.n	8002176 <HAL_SD_ReadBlocks+0xde>
    dataremaining = config.DataLength;
 8002162:	9f01      	ldr	r7, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 8002164:	e01c      	b.n	80021a0 <HAL_SD_ReadBlocks+0x108>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 8002166:	2301      	movs	r3, #1
 8002168:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800216a:	4631      	mov	r1, r6
 800216c:	6828      	ldr	r0, [r5, #0]
 800216e:	f001 fb1b 	bl	80037a8 <SDMMC_CmdReadSingleBlock>
 8002172:	4682      	mov	sl, r0
 8002174:	e7f2      	b.n	800215c <HAL_SD_ReadBlocks+0xc4>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002176:	682b      	ldr	r3, [r5, #0]
 8002178:	4a5f      	ldr	r2, [pc, #380]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 800217a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 800217c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800217e:	ea4a 0303 	orr.w	r3, sl, r3
 8002182:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8002184:	2001      	movs	r0, #1
 8002186:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800218a:	2300      	movs	r3, #0
 800218c:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 800218e:	e798      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 8002190:	f7fe f894 	bl	80002bc <HAL_GetTick>
 8002194:	eba0 0008 	sub.w	r0, r0, r8
 8002198:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800219a:	4298      	cmp	r0, r3
 800219c:	d21f      	bcs.n	80021de <HAL_SD_ReadBlocks+0x146>
 800219e:	b1f3      	cbz	r3, 80021de <HAL_SD_ReadBlocks+0x146>
    while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 80021a0:	6828      	ldr	r0, [r5, #0]
 80021a2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80021a4:	f240 332a 	movw	r3, #810	; 0x32a
 80021a8:	421a      	tst	r2, r3
 80021aa:	d126      	bne.n	80021fa <HAL_SD_ReadBlocks+0x162>
      if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF) && (dataremaining > 0U))
 80021ac:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80021ae:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 80021b2:	d0ed      	beq.n	8002190 <HAL_SD_ReadBlocks+0xf8>
 80021b4:	2f00      	cmp	r7, #0
 80021b6:	d0eb      	beq.n	8002190 <HAL_SD_ReadBlocks+0xf8>
 80021b8:	4656      	mov	r6, sl
        for(count = 0U; count < 8U; count++)
 80021ba:	2e07      	cmp	r6, #7
 80021bc:	d8e8      	bhi.n	8002190 <HAL_SD_ReadBlocks+0xf8>
          data = SDIO_ReadFIFO(hsd->Instance);
 80021be:	6828      	ldr	r0, [r5, #0]
 80021c0:	f001 f99d 	bl	80034fe <SDIO_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
 80021c4:	7020      	strb	r0, [r4, #0]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 80021c6:	f3c0 2307 	ubfx	r3, r0, #8, #8
 80021ca:	7063      	strb	r3, [r4, #1]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 80021cc:	f3c0 4307 	ubfx	r3, r0, #16, #8
 80021d0:	70a3      	strb	r3, [r4, #2]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 80021d2:	0e00      	lsrs	r0, r0, #24
 80021d4:	70e0      	strb	r0, [r4, #3]
          tempbuff++;
 80021d6:	3404      	adds	r4, #4
          dataremaining--;
 80021d8:	3f04      	subs	r7, #4
        for(count = 0U; count < 8U; count++)
 80021da:	3601      	adds	r6, #1
 80021dc:	e7ed      	b.n	80021ba <HAL_SD_ReadBlocks+0x122>
        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80021de:	682b      	ldr	r3, [r5, #0]
 80021e0:	4a45      	ldr	r2, [pc, #276]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 80021e2:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 80021e4:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80021e6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80021ea:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 80021ec:	2301      	movs	r3, #1
 80021ee:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 80021f2:	2300      	movs	r3, #0
 80021f4:	632b      	str	r3, [r5, #48]	; 0x30
        return HAL_TIMEOUT;
 80021f6:	2003      	movs	r0, #3
 80021f8:	e763      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 80021fa:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80021fc:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002200:	d00a      	beq.n	8002218 <HAL_SD_ReadBlocks+0x180>
 8002202:	f1b9 0f01 	cmp.w	r9, #1
 8002206:	d907      	bls.n	8002218 <HAL_SD_ReadBlocks+0x180>
      if(hsd->SdCard.CardType != CARD_SECURED)
 8002208:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800220a:	2b03      	cmp	r3, #3
 800220c:	d004      	beq.n	8002218 <HAL_SD_ReadBlocks+0x180>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800220e:	f001 fb2b 	bl	8003868 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8002212:	4603      	mov	r3, r0
 8002214:	2800      	cmp	r0, #0
 8002216:	d136      	bne.n	8002286 <HAL_SD_ReadBlocks+0x1ee>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002218:	682b      	ldr	r3, [r5, #0]
 800221a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800221c:	f012 0f08 	tst.w	r2, #8
 8002220:	d13d      	bne.n	800229e <HAL_SD_ReadBlocks+0x206>
    else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8002222:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002224:	f012 0f02 	tst.w	r2, #2
 8002228:	d145      	bne.n	80022b6 <HAL_SD_ReadBlocks+0x21e>
    else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 800222a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800222c:	f012 0f20 	tst.w	r2, #32
 8002230:	d14d      	bne.n	80022ce <HAL_SD_ReadBlocks+0x236>
    while ((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (dataremaining > 0U))
 8002232:	6828      	ldr	r0, [r5, #0]
 8002234:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002236:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 800223a:	d054      	beq.n	80022e6 <HAL_SD_ReadBlocks+0x24e>
 800223c:	2f00      	cmp	r7, #0
 800223e:	d052      	beq.n	80022e6 <HAL_SD_ReadBlocks+0x24e>
      data = SDIO_ReadFIFO(hsd->Instance);
 8002240:	f001 f95d 	bl	80034fe <SDIO_ReadFIFO>
      *tempbuff = (uint8_t)(data & 0xFFU);
 8002244:	7020      	strb	r0, [r4, #0]
      *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 8002246:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800224a:	7063      	strb	r3, [r4, #1]
      *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800224c:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8002250:	70a3      	strb	r3, [r4, #2]
      *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 8002252:	0e00      	lsrs	r0, r0, #24
 8002254:	70e0      	strb	r0, [r4, #3]
      tempbuff++;
 8002256:	3404      	adds	r4, #4
      dataremaining--;
 8002258:	3f04      	subs	r7, #4
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800225a:	f7fe f82f 	bl	80002bc <HAL_GetTick>
 800225e:	eba0 0008 	sub.w	r0, r0, r8
 8002262:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8002264:	4283      	cmp	r3, r0
 8002266:	d901      	bls.n	800226c <HAL_SD_ReadBlocks+0x1d4>
 8002268:	2b00      	cmp	r3, #0
 800226a:	d1e2      	bne.n	8002232 <HAL_SD_ReadBlocks+0x19a>
        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800226c:	682b      	ldr	r3, [r5, #0]
 800226e:	4a22      	ldr	r2, [pc, #136]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 8002270:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 8002272:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002274:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002278:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800227a:	2001      	movs	r0, #1
 800227c:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8002280:	2300      	movs	r3, #0
 8002282:	632b      	str	r3, [r5, #48]	; 0x30
        return HAL_ERROR;
 8002284:	e71d      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002286:	682a      	ldr	r2, [r5, #0]
 8002288:	491b      	ldr	r1, [pc, #108]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 800228a:	6391      	str	r1, [r2, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800228c:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800228e:	4313      	orrs	r3, r2
 8002290:	63ab      	str	r3, [r5, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 8002292:	2001      	movs	r0, #1
 8002294:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 8002298:	2300      	movs	r3, #0
 800229a:	632b      	str	r3, [r5, #48]	; 0x30
          return HAL_ERROR;
 800229c:	e711      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800229e:	4a16      	ldr	r2, [pc, #88]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 80022a0:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 80022a2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80022a4:	f043 0308 	orr.w	r3, r3, #8
 80022a8:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80022aa:	2001      	movs	r0, #1
 80022ac:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80022b0:	2300      	movs	r3, #0
 80022b2:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80022b4:	e705      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80022b6:	4a10      	ldr	r2, [pc, #64]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 80022b8:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 80022ba:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80022bc:	f043 0302 	orr.w	r3, r3, #2
 80022c0:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80022c2:	2001      	movs	r0, #1
 80022c4:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80022c8:	2300      	movs	r3, #0
 80022ca:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80022cc:	e6f9      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80022ce:	4a0a      	ldr	r2, [pc, #40]	; (80022f8 <HAL_SD_ReadBlocks+0x260>)
 80022d0:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 80022d2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80022d4:	f043 0320 	orr.w	r3, r3, #32
 80022d8:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80022da:	2001      	movs	r0, #1
 80022dc:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80022e0:	2300      	movs	r3, #0
 80022e2:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80022e4:	e6ed      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 80022e6:	f240 533a 	movw	r3, #1338	; 0x53a
 80022ea:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80022ec:	2301      	movs	r3, #1
 80022ee:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    return HAL_OK;
 80022f2:	2000      	movs	r0, #0
 80022f4:	e6e5      	b.n	80020c2 <HAL_SD_ReadBlocks+0x2a>
 80022f6:	bf00      	nop
 80022f8:	004005ff 	.word	0x004005ff

080022fc <HAL_SD_WriteBlocks>:
{
 80022fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002300:	b088      	sub	sp, #32
 8002302:	4605      	mov	r5, r0
 8002304:	460c      	mov	r4, r1
 8002306:	4616      	mov	r6, r2
 8002308:	4699      	mov	r9, r3
  uint32_t tickstart = HAL_GetTick();
 800230a:	f7fd ffd7 	bl	80002bc <HAL_GetTick>
  if(NULL == pData)
 800230e:	b16c      	cbz	r4, 800232c <HAL_SD_WriteBlocks+0x30>
 8002310:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
 8002312:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 8002316:	b2db      	uxtb	r3, r3
 8002318:	2b01      	cmp	r3, #1
 800231a:	d00d      	beq.n	8002338 <HAL_SD_WriteBlocks+0x3c>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800231c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800231e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002322:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 8002324:	2001      	movs	r0, #1
}
 8002326:	b008      	add	sp, #32
 8002328:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800232c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800232e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8002332:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 8002334:	2001      	movs	r0, #1
 8002336:	e7f6      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8002338:	2300      	movs	r3, #0
 800233a:	63ab      	str	r3, [r5, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800233c:	eb06 0309 	add.w	r3, r6, r9
 8002340:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8002342:	4293      	cmp	r3, r2
 8002344:	d81a      	bhi.n	800237c <HAL_SD_WriteBlocks+0x80>
    hsd->State = HAL_SD_STATE_BUSY;
 8002346:	2303      	movs	r3, #3
 8002348:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 800234c:	682b      	ldr	r3, [r5, #0]
 800234e:	2200      	movs	r2, #0
 8002350:	62da      	str	r2, [r3, #44]	; 0x2c
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8002352:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002354:	2b01      	cmp	r3, #1
 8002356:	d000      	beq.n	800235a <HAL_SD_WriteBlocks+0x5e>
      add *= 512U;
 8002358:	0276      	lsls	r6, r6, #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800235a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800235e:	6828      	ldr	r0, [r5, #0]
 8002360:	f001 fa0a 	bl	8003778 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002364:	4603      	mov	r3, r0
 8002366:	b178      	cbz	r0, 8002388 <HAL_SD_WriteBlocks+0x8c>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002368:	682a      	ldr	r2, [r5, #0]
 800236a:	4968      	ldr	r1, [pc, #416]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 800236c:	6391      	str	r1, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 800236e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8002370:	4313      	orrs	r3, r2
 8002372:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8002374:	2001      	movs	r0, #1
 8002376:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      return HAL_ERROR;
 800237a:	e7d4      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800237c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800237e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8002382:	63ab      	str	r3, [r5, #56]	; 0x38
      return HAL_ERROR;
 8002384:	2001      	movs	r0, #1
 8002386:	e7ce      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8002388:	f04f 33ff 	mov.w	r3, #4294967295
 800238c:	9302      	str	r3, [sp, #8]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800238e:	ea4f 2349 	mov.w	r3, r9, lsl #9
 8002392:	9303      	str	r3, [sp, #12]
    config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8002394:	2390      	movs	r3, #144	; 0x90
 8002396:	9304      	str	r3, [sp, #16]
    config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8002398:	2300      	movs	r3, #0
 800239a:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 800239c:	9306      	str	r3, [sp, #24]
    config.DPSM          = SDIO_DPSM_ENABLE;
 800239e:	2301      	movs	r3, #1
 80023a0:	9307      	str	r3, [sp, #28]
    (void)SDIO_ConfigData(hsd->Instance, &config);
 80023a2:	a902      	add	r1, sp, #8
 80023a4:	6828      	ldr	r0, [r5, #0]
 80023a6:	f001 f9d5 	bl	8003754 <SDIO_ConfigData>
    if(NumberOfBlocks > 1U)
 80023aa:	f1b9 0f01 	cmp.w	r9, #1
 80023ae:	d90b      	bls.n	80023c8 <HAL_SD_WriteBlocks+0xcc>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 80023b0:	2320      	movs	r3, #32
 80023b2:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 80023b4:	4631      	mov	r1, r6
 80023b6:	6828      	ldr	r0, [r5, #0]
 80023b8:	f001 fa3e 	bl	8003838 <SDMMC_CmdWriteMultiBlock>
 80023bc:	4682      	mov	sl, r0
    if(errorstate != HAL_SD_ERROR_NONE)
 80023be:	f1ba 0f00 	cmp.w	sl, #0
 80023c2:	d109      	bne.n	80023d8 <HAL_SD_WriteBlocks+0xdc>
    dataremaining = config.DataLength;
 80023c4:	9f03      	ldr	r7, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 80023c6:	e01c      	b.n	8002402 <HAL_SD_WriteBlocks+0x106>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 80023c8:	2310      	movs	r3, #16
 80023ca:	632b      	str	r3, [r5, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 80023cc:	4631      	mov	r1, r6
 80023ce:	6828      	ldr	r0, [r5, #0]
 80023d0:	f001 fa1a 	bl	8003808 <SDMMC_CmdWriteSingleBlock>
 80023d4:	4682      	mov	sl, r0
 80023d6:	e7f2      	b.n	80023be <HAL_SD_WriteBlocks+0xc2>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80023d8:	682b      	ldr	r3, [r5, #0]
 80023da:	4a4c      	ldr	r2, [pc, #304]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 80023dc:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 80023de:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80023e0:	ea4a 0303 	orr.w	r3, sl, r3
 80023e4:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80023e6:	2001      	movs	r0, #1
 80023e8:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80023ec:	2300      	movs	r3, #0
 80023ee:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80023f0:	e799      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 80023f2:	f7fd ff63 	bl	80002bc <HAL_GetTick>
 80023f6:	eba0 0008 	sub.w	r0, r0, r8
 80023fa:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80023fc:	4298      	cmp	r0, r3
 80023fe:	d223      	bcs.n	8002448 <HAL_SD_WriteBlocks+0x14c>
 8002400:	b313      	cbz	r3, 8002448 <HAL_SD_WriteBlocks+0x14c>
    while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 8002402:	6828      	ldr	r0, [r5, #0]
 8002404:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8002406:	f240 331a 	movw	r3, #794	; 0x31a
 800240a:	421a      	tst	r2, r3
 800240c:	d12a      	bne.n	8002464 <HAL_SD_WriteBlocks+0x168>
      if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE) && (dataremaining > 0U))
 800240e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002410:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8002414:	d0ed      	beq.n	80023f2 <HAL_SD_WriteBlocks+0xf6>
 8002416:	2f00      	cmp	r7, #0
 8002418:	d0eb      	beq.n	80023f2 <HAL_SD_WriteBlocks+0xf6>
 800241a:	4656      	mov	r6, sl
        for(count = 0U; count < 8U; count++)
 800241c:	2e07      	cmp	r6, #7
 800241e:	d8e8      	bhi.n	80023f2 <HAL_SD_WriteBlocks+0xf6>
          data = (uint32_t)(*tempbuff);
 8002420:	7823      	ldrb	r3, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 8U);
 8002422:	7862      	ldrb	r2, [r4, #1]
 8002424:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
          data |= ((uint32_t)(*tempbuff) << 16U);
 8002428:	78a2      	ldrb	r2, [r4, #2]
 800242a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
          data |= ((uint32_t)(*tempbuff) << 24U);
 800242e:	78e2      	ldrb	r2, [r4, #3]
 8002430:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8002434:	a908      	add	r1, sp, #32
 8002436:	f841 3d1c 	str.w	r3, [r1, #-28]!
          tempbuff++;
 800243a:	3404      	adds	r4, #4
          dataremaining--;
 800243c:	3f04      	subs	r7, #4
          (void)SDIO_WriteFIFO(hsd->Instance, &data);
 800243e:	6828      	ldr	r0, [r5, #0]
 8002440:	f001 f860 	bl	8003504 <SDIO_WriteFIFO>
        for(count = 0U; count < 8U; count++)
 8002444:	3601      	adds	r6, #1
 8002446:	e7e9      	b.n	800241c <HAL_SD_WriteBlocks+0x120>
        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002448:	682b      	ldr	r3, [r5, #0]
 800244a:	4a30      	ldr	r2, [pc, #192]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 800244c:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 800244e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002450:	ea4a 0303 	orr.w	r3, sl, r3
 8002454:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 8002456:	2301      	movs	r3, #1
 8002458:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800245c:	2300      	movs	r3, #0
 800245e:	632b      	str	r3, [r5, #48]	; 0x30
        return HAL_TIMEOUT;
 8002460:	2003      	movs	r0, #3
 8002462:	e760      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8002464:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002466:	f413 7f80 	tst.w	r3, #256	; 0x100
 800246a:	d009      	beq.n	8002480 <HAL_SD_WriteBlocks+0x184>
 800246c:	f1b9 0f01 	cmp.w	r9, #1
 8002470:	d906      	bls.n	8002480 <HAL_SD_WriteBlocks+0x184>
      if(hsd->SdCard.CardType != CARD_SECURED)
 8002472:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002474:	2b03      	cmp	r3, #3
 8002476:	d003      	beq.n	8002480 <HAL_SD_WriteBlocks+0x184>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8002478:	f001 f9f6 	bl	8003868 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800247c:	4603      	mov	r3, r0
 800247e:	b9c0      	cbnz	r0, 80024b2 <HAL_SD_WriteBlocks+0x1b6>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002480:	682b      	ldr	r3, [r5, #0]
 8002482:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002484:	f012 0f08 	tst.w	r2, #8
 8002488:	d11f      	bne.n	80024ca <HAL_SD_WriteBlocks+0x1ce>
    else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 800248a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800248c:	f012 0f02 	tst.w	r2, #2
 8002490:	d127      	bne.n	80024e2 <HAL_SD_WriteBlocks+0x1e6>
    else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
 8002492:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002494:	f012 0f10 	tst.w	r2, #16
 8002498:	d02f      	beq.n	80024fa <HAL_SD_WriteBlocks+0x1fe>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800249a:	4a1c      	ldr	r2, [pc, #112]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 800249c:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800249e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80024a0:	f043 0310 	orr.w	r3, r3, #16
 80024a4:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80024a6:	2001      	movs	r0, #1
 80024a8:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80024ac:	2300      	movs	r3, #0
 80024ae:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80024b0:	e739      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80024b2:	682a      	ldr	r2, [r5, #0]
 80024b4:	4915      	ldr	r1, [pc, #84]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 80024b6:	6391      	str	r1, [r2, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 80024b8:	6baa      	ldr	r2, [r5, #56]	; 0x38
 80024ba:	4313      	orrs	r3, r2
 80024bc:	63ab      	str	r3, [r5, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 80024be:	2001      	movs	r0, #1
 80024c0:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 80024c4:	2300      	movs	r3, #0
 80024c6:	632b      	str	r3, [r5, #48]	; 0x30
          return HAL_ERROR;
 80024c8:	e72d      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80024ca:	4a10      	ldr	r2, [pc, #64]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 80024cc:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 80024ce:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80024d0:	f043 0308 	orr.w	r3, r3, #8
 80024d4:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80024d6:	2001      	movs	r0, #1
 80024d8:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80024dc:	2300      	movs	r3, #0
 80024de:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80024e0:	e721      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80024e2:	4a0a      	ldr	r2, [pc, #40]	; (800250c <HAL_SD_WriteBlocks+0x210>)
 80024e4:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 80024e6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80024e8:	f043 0302 	orr.w	r3, r3, #2
 80024ec:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80024ee:	2001      	movs	r0, #1
 80024f0:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80024f4:	2300      	movs	r3, #0
 80024f6:	632b      	str	r3, [r5, #48]	; 0x30
      return HAL_ERROR;
 80024f8:	e715      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 80024fa:	f240 523a 	movw	r2, #1338	; 0x53a
 80024fe:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8002500:	2301      	movs	r3, #1
 8002502:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    return HAL_OK;
 8002506:	2000      	movs	r0, #0
 8002508:	e70d      	b.n	8002326 <HAL_SD_WriteBlocks+0x2a>
 800250a:	bf00      	nop
 800250c:	004005ff 	.word	0x004005ff

08002510 <HAL_SD_GetCardCSD>:
{
 8002510:	b410      	push	{r4}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8002512:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8002514:	0f9b      	lsrs	r3, r3, #30
 8002516:	700b      	strb	r3, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8002518:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800251a:	f3c3 6383 	ubfx	r3, r3, #26, #4
 800251e:	704b      	strb	r3, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8002520:	f890 3067 	ldrb.w	r3, [r0, #103]	; 0x67
 8002524:	f003 0303 	and.w	r3, r3, #3
 8002528:	708b      	strb	r3, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800252a:	f890 3066 	ldrb.w	r3, [r0, #102]	; 0x66
 800252e:	70cb      	strb	r3, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8002530:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
 8002534:	710b      	strb	r3, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8002536:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 800253a:	714b      	strb	r3, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800253c:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800253e:	0d1b      	lsrs	r3, r3, #20
 8002540:	80cb      	strh	r3, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 8002542:	f8b0 306a 	ldrh.w	r3, [r0, #106]	; 0x6a
 8002546:	f003 030f 	and.w	r3, r3, #15
 800254a:	720b      	strb	r3, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 800254c:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800254e:	f3c3 33c0 	ubfx	r3, r3, #15, #1
 8002552:	724b      	strb	r3, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8002554:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8002556:	f3c3 3380 	ubfx	r3, r3, #14, #1
 800255a:	728b      	strb	r3, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800255c:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800255e:	f3c3 3340 	ubfx	r3, r3, #13, #1
 8002562:	72cb      	strb	r3, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8002564:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8002566:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800256a:	730b      	strb	r3, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 800256c:	2300      	movs	r3, #0
 800256e:	734b      	strb	r3, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 8002570:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8002572:	2b00      	cmp	r3, #0
 8002574:	f040 8087 	bne.w	8002686 <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 8002578:	6e82      	ldr	r2, [r0, #104]	; 0x68
 800257a:	f640 73fc 	movw	r3, #4092	; 0xffc
 800257e:	ea03 0382 	and.w	r3, r3, r2, lsl #2
 8002582:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8002584:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
 8002588:	610b      	str	r3, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800258a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800258c:	f3c3 63c2 	ubfx	r3, r3, #27, #3
 8002590:	750b      	strb	r3, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 8002592:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
 8002596:	f003 0307 	and.w	r3, r3, #7
 800259a:	754b      	strb	r3, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 800259c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800259e:	f3c3 5342 	ubfx	r3, r3, #21, #3
 80025a2:	758b      	strb	r3, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80025a4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80025a6:	f3c3 4382 	ubfx	r3, r3, #18, #3
 80025aa:	75cb      	strb	r3, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80025ac:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80025ae:	f3c3 33c2 	ubfx	r3, r3, #15, #3
 80025b2:	760b      	strb	r3, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80025b4:	690b      	ldr	r3, [r1, #16]
 80025b6:	3301      	adds	r3, #1
 80025b8:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80025ba:	7e0a      	ldrb	r2, [r1, #24]
 80025bc:	f002 0207 	and.w	r2, r2, #7
 80025c0:	3202      	adds	r2, #2
 80025c2:	fa03 f202 	lsl.w	r2, r3, r2
 80025c6:	6542      	str	r2, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 80025c8:	7a0b      	ldrb	r3, [r1, #8]
 80025ca:	f003 040f 	and.w	r4, r3, #15
 80025ce:	2301      	movs	r3, #1
 80025d0:	40a3      	lsls	r3, r4
 80025d2:	6583      	str	r3, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 80025d4:	0a5b      	lsrs	r3, r3, #9
 80025d6:	fb03 f302 	mul.w	r3, r3, r2
 80025da:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = 512U;
 80025dc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80025e0:	6603      	str	r3, [r0, #96]	; 0x60
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 80025e2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80025e4:	f3c3 3380 	ubfx	r3, r3, #14, #1
 80025e8:	764b      	strb	r3, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 80025ea:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80025ec:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 80025f0:	768b      	strb	r3, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 80025f2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80025f4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80025f8:	76cb      	strb	r3, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 80025fa:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80025fc:	0fdb      	lsrs	r3, r3, #31
 80025fe:	770b      	strb	r3, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8002600:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8002602:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8002606:	774b      	strb	r3, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 8002608:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800260a:	f3c3 6382 	ubfx	r3, r3, #26, #3
 800260e:	778b      	strb	r3, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8002610:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8002612:	f3c3 5383 	ubfx	r3, r3, #22, #4
 8002616:	77cb      	strb	r3, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8002618:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800261a:	f3c3 5340 	ubfx	r3, r3, #21, #1
 800261e:	f881 3020 	strb.w	r3, [r1, #32]
  pCSD->Reserved3 = 0;
 8002622:	2300      	movs	r3, #0
 8002624:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8002628:	f8b0 2072 	ldrh.w	r2, [r0, #114]	; 0x72
 800262c:	f002 0201 	and.w	r2, r2, #1
 8002630:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 8002634:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8002636:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800263a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 800263e:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8002640:	f3c2 3280 	ubfx	r2, r2, #14, #1
 8002644:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8002648:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800264a:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800264e:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8002652:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8002654:	f3c2 3200 	ubfx	r2, r2, #12, #1
 8002658:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800265c:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800265e:	f3c2 2281 	ubfx	r2, r2, #10, #2
 8002662:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8002666:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8002668:	f3c2 2201 	ubfx	r2, r2, #8, #2
 800266c:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8002670:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8002672:	f3c2 0246 	ubfx	r2, r2, #1, #7
 8002676:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 800267a:	2201      	movs	r2, #1
 800267c:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
  return HAL_OK;
 8002680:	4618      	mov	r0, r3
}
 8002682:	bc10      	pop	{r4}
 8002684:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8002686:	2b01      	cmp	r3, #1
 8002688:	d00b      	beq.n	80026a2 <HAL_SD_GetCardCSD+0x192>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800268a:	6803      	ldr	r3, [r0, #0]
 800268c:	4a0e      	ldr	r2, [pc, #56]	; (80026c8 <HAL_SD_GetCardCSD+0x1b8>)
 800268e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8002690:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002692:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002696:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8002698:	2301      	movs	r3, #1
 800269a:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
 800269e:	4618      	mov	r0, r3
 80026a0:	e7ef      	b.n	8002682 <HAL_SD_GetCardCSD+0x172>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 80026a2:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80026a4:	041b      	lsls	r3, r3, #16
 80026a6:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 80026aa:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
 80026ae:	4313      	orrs	r3, r2
 80026b0:	610b      	str	r3, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 80026b2:	690b      	ldr	r3, [r1, #16]
 80026b4:	3301      	adds	r3, #1
 80026b6:	029b      	lsls	r3, r3, #10
 80026b8:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 80026ba:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.BlockSize = 512U;
 80026bc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80026c0:	6583      	str	r3, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 80026c2:	6603      	str	r3, [r0, #96]	; 0x60
 80026c4:	e78d      	b.n	80025e2 <HAL_SD_GetCardCSD+0xd2>
 80026c6:	bf00      	nop
 80026c8:	004005ff 	.word	0x004005ff

080026cc <SD_InitCard>:
{
 80026cc:	b570      	push	{r4, r5, r6, lr}
 80026ce:	b090      	sub	sp, #64	; 0x40
 80026d0:	4604      	mov	r4, r0
  uint16_t sd_rca = 1U;
 80026d2:	2301      	movs	r3, #1
 80026d4:	f8ad 3012 	strh.w	r3, [sp, #18]
  if(SDIO_GetPowerState(hsd->Instance) == 0U)
 80026d8:	6800      	ldr	r0, [r0, #0]
 80026da:	f000 ff20 	bl	800351e <SDIO_GetPowerState>
 80026de:	b920      	cbnz	r0, 80026ea <SD_InitCard+0x1e>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80026e0:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
}
 80026e4:	4628      	mov	r0, r5
 80026e6:	b010      	add	sp, #64	; 0x40
 80026e8:	bd70      	pop	{r4, r5, r6, pc}
  if(hsd->SdCard.CardType != CARD_SECURED)
 80026ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80026ec:	2b03      	cmp	r3, #3
 80026ee:	d01a      	beq.n	8002726 <SD_InitCard+0x5a>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 80026f0:	6820      	ldr	r0, [r4, #0]
 80026f2:	f001 f976 	bl	80039e2 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 80026f6:	4605      	mov	r5, r0
 80026f8:	2800      	cmp	r0, #0
 80026fa:	d1f3      	bne.n	80026e4 <SD_InitCard+0x18>
      hsd->CID[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 80026fc:	2100      	movs	r1, #0
 80026fe:	6820      	ldr	r0, [r4, #0]
 8002700:	f000 ff26 	bl	8003550 <SDIO_GetResponse>
 8002704:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8002706:	2104      	movs	r1, #4
 8002708:	6820      	ldr	r0, [r4, #0]
 800270a:	f000 ff21 	bl	8003550 <SDIO_GetResponse>
 800270e:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 8002710:	2108      	movs	r1, #8
 8002712:	6820      	ldr	r0, [r4, #0]
 8002714:	f000 ff1c 	bl	8003550 <SDIO_GetResponse>
 8002718:	67e0      	str	r0, [r4, #124]	; 0x7c
      hsd->CID[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 800271a:	210c      	movs	r1, #12
 800271c:	6820      	ldr	r0, [r4, #0]
 800271e:	f000 ff17 	bl	8003550 <SDIO_GetResponse>
 8002722:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED)
 8002726:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002728:	2b03      	cmp	r3, #3
 800272a:	d007      	beq.n	800273c <SD_InitCard+0x70>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800272c:	f10d 0112 	add.w	r1, sp, #18
 8002730:	6820      	ldr	r0, [r4, #0]
 8002732:	f001 f980 	bl	8003a36 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002736:	4605      	mov	r5, r0
 8002738:	2800      	cmp	r0, #0
 800273a:	d1d3      	bne.n	80026e4 <SD_InitCard+0x18>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800273c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800273e:	2b03      	cmp	r3, #3
 8002740:	d01d      	beq.n	800277e <SD_InitCard+0xb2>
    hsd->SdCard.RelCardAdd = sd_rca;
 8002742:	f8bd 1012 	ldrh.w	r1, [sp, #18]
 8002746:	6521      	str	r1, [r4, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8002748:	0409      	lsls	r1, r1, #16
 800274a:	6820      	ldr	r0, [r4, #0]
 800274c:	f001 f95e 	bl	8003a0c <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 8002750:	4605      	mov	r5, r0
 8002752:	2800      	cmp	r0, #0
 8002754:	d1c6      	bne.n	80026e4 <SD_InitCard+0x18>
      hsd->CSD[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8002756:	2100      	movs	r1, #0
 8002758:	6820      	ldr	r0, [r4, #0]
 800275a:	f000 fef9 	bl	8003550 <SDIO_GetResponse>
 800275e:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8002760:	2104      	movs	r1, #4
 8002762:	6820      	ldr	r0, [r4, #0]
 8002764:	f000 fef4 	bl	8003550 <SDIO_GetResponse>
 8002768:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 800276a:	2108      	movs	r1, #8
 800276c:	6820      	ldr	r0, [r4, #0]
 800276e:	f000 feef 	bl	8003550 <SDIO_GetResponse>
 8002772:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CSD[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 8002774:	210c      	movs	r1, #12
 8002776:	6820      	ldr	r0, [r4, #0]
 8002778:	f000 feea 	bl	8003550 <SDIO_GetResponse>
 800277c:	6720      	str	r0, [r4, #112]	; 0x70
  hsd->SdCard.Class = (SDIO_GetResponse(hsd->Instance, SDIO_RESP2) >> 20U);
 800277e:	2104      	movs	r1, #4
 8002780:	6820      	ldr	r0, [r4, #0]
 8002782:	f000 fee5 	bl	8003550 <SDIO_GetResponse>
 8002786:	0d00      	lsrs	r0, r0, #20
 8002788:	64e0      	str	r0, [r4, #76]	; 0x4c
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800278a:	a905      	add	r1, sp, #20
 800278c:	4620      	mov	r0, r4
 800278e:	f7ff febf 	bl	8002510 <HAL_SD_GetCardCSD>
 8002792:	b110      	cbz	r0, 800279a <SD_InitCard+0xce>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8002794:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8002798:	e7a4      	b.n	80026e4 <SD_InitCard+0x18>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 800279a:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800279c:	0412      	lsls	r2, r2, #16
 800279e:	2300      	movs	r3, #0
 80027a0:	6820      	ldr	r0, [r4, #0]
 80027a2:	f001 f87b 	bl	800389c <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 80027a6:	4605      	mov	r5, r0
 80027a8:	2800      	cmp	r0, #0
 80027aa:	d19b      	bne.n	80026e4 <SD_InitCard+0x18>
  (void)SDIO_Init(hsd->Instance, hsd->Init);
 80027ac:	4623      	mov	r3, r4
 80027ae:	f853 6b10 	ldr.w	r6, [r3], #16
 80027b2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80027b6:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80027ba:	3404      	adds	r4, #4
 80027bc:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
 80027c0:	4630      	mov	r0, r6
 80027c2:	f000 fe81 	bl	80034c8 <SDIO_Init>
  return HAL_SD_ERROR_NONE;
 80027c6:	e78d      	b.n	80026e4 <SD_InitCard+0x18>

080027c8 <HAL_SD_InitCard>:
{
 80027c8:	b570      	push	{r4, r5, r6, lr}
 80027ca:	b08a      	sub	sp, #40	; 0x28
 80027cc:	4605      	mov	r5, r0
  Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 80027ce:	2300      	movs	r3, #0
 80027d0:	9304      	str	r3, [sp, #16]
  Init.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 80027d2:	9305      	str	r3, [sp, #20]
  Init.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 80027d4:	9306      	str	r3, [sp, #24]
  Init.BusWide             = SDIO_BUS_WIDE_1B;
 80027d6:	9307      	str	r3, [sp, #28]
  Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 80027d8:	9308      	str	r3, [sp, #32]
  Init.ClockDiv            = SDIO_INIT_CLK_DIV;
 80027da:	2376      	movs	r3, #118	; 0x76
 80027dc:	9309      	str	r3, [sp, #36]	; 0x24
  status = SDIO_Init(hsd->Instance, Init);
 80027de:	ab0a      	add	r3, sp, #40	; 0x28
 80027e0:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80027e4:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80027e8:	ab04      	add	r3, sp, #16
 80027ea:	cb0e      	ldmia	r3, {r1, r2, r3}
 80027ec:	6828      	ldr	r0, [r5, #0]
 80027ee:	f000 fe6b 	bl	80034c8 <SDIO_Init>
  if(status != HAL_OK)
 80027f2:	b118      	cbz	r0, 80027fc <HAL_SD_InitCard+0x34>
    return HAL_ERROR;
 80027f4:	2401      	movs	r4, #1
}
 80027f6:	4620      	mov	r0, r4
 80027f8:	b00a      	add	sp, #40	; 0x28
 80027fa:	bd70      	pop	{r4, r5, r6, pc}
 80027fc:	4604      	mov	r4, r0
  __HAL_SD_DISABLE(hsd);
 80027fe:	4e10      	ldr	r6, [pc, #64]	; (8002840 <HAL_SD_InitCard+0x78>)
 8002800:	2300      	movs	r3, #0
 8002802:	6033      	str	r3, [r6, #0]
  (void)SDIO_PowerState_ON(hsd->Instance);
 8002804:	6828      	ldr	r0, [r5, #0]
 8002806:	f000 fe82 	bl	800350e <SDIO_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
 800280a:	2301      	movs	r3, #1
 800280c:	6033      	str	r3, [r6, #0]
  errorstate = SD_PowerON(hsd);
 800280e:	4628      	mov	r0, r5
 8002810:	f7ff faf0 	bl	8001df4 <SD_PowerON>
  if(errorstate != HAL_SD_ERROR_NONE)
 8002814:	4603      	mov	r3, r0
 8002816:	b130      	cbz	r0, 8002826 <HAL_SD_InitCard+0x5e>
    hsd->State = HAL_SD_STATE_READY;
 8002818:	2401      	movs	r4, #1
 800281a:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800281e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8002820:	4313      	orrs	r3, r2
 8002822:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 8002824:	e7e7      	b.n	80027f6 <HAL_SD_InitCard+0x2e>
  errorstate = SD_InitCard(hsd);
 8002826:	4628      	mov	r0, r5
 8002828:	f7ff ff50 	bl	80026cc <SD_InitCard>
  if(errorstate != HAL_SD_ERROR_NONE)
 800282c:	4603      	mov	r3, r0
 800282e:	2800      	cmp	r0, #0
 8002830:	d0e1      	beq.n	80027f6 <HAL_SD_InitCard+0x2e>
    hsd->State = HAL_SD_STATE_READY;
 8002832:	2401      	movs	r4, #1
 8002834:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8002838:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800283a:	4313      	orrs	r3, r2
 800283c:	63ab      	str	r3, [r5, #56]	; 0x38
    return HAL_ERROR;
 800283e:	e7da      	b.n	80027f6 <HAL_SD_InitCard+0x2e>
 8002840:	423000a0 	.word	0x423000a0

08002844 <HAL_SD_Init>:
  if(hsd == NULL)
 8002844:	b1c0      	cbz	r0, 8002878 <HAL_SD_Init+0x34>
{
 8002846:	b510      	push	{r4, lr}
 8002848:	4604      	mov	r4, r0
  if(hsd->State == HAL_SD_STATE_RESET)
 800284a:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800284e:	b17b      	cbz	r3, 8002870 <HAL_SD_Init+0x2c>
  hsd->State = HAL_SD_STATE_BUSY;
 8002850:	2303      	movs	r3, #3
 8002852:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 8002856:	4620      	mov	r0, r4
 8002858:	f7ff ffb6 	bl	80027c8 <HAL_SD_InitCard>
 800285c:	4603      	mov	r3, r0
 800285e:	b970      	cbnz	r0, 800287e <HAL_SD_Init+0x3a>
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8002860:	2200      	movs	r2, #0
 8002862:	63a2      	str	r2, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 8002864:	6322      	str	r2, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 8002866:	2201      	movs	r2, #1
 8002868:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
}
 800286c:	4618      	mov	r0, r3
 800286e:	bd10      	pop	{r4, pc}
    hsd->Lock = HAL_UNLOCKED;
 8002870:	7703      	strb	r3, [r0, #28]
    HAL_SD_MspInit(hsd);
 8002872:	f005 ff55 	bl	8008720 <HAL_SD_MspInit>
 8002876:	e7eb      	b.n	8002850 <HAL_SD_Init+0xc>
    return HAL_ERROR;
 8002878:	2301      	movs	r3, #1
}
 800287a:	4618      	mov	r0, r3
 800287c:	4770      	bx	lr
    return HAL_ERROR;
 800287e:	2301      	movs	r3, #1
 8002880:	e7f4      	b.n	800286c <HAL_SD_Init+0x28>

08002882 <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8002882:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8002884:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 8002886:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8002888:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800288a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800288c:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 800288e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8002890:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 8002892:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8002894:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 8002896:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8002898:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800289a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800289c:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 800289e:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80028a0:	61cb      	str	r3, [r1, #28]
}
 80028a2:	2000      	movs	r0, #0
 80028a4:	4770      	bx	lr
	...

080028a8 <HAL_SD_ConfigWideBusOperation>:
{
 80028a8:	b530      	push	{r4, r5, lr}
 80028aa:	b08b      	sub	sp, #44	; 0x2c
 80028ac:	4604      	mov	r4, r0
 80028ae:	460d      	mov	r5, r1
  hsd->State = HAL_SD_STATE_BUSY;
 80028b0:	2303      	movs	r3, #3
 80028b2:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
 80028b6:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80028b8:	2b03      	cmp	r3, #3
 80028ba:	d025      	beq.n	8002908 <HAL_SD_ConfigWideBusOperation+0x60>
    if(WideMode == SDIO_BUS_WIDE_8B)
 80028bc:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80028c0:	d011      	beq.n	80028e6 <HAL_SD_ConfigWideBusOperation+0x3e>
    else if(WideMode == SDIO_BUS_WIDE_4B)
 80028c2:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 80028c6:	d013      	beq.n	80028f0 <HAL_SD_ConfigWideBusOperation+0x48>
    else if(WideMode == SDIO_BUS_WIDE_1B)
 80028c8:	b1c1      	cbz	r1, 80028fc <HAL_SD_ConfigWideBusOperation+0x54>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80028ca:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80028cc:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80028d0:	6383      	str	r3, [r0, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80028d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80028d4:	b1eb      	cbz	r3, 8002912 <HAL_SD_ConfigWideBusOperation+0x6a>
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80028d6:	6823      	ldr	r3, [r4, #0]
 80028d8:	4a1b      	ldr	r2, [pc, #108]	; (8002948 <HAL_SD_ConfigWideBusOperation+0xa0>)
 80028da:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80028dc:	2001      	movs	r0, #1
 80028de:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
}
 80028e2:	b00b      	add	sp, #44	; 0x2c
 80028e4:	bd30      	pop	{r4, r5, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80028e6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80028e8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80028ec:	6383      	str	r3, [r0, #56]	; 0x38
 80028ee:	e7f0      	b.n	80028d2 <HAL_SD_ConfigWideBusOperation+0x2a>
      errorstate = SD_WideBus_Enable(hsd);
 80028f0:	f7ff fb63 	bl	8001fba <SD_WideBus_Enable>
      hsd->ErrorCode |= errorstate;
 80028f4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80028f6:	4318      	orrs	r0, r3
 80028f8:	63a0      	str	r0, [r4, #56]	; 0x38
 80028fa:	e7ea      	b.n	80028d2 <HAL_SD_ConfigWideBusOperation+0x2a>
      errorstate = SD_WideBus_Disable(hsd);
 80028fc:	f7ff fb8a 	bl	8002014 <SD_WideBus_Disable>
      hsd->ErrorCode |= errorstate;
 8002900:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002902:	4318      	orrs	r0, r3
 8002904:	63a0      	str	r0, [r4, #56]	; 0x38
 8002906:	e7e4      	b.n	80028d2 <HAL_SD_ConfigWideBusOperation+0x2a>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8002908:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800290a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800290e:	6383      	str	r3, [r0, #56]	; 0x38
 8002910:	e7df      	b.n	80028d2 <HAL_SD_ConfigWideBusOperation+0x2a>
    Init.ClockEdge           = hsd->Init.ClockEdge;
 8002912:	6863      	ldr	r3, [r4, #4]
 8002914:	9304      	str	r3, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 8002916:	68a3      	ldr	r3, [r4, #8]
 8002918:	9305      	str	r3, [sp, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800291a:	68e3      	ldr	r3, [r4, #12]
 800291c:	9306      	str	r3, [sp, #24]
    Init.BusWide             = WideMode;
 800291e:	9507      	str	r5, [sp, #28]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8002920:	6963      	ldr	r3, [r4, #20]
 8002922:	9308      	str	r3, [sp, #32]
    Init.ClockDiv            = hsd->Init.ClockDiv;
 8002924:	69a3      	ldr	r3, [r4, #24]
 8002926:	9309      	str	r3, [sp, #36]	; 0x24
    (void)SDIO_Init(hsd->Instance, Init);
 8002928:	ab0a      	add	r3, sp, #40	; 0x28
 800292a:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 800292e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8002932:	ab04      	add	r3, sp, #16
 8002934:	cb0e      	ldmia	r3, {r1, r2, r3}
 8002936:	6820      	ldr	r0, [r4, #0]
 8002938:	f000 fdc6 	bl	80034c8 <SDIO_Init>
  hsd->State = HAL_SD_STATE_READY;
 800293c:	2301      	movs	r3, #1
 800293e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 8002942:	2000      	movs	r0, #0
 8002944:	e7cd      	b.n	80028e2 <HAL_SD_ConfigWideBusOperation+0x3a>
 8002946:	bf00      	nop
 8002948:	004005ff 	.word	0x004005ff

0800294c <HAL_SD_GetCardState>:
{
 800294c:	b510      	push	{r4, lr}
 800294e:	b082      	sub	sp, #8
 8002950:	4604      	mov	r4, r0
  uint32_t resp1 = 0;
 8002952:	a902      	add	r1, sp, #8
 8002954:	2300      	movs	r3, #0
 8002956:	f841 3d04 	str.w	r3, [r1, #-4]!
  errorstate = SD_SendStatus(hsd, &resp1);
 800295a:	f7ff fb88 	bl	800206e <SD_SendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800295e:	b118      	cbz	r0, 8002968 <HAL_SD_GetCardState+0x1c>
 8002960:	4603      	mov	r3, r0
    hsd->ErrorCode |= errorstate;
 8002962:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002964:	4313      	orrs	r3, r2
 8002966:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8002968:	9801      	ldr	r0, [sp, #4]
 800296a:	f3c0 2043 	ubfx	r0, r0, #9, #4
 800296e:	b002      	add	sp, #8
 8002970:	bd10      	pop	{r4, pc}

08002972 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8002972:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002974:	4605      	mov	r5, r0
 8002976:	460f      	mov	r7, r1
 8002978:	4616      	mov	r6, r2
 800297a:	461c      	mov	r4, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800297c:	682b      	ldr	r3, [r5, #0]
 800297e:	689b      	ldr	r3, [r3, #8]
 8002980:	ea37 0303 	bics.w	r3, r7, r3
 8002984:	bf0c      	ite	eq
 8002986:	2301      	moveq	r3, #1
 8002988:	2300      	movne	r3, #0
 800298a:	42b3      	cmp	r3, r6
 800298c:	d037      	beq.n	80029fe <SPI_WaitFlagStateUntilTimeout+0x8c>
  {
    if (Timeout != HAL_MAX_DELAY)
 800298e:	f1b4 3fff 	cmp.w	r4, #4294967295
 8002992:	d0f3      	beq.n	800297c <SPI_WaitFlagStateUntilTimeout+0xa>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002994:	f7fd fc92 	bl	80002bc <HAL_GetTick>
 8002998:	9b06      	ldr	r3, [sp, #24]
 800299a:	1ac0      	subs	r0, r0, r3
 800299c:	4284      	cmp	r4, r0
 800299e:	d901      	bls.n	80029a4 <SPI_WaitFlagStateUntilTimeout+0x32>
 80029a0:	2c00      	cmp	r4, #0
 80029a2:	d1eb      	bne.n	800297c <SPI_WaitFlagStateUntilTimeout+0xa>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80029a4:	682a      	ldr	r2, [r5, #0]
 80029a6:	6853      	ldr	r3, [r2, #4]
 80029a8:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80029ac:	6053      	str	r3, [r2, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80029ae:	686b      	ldr	r3, [r5, #4]
 80029b0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80029b4:	d00b      	beq.n	80029ce <SPI_WaitFlagStateUntilTimeout+0x5c>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80029b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80029b8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80029bc:	d014      	beq.n	80029e8 <SPI_WaitFlagStateUntilTimeout+0x76>
        {
          SPI_RESET_CRC(hspi);
        }

        hspi->State = HAL_SPI_STATE_READY;
 80029be:	2301      	movs	r3, #1
 80029c0:	f885 3051 	strb.w	r3, [r5, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80029c4:	2300      	movs	r3, #0
 80029c6:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50

        return HAL_TIMEOUT;
 80029ca:	2003      	movs	r0, #3
 80029cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80029ce:	68ab      	ldr	r3, [r5, #8]
 80029d0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80029d4:	d002      	beq.n	80029dc <SPI_WaitFlagStateUntilTimeout+0x6a>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80029d6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80029da:	d1ec      	bne.n	80029b6 <SPI_WaitFlagStateUntilTimeout+0x44>
          __HAL_SPI_DISABLE(hspi);
 80029dc:	682a      	ldr	r2, [r5, #0]
 80029de:	6813      	ldr	r3, [r2, #0]
 80029e0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80029e4:	6013      	str	r3, [r2, #0]
 80029e6:	e7e6      	b.n	80029b6 <SPI_WaitFlagStateUntilTimeout+0x44>
          SPI_RESET_CRC(hspi);
 80029e8:	682a      	ldr	r2, [r5, #0]
 80029ea:	6813      	ldr	r3, [r2, #0]
 80029ec:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80029f0:	6013      	str	r3, [r2, #0]
 80029f2:	682a      	ldr	r2, [r5, #0]
 80029f4:	6813      	ldr	r3, [r2, #0]
 80029f6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80029fa:	6013      	str	r3, [r2, #0]
 80029fc:	e7df      	b.n	80029be <SPI_WaitFlagStateUntilTimeout+0x4c>
      }
    }
  }

  return HAL_OK;
 80029fe:	2000      	movs	r0, #0
}
 8002a00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002a02 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002a02:	b510      	push	{r4, lr}
 8002a04:	b082      	sub	sp, #8
 8002a06:	4604      	mov	r4, r0
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002a08:	9200      	str	r2, [sp, #0]
 8002a0a:	460b      	mov	r3, r1
 8002a0c:	2200      	movs	r2, #0
 8002a0e:	2180      	movs	r1, #128	; 0x80
 8002a10:	f7ff ffaf 	bl	8002972 <SPI_WaitFlagStateUntilTimeout>
 8002a14:	4603      	mov	r3, r0
 8002a16:	b120      	cbz	r0, 8002a22 <SPI_EndRxTxTransaction+0x20>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002a18:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002a1a:	f043 0320 	orr.w	r3, r3, #32
 8002a1e:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_TIMEOUT;
 8002a20:	2303      	movs	r3, #3
  }
  return HAL_OK;
}
 8002a22:	4618      	mov	r0, r3
 8002a24:	b002      	add	sp, #8
 8002a26:	bd10      	pop	{r4, pc}

08002a28 <SPI_EndRxTransaction>:
{
 8002a28:	b510      	push	{r4, lr}
 8002a2a:	b082      	sub	sp, #8
 8002a2c:	4604      	mov	r4, r0
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a2e:	6840      	ldr	r0, [r0, #4]
 8002a30:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 8002a34:	d014      	beq.n	8002a60 <SPI_EndRxTransaction+0x38>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY))
 8002a36:	6860      	ldr	r0, [r4, #4]
 8002a38:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 8002a3c:	d01d      	beq.n	8002a7a <SPI_EndRxTransaction+0x52>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002a3e:	9200      	str	r2, [sp, #0]
 8002a40:	460b      	mov	r3, r1
 8002a42:	2200      	movs	r2, #0
 8002a44:	2180      	movs	r1, #128	; 0x80
 8002a46:	4620      	mov	r0, r4
 8002a48:	f7ff ff93 	bl	8002972 <SPI_WaitFlagStateUntilTimeout>
 8002a4c:	4603      	mov	r3, r0
 8002a4e:	b120      	cbz	r0, 8002a5a <SPI_EndRxTransaction+0x32>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002a50:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002a52:	f043 0320 	orr.w	r3, r3, #32
 8002a56:	6563      	str	r3, [r4, #84]	; 0x54
      return HAL_TIMEOUT;
 8002a58:	2303      	movs	r3, #3
}
 8002a5a:	4618      	mov	r0, r3
 8002a5c:	b002      	add	sp, #8
 8002a5e:	bd10      	pop	{r4, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a60:	68a3      	ldr	r3, [r4, #8]
 8002a62:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002a66:	d002      	beq.n	8002a6e <SPI_EndRxTransaction+0x46>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002a68:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002a6c:	d1e3      	bne.n	8002a36 <SPI_EndRxTransaction+0xe>
    __HAL_SPI_DISABLE(hspi);
 8002a6e:	6820      	ldr	r0, [r4, #0]
 8002a70:	6803      	ldr	r3, [r0, #0]
 8002a72:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002a76:	6003      	str	r3, [r0, #0]
 8002a78:	e7dd      	b.n	8002a36 <SPI_EndRxTransaction+0xe>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY))
 8002a7a:	68a3      	ldr	r3, [r4, #8]
 8002a7c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002a80:	d1dd      	bne.n	8002a3e <SPI_EndRxTransaction+0x16>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 8002a82:	9200      	str	r2, [sp, #0]
 8002a84:	460b      	mov	r3, r1
 8002a86:	2200      	movs	r2, #0
 8002a88:	2101      	movs	r1, #1
 8002a8a:	4620      	mov	r0, r4
 8002a8c:	f7ff ff71 	bl	8002972 <SPI_WaitFlagStateUntilTimeout>
 8002a90:	4603      	mov	r3, r0
 8002a92:	2800      	cmp	r0, #0
 8002a94:	d0e1      	beq.n	8002a5a <SPI_EndRxTransaction+0x32>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002a96:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002a98:	f043 0320 	orr.w	r3, r3, #32
 8002a9c:	6563      	str	r3, [r4, #84]	; 0x54
      return HAL_TIMEOUT;
 8002a9e:	2303      	movs	r3, #3
 8002aa0:	e7db      	b.n	8002a5a <SPI_EndRxTransaction+0x32>

08002aa2 <HAL_SPI_Init>:
  if (hspi == NULL)
 8002aa2:	2800      	cmp	r0, #0
 8002aa4:	d039      	beq.n	8002b1a <HAL_SPI_Init+0x78>
{
 8002aa6:	b510      	push	{r4, lr}
 8002aa8:	4604      	mov	r4, r0
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002aaa:	2300      	movs	r3, #0
 8002aac:	6283      	str	r3, [r0, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002aae:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d02c      	beq.n	8002b10 <HAL_SPI_Init+0x6e>
  hspi->State = HAL_SPI_STATE_BUSY;
 8002ab6:	2302      	movs	r3, #2
 8002ab8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 8002abc:	6822      	ldr	r2, [r4, #0]
 8002abe:	6813      	ldr	r3, [r2, #0]
 8002ac0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002ac4:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8002ac6:	6822      	ldr	r2, [r4, #0]
 8002ac8:	6863      	ldr	r3, [r4, #4]
 8002aca:	68a1      	ldr	r1, [r4, #8]
 8002acc:	430b      	orrs	r3, r1
 8002ace:	68e1      	ldr	r1, [r4, #12]
 8002ad0:	430b      	orrs	r3, r1
 8002ad2:	6921      	ldr	r1, [r4, #16]
 8002ad4:	430b      	orrs	r3, r1
 8002ad6:	6961      	ldr	r1, [r4, #20]
 8002ad8:	430b      	orrs	r3, r1
 8002ada:	69a1      	ldr	r1, [r4, #24]
 8002adc:	f401 7100 	and.w	r1, r1, #512	; 0x200
 8002ae0:	430b      	orrs	r3, r1
 8002ae2:	69e1      	ldr	r1, [r4, #28]
 8002ae4:	430b      	orrs	r3, r1
 8002ae6:	6a21      	ldr	r1, [r4, #32]
 8002ae8:	430b      	orrs	r3, r1
 8002aea:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8002aec:	430b      	orrs	r3, r1
 8002aee:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
 8002af0:	6822      	ldr	r2, [r4, #0]
 8002af2:	8b63      	ldrh	r3, [r4, #26]
 8002af4:	f003 0304 	and.w	r3, r3, #4
 8002af8:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002afa:	6822      	ldr	r2, [r4, #0]
 8002afc:	69d3      	ldr	r3, [r2, #28]
 8002afe:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8002b02:	61d3      	str	r3, [r2, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002b04:	2000      	movs	r0, #0
 8002b06:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8002b08:	2301      	movs	r3, #1
 8002b0a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  return HAL_OK;
 8002b0e:	bd10      	pop	{r4, pc}
    hspi->Lock = HAL_UNLOCKED;
 8002b10:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
    HAL_SPI_MspInit(hspi);
 8002b14:	f005 fe48 	bl	80087a8 <HAL_SPI_MspInit>
 8002b18:	e7cd      	b.n	8002ab6 <HAL_SPI_Init+0x14>
    return HAL_ERROR;
 8002b1a:	2001      	movs	r0, #1
 8002b1c:	4770      	bx	lr

08002b1e <HAL_SPI_Transmit>:
{
 8002b1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002b22:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8002b24:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
 8002b28:	2c01      	cmp	r4, #1
 8002b2a:	d103      	bne.n	8002b34 <HAL_SPI_Transmit+0x16>
 8002b2c:	2002      	movs	r0, #2
}
 8002b2e:	b002      	add	sp, #8
 8002b30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002b34:	461d      	mov	r5, r3
 8002b36:	4617      	mov	r7, r2
 8002b38:	4688      	mov	r8, r1
 8002b3a:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8002b3c:	2301      	movs	r3, #1
 8002b3e:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  tickstart = HAL_GetTick();
 8002b42:	f7fd fbbb 	bl	80002bc <HAL_GetTick>
 8002b46:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002b48:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8002b4c:	b2db      	uxtb	r3, r3
 8002b4e:	2b01      	cmp	r3, #1
 8002b50:	d007      	beq.n	8002b62 <HAL_SPI_Transmit+0x44>
    errorcode = HAL_BUSY;
 8002b52:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002b54:	2301      	movs	r3, #1
 8002b56:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8002b5a:	2300      	movs	r3, #0
 8002b5c:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 8002b60:	e7e5      	b.n	8002b2e <HAL_SPI_Transmit+0x10>
  if ((pData == NULL) || (Size == 0U))
 8002b62:	f1b8 0f00 	cmp.w	r8, #0
 8002b66:	f000 809c 	beq.w	8002ca2 <HAL_SPI_Transmit+0x184>
 8002b6a:	2f00      	cmp	r7, #0
 8002b6c:	f000 809b 	beq.w	8002ca6 <HAL_SPI_Transmit+0x188>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002b70:	2303      	movs	r3, #3
 8002b72:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002b76:	2300      	movs	r3, #0
 8002b78:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002b7a:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
  hspi->TxXferSize  = Size;
 8002b7e:	86a7      	strh	r7, [r4, #52]	; 0x34
  hspi->TxXferCount = Size;
 8002b80:	86e7      	strh	r7, [r4, #54]	; 0x36
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002b82:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->RxXferSize  = 0U;
 8002b84:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8002b86:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 8002b88:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 8002b8a:	6423      	str	r3, [r4, #64]	; 0x40
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002b8c:	68a3      	ldr	r3, [r4, #8]
 8002b8e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002b92:	d01d      	beq.n	8002bd0 <HAL_SPI_Transmit+0xb2>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002b94:	6823      	ldr	r3, [r4, #0]
 8002b96:	681a      	ldr	r2, [r3, #0]
 8002b98:	f012 0f40 	tst.w	r2, #64	; 0x40
 8002b9c:	d103      	bne.n	8002ba6 <HAL_SPI_Transmit+0x88>
    __HAL_SPI_ENABLE(hspi);
 8002b9e:	681a      	ldr	r2, [r3, #0]
 8002ba0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002ba4:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8002ba6:	68e3      	ldr	r3, [r4, #12]
 8002ba8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002bac:	d016      	beq.n	8002bdc <HAL_SPI_Transmit+0xbe>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002bae:	6863      	ldr	r3, [r4, #4]
 8002bb0:	b10b      	cbz	r3, 8002bb6 <HAL_SPI_Transmit+0x98>
 8002bb2:	2f01      	cmp	r7, #1
 8002bb4:	d14c      	bne.n	8002c50 <HAL_SPI_Transmit+0x132>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002bb6:	6823      	ldr	r3, [r4, #0]
 8002bb8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002bba:	7812      	ldrb	r2, [r2, #0]
 8002bbc:	731a      	strb	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002bbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002bc0:	3301      	adds	r3, #1
 8002bc2:	6323      	str	r3, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002bc4:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002bc6:	b29b      	uxth	r3, r3
 8002bc8:	3b01      	subs	r3, #1
 8002bca:	b29b      	uxth	r3, r3
 8002bcc:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002bce:	e03f      	b.n	8002c50 <HAL_SPI_Transmit+0x132>
    SPI_1LINE_TX(hspi);
 8002bd0:	6822      	ldr	r2, [r4, #0]
 8002bd2:	6813      	ldr	r3, [r2, #0]
 8002bd4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002bd8:	6013      	str	r3, [r2, #0]
 8002bda:	e7db      	b.n	8002b94 <HAL_SPI_Transmit+0x76>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002bdc:	6863      	ldr	r3, [r4, #4]
 8002bde:	b10b      	cbz	r3, 8002be4 <HAL_SPI_Transmit+0xc6>
 8002be0:	2f01      	cmp	r7, #1
 8002be2:	d116      	bne.n	8002c12 <HAL_SPI_Transmit+0xf4>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002be4:	6823      	ldr	r3, [r4, #0]
 8002be6:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002be8:	8812      	ldrh	r2, [r2, #0]
 8002bea:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002bec:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002bee:	3302      	adds	r3, #2
 8002bf0:	6323      	str	r3, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002bf2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002bf4:	b29b      	uxth	r3, r3
 8002bf6:	3b01      	subs	r3, #1
 8002bf8:	b29b      	uxth	r3, r3
 8002bfa:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002bfc:	e009      	b.n	8002c12 <HAL_SPI_Transmit+0xf4>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002bfe:	f7fd fb5d 	bl	80002bc <HAL_GetTick>
 8002c02:	1b80      	subs	r0, r0, r6
 8002c04:	42a8      	cmp	r0, r5
 8002c06:	d302      	bcc.n	8002c0e <HAL_SPI_Transmit+0xf0>
 8002c08:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002c0c:	d14d      	bne.n	8002caa <HAL_SPI_Transmit+0x18c>
 8002c0e:	2d00      	cmp	r5, #0
 8002c10:	d04d      	beq.n	8002cae <HAL_SPI_Transmit+0x190>
    while (hspi->TxXferCount > 0U)
 8002c12:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002c14:	b29b      	uxth	r3, r3
 8002c16:	2b00      	cmp	r3, #0
 8002c18:	d02e      	beq.n	8002c78 <HAL_SPI_Transmit+0x15a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002c1a:	6823      	ldr	r3, [r4, #0]
 8002c1c:	689a      	ldr	r2, [r3, #8]
 8002c1e:	f012 0f02 	tst.w	r2, #2
 8002c22:	d0ec      	beq.n	8002bfe <HAL_SPI_Transmit+0xe0>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002c24:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c26:	8812      	ldrh	r2, [r2, #0]
 8002c28:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002c2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c2c:	3302      	adds	r3, #2
 8002c2e:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002c30:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002c32:	b29b      	uxth	r3, r3
 8002c34:	3b01      	subs	r3, #1
 8002c36:	b29b      	uxth	r3, r3
 8002c38:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002c3a:	e7ea      	b.n	8002c12 <HAL_SPI_Transmit+0xf4>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002c3c:	f7fd fb3e 	bl	80002bc <HAL_GetTick>
 8002c40:	1b80      	subs	r0, r0, r6
 8002c42:	4285      	cmp	r5, r0
 8002c44:	d802      	bhi.n	8002c4c <HAL_SPI_Transmit+0x12e>
 8002c46:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002c4a:	d132      	bne.n	8002cb2 <HAL_SPI_Transmit+0x194>
 8002c4c:	2d00      	cmp	r5, #0
 8002c4e:	d032      	beq.n	8002cb6 <HAL_SPI_Transmit+0x198>
    while (hspi->TxXferCount > 0U)
 8002c50:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002c52:	b292      	uxth	r2, r2
 8002c54:	b182      	cbz	r2, 8002c78 <HAL_SPI_Transmit+0x15a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002c56:	6823      	ldr	r3, [r4, #0]
 8002c58:	689a      	ldr	r2, [r3, #8]
 8002c5a:	f012 0f02 	tst.w	r2, #2
 8002c5e:	d0ed      	beq.n	8002c3c <HAL_SPI_Transmit+0x11e>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002c60:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002c62:	7812      	ldrb	r2, [r2, #0]
 8002c64:	731a      	strb	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002c66:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c68:	3301      	adds	r3, #1
 8002c6a:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002c6c:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002c6e:	b292      	uxth	r2, r2
 8002c70:	3a01      	subs	r2, #1
 8002c72:	b292      	uxth	r2, r2
 8002c74:	86e2      	strh	r2, [r4, #54]	; 0x36
 8002c76:	e7eb      	b.n	8002c50 <HAL_SPI_Transmit+0x132>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002c78:	4632      	mov	r2, r6
 8002c7a:	4629      	mov	r1, r5
 8002c7c:	4620      	mov	r0, r4
 8002c7e:	f7ff fec0 	bl	8002a02 <SPI_EndRxTxTransaction>
 8002c82:	b108      	cbz	r0, 8002c88 <HAL_SPI_Transmit+0x16a>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002c84:	2320      	movs	r3, #32
 8002c86:	6563      	str	r3, [r4, #84]	; 0x54
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002c88:	68a3      	ldr	r3, [r4, #8]
 8002c8a:	b933      	cbnz	r3, 8002c9a <HAL_SPI_Transmit+0x17c>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002c8c:	9301      	str	r3, [sp, #4]
 8002c8e:	6823      	ldr	r3, [r4, #0]
 8002c90:	68da      	ldr	r2, [r3, #12]
 8002c92:	9201      	str	r2, [sp, #4]
 8002c94:	689b      	ldr	r3, [r3, #8]
 8002c96:	9301      	str	r3, [sp, #4]
 8002c98:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002c9a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002c9c:	b96b      	cbnz	r3, 8002cba <HAL_SPI_Transmit+0x19c>
  HAL_StatusTypeDef errorcode = HAL_OK;
 8002c9e:	2000      	movs	r0, #0
 8002ca0:	e758      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
    errorcode = HAL_ERROR;
 8002ca2:	2001      	movs	r0, #1
 8002ca4:	e756      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
 8002ca6:	2001      	movs	r0, #1
 8002ca8:	e754      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
          errorcode = HAL_TIMEOUT;
 8002caa:	2003      	movs	r0, #3
 8002cac:	e752      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
 8002cae:	2003      	movs	r0, #3
 8002cb0:	e750      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
          errorcode = HAL_TIMEOUT;
 8002cb2:	2003      	movs	r0, #3
 8002cb4:	e74e      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
 8002cb6:	2003      	movs	r0, #3
 8002cb8:	e74c      	b.n	8002b54 <HAL_SPI_Transmit+0x36>
    errorcode = HAL_ERROR;
 8002cba:	2001      	movs	r0, #1
 8002cbc:	e74a      	b.n	8002b54 <HAL_SPI_Transmit+0x36>

08002cbe <HAL_SPI_TransmitReceive>:
{
 8002cbe:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002cc2:	b083      	sub	sp, #12
 8002cc4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  __HAL_LOCK(hspi);
 8002cc6:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
 8002cca:	2c01      	cmp	r4, #1
 8002ccc:	d104      	bne.n	8002cd8 <HAL_SPI_TransmitReceive+0x1a>
 8002cce:	2302      	movs	r3, #2
}
 8002cd0:	4618      	mov	r0, r3
 8002cd2:	b003      	add	sp, #12
 8002cd4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002cd8:	461e      	mov	r6, r3
 8002cda:	4690      	mov	r8, r2
 8002cdc:	460f      	mov	r7, r1
 8002cde:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8002ce0:	2301      	movs	r3, #1
 8002ce2:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  tickstart = HAL_GetTick();
 8002ce6:	f7fd fae9 	bl	80002bc <HAL_GetTick>
 8002cea:	4681      	mov	r9, r0
  tmp_state           = hspi->State;
 8002cec:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8002cf0:	b2db      	uxtb	r3, r3
  tmp_mode            = hspi->Init.Mode;
 8002cf2:	6862      	ldr	r2, [r4, #4]
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002cf4:	2b01      	cmp	r3, #1
 8002cf6:	d012      	beq.n	8002d1e <HAL_SPI_TransmitReceive+0x60>
 8002cf8:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8002cfc:	d007      	beq.n	8002d0e <HAL_SPI_TransmitReceive+0x50>
    errorcode = HAL_BUSY;
 8002cfe:	2302      	movs	r3, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002d00:	2201      	movs	r2, #1
 8002d02:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8002d06:	2200      	movs	r2, #0
 8002d08:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
  return errorcode;
 8002d0c:	e7e0      	b.n	8002cd0 <HAL_SPI_TransmitReceive+0x12>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8002d0e:	68a2      	ldr	r2, [r4, #8]
 8002d10:	2a00      	cmp	r2, #0
 8002d12:	f040 80e2 	bne.w	8002eda <HAL_SPI_TransmitReceive+0x21c>
 8002d16:	2b04      	cmp	r3, #4
 8002d18:	d001      	beq.n	8002d1e <HAL_SPI_TransmitReceive+0x60>
    errorcode = HAL_BUSY;
 8002d1a:	2302      	movs	r3, #2
 8002d1c:	e7f0      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8002d1e:	2f00      	cmp	r7, #0
 8002d20:	f000 80dd 	beq.w	8002ede <HAL_SPI_TransmitReceive+0x220>
 8002d24:	f1b8 0f00 	cmp.w	r8, #0
 8002d28:	f000 80db 	beq.w	8002ee2 <HAL_SPI_TransmitReceive+0x224>
 8002d2c:	2e00      	cmp	r6, #0
 8002d2e:	f000 80da 	beq.w	8002ee6 <HAL_SPI_TransmitReceive+0x228>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002d32:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8002d36:	b2db      	uxtb	r3, r3
 8002d38:	2b04      	cmp	r3, #4
 8002d3a:	d002      	beq.n	8002d42 <HAL_SPI_TransmitReceive+0x84>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8002d3c:	2305      	movs	r3, #5
 8002d3e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002d42:	2300      	movs	r3, #0
 8002d44:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8002d46:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->RxXferCount = Size;
 8002d4a:	87e6      	strh	r6, [r4, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 8002d4c:	87a6      	strh	r6, [r4, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8002d4e:	6327      	str	r7, [r4, #48]	; 0x30
  hspi->TxXferCount = Size;
 8002d50:	86e6      	strh	r6, [r4, #54]	; 0x36
  hspi->TxXferSize  = Size;
 8002d52:	86a6      	strh	r6, [r4, #52]	; 0x34
  hspi->RxISR       = NULL;
 8002d54:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8002d56:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002d58:	6823      	ldr	r3, [r4, #0]
 8002d5a:	681a      	ldr	r2, [r3, #0]
 8002d5c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8002d60:	d103      	bne.n	8002d6a <HAL_SPI_TransmitReceive+0xac>
    __HAL_SPI_ENABLE(hspi);
 8002d62:	681a      	ldr	r2, [r3, #0]
 8002d64:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002d68:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8002d6a:	68e3      	ldr	r3, [r4, #12]
 8002d6c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002d70:	d011      	beq.n	8002d96 <HAL_SPI_TransmitReceive+0xd8>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002d72:	6863      	ldr	r3, [r4, #4]
 8002d74:	b10b      	cbz	r3, 8002d7a <HAL_SPI_TransmitReceive+0xbc>
 8002d76:	2e01      	cmp	r6, #1
 8002d78:	d10b      	bne.n	8002d92 <HAL_SPI_TransmitReceive+0xd4>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002d7a:	6823      	ldr	r3, [r4, #0]
 8002d7c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002d7e:	7812      	ldrb	r2, [r2, #0]
 8002d80:	731a      	strb	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002d82:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002d84:	3301      	adds	r3, #1
 8002d86:	6323      	str	r3, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002d88:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002d8a:	b29b      	uxth	r3, r3
 8002d8c:	3b01      	subs	r3, #1
 8002d8e:	b29b      	uxth	r3, r3
 8002d90:	86e3      	strh	r3, [r4, #54]	; 0x36
        txallowed = 1U;
 8002d92:	2601      	movs	r6, #1
 8002d94:	e06c      	b.n	8002e70 <HAL_SPI_TransmitReceive+0x1b2>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002d96:	6863      	ldr	r3, [r4, #4]
 8002d98:	b10b      	cbz	r3, 8002d9e <HAL_SPI_TransmitReceive+0xe0>
 8002d9a:	2e01      	cmp	r6, #1
 8002d9c:	d10b      	bne.n	8002db6 <HAL_SPI_TransmitReceive+0xf8>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002d9e:	6823      	ldr	r3, [r4, #0]
 8002da0:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002da2:	8812      	ldrh	r2, [r2, #0]
 8002da4:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002da6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002da8:	3302      	adds	r3, #2
 8002daa:	6323      	str	r3, [r4, #48]	; 0x30
      hspi->TxXferCount--;
 8002dac:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002dae:	b29b      	uxth	r3, r3
 8002db0:	3b01      	subs	r3, #1
 8002db2:	b29b      	uxth	r3, r3
 8002db4:	86e3      	strh	r3, [r4, #54]	; 0x36
        txallowed = 1U;
 8002db6:	2601      	movs	r6, #1
 8002db8:	e01c      	b.n	8002df4 <HAL_SPI_TransmitReceive+0x136>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002dba:	6823      	ldr	r3, [r4, #0]
 8002dbc:	689a      	ldr	r2, [r3, #8]
 8002dbe:	f012 0f01 	tst.w	r2, #1
 8002dc2:	d00e      	beq.n	8002de2 <HAL_SPI_TransmitReceive+0x124>
 8002dc4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8002dc6:	b292      	uxth	r2, r2
 8002dc8:	b15a      	cbz	r2, 8002de2 <HAL_SPI_TransmitReceive+0x124>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8002dca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002dcc:	68db      	ldr	r3, [r3, #12]
 8002dce:	8013      	strh	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8002dd0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002dd2:	3302      	adds	r3, #2
 8002dd4:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002dd6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002dd8:	b29b      	uxth	r3, r3
 8002dda:	3b01      	subs	r3, #1
 8002ddc:	b29b      	uxth	r3, r3
 8002dde:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 8002de0:	2601      	movs	r6, #1
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8002de2:	f7fd fa6b 	bl	80002bc <HAL_GetTick>
 8002de6:	eba0 0009 	sub.w	r0, r0, r9
 8002dea:	42a8      	cmp	r0, r5
 8002dec:	d302      	bcc.n	8002df4 <HAL_SPI_TransmitReceive+0x136>
 8002dee:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002df2:	d17a      	bne.n	8002eea <HAL_SPI_TransmitReceive+0x22c>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002df4:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002df6:	b29b      	uxth	r3, r3
 8002df8:	b91b      	cbnz	r3, 8002e02 <HAL_SPI_TransmitReceive+0x144>
 8002dfa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002dfc:	b29b      	uxth	r3, r3
 8002dfe:	2b00      	cmp	r3, #0
 8002e00:	d054      	beq.n	8002eac <HAL_SPI_TransmitReceive+0x1ee>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002e02:	6823      	ldr	r3, [r4, #0]
 8002e04:	689a      	ldr	r2, [r3, #8]
 8002e06:	f012 0f02 	tst.w	r2, #2
 8002e0a:	d0d6      	beq.n	8002dba <HAL_SPI_TransmitReceive+0xfc>
 8002e0c:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002e0e:	b292      	uxth	r2, r2
 8002e10:	2a00      	cmp	r2, #0
 8002e12:	d0d2      	beq.n	8002dba <HAL_SPI_TransmitReceive+0xfc>
 8002e14:	2e00      	cmp	r6, #0
 8002e16:	d0d0      	beq.n	8002dba <HAL_SPI_TransmitReceive+0xfc>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002e18:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002e1a:	8812      	ldrh	r2, [r2, #0]
 8002e1c:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002e1e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e20:	3302      	adds	r3, #2
 8002e22:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002e24:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e26:	b29b      	uxth	r3, r3
 8002e28:	3b01      	subs	r3, #1
 8002e2a:	b29b      	uxth	r3, r3
 8002e2c:	86e3      	strh	r3, [r4, #54]	; 0x36
        txallowed = 0U;
 8002e2e:	2600      	movs	r6, #0
 8002e30:	e7c3      	b.n	8002dba <HAL_SPI_TransmitReceive+0xfc>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002e32:	6823      	ldr	r3, [r4, #0]
 8002e34:	689a      	ldr	r2, [r3, #8]
 8002e36:	f012 0f01 	tst.w	r2, #1
 8002e3a:	d00e      	beq.n	8002e5a <HAL_SPI_TransmitReceive+0x19c>
 8002e3c:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8002e3e:	b292      	uxth	r2, r2
 8002e40:	b15a      	cbz	r2, 8002e5a <HAL_SPI_TransmitReceive+0x19c>
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002e42:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002e44:	68db      	ldr	r3, [r3, #12]
 8002e46:	7013      	strb	r3, [r2, #0]
        hspi->pRxBuffPtr++;
 8002e48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002e4a:	3301      	adds	r3, #1
 8002e4c:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002e4e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e50:	b29b      	uxth	r3, r3
 8002e52:	3b01      	subs	r3, #1
 8002e54:	b29b      	uxth	r3, r3
 8002e56:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 8002e58:	2601      	movs	r6, #1
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8002e5a:	f7fd fa2f 	bl	80002bc <HAL_GetTick>
 8002e5e:	eba0 0009 	sub.w	r0, r0, r9
 8002e62:	4285      	cmp	r5, r0
 8002e64:	d802      	bhi.n	8002e6c <HAL_SPI_TransmitReceive+0x1ae>
 8002e66:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002e6a:	d140      	bne.n	8002eee <HAL_SPI_TransmitReceive+0x230>
 8002e6c:	2d00      	cmp	r5, #0
 8002e6e:	d040      	beq.n	8002ef2 <HAL_SPI_TransmitReceive+0x234>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002e70:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002e72:	b29b      	uxth	r3, r3
 8002e74:	b913      	cbnz	r3, 8002e7c <HAL_SPI_TransmitReceive+0x1be>
 8002e76:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e78:	b29b      	uxth	r3, r3
 8002e7a:	b1bb      	cbz	r3, 8002eac <HAL_SPI_TransmitReceive+0x1ee>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002e7c:	6823      	ldr	r3, [r4, #0]
 8002e7e:	689a      	ldr	r2, [r3, #8]
 8002e80:	f012 0f02 	tst.w	r2, #2
 8002e84:	d0d5      	beq.n	8002e32 <HAL_SPI_TransmitReceive+0x174>
 8002e86:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8002e88:	b292      	uxth	r2, r2
 8002e8a:	2a00      	cmp	r2, #0
 8002e8c:	d0d1      	beq.n	8002e32 <HAL_SPI_TransmitReceive+0x174>
 8002e8e:	2e00      	cmp	r6, #0
 8002e90:	d0cf      	beq.n	8002e32 <HAL_SPI_TransmitReceive+0x174>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8002e92:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002e94:	7812      	ldrb	r2, [r2, #0]
 8002e96:	731a      	strb	r2, [r3, #12]
        hspi->pTxBuffPtr++;
 8002e98:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e9a:	3301      	adds	r3, #1
 8002e9c:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002e9e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002ea0:	b29b      	uxth	r3, r3
 8002ea2:	3b01      	subs	r3, #1
 8002ea4:	b29b      	uxth	r3, r3
 8002ea6:	86e3      	strh	r3, [r4, #54]	; 0x36
        txallowed = 0U;
 8002ea8:	2600      	movs	r6, #0
 8002eaa:	e7c2      	b.n	8002e32 <HAL_SPI_TransmitReceive+0x174>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002eac:	464a      	mov	r2, r9
 8002eae:	4629      	mov	r1, r5
 8002eb0:	4620      	mov	r0, r4
 8002eb2:	f7ff fda6 	bl	8002a02 <SPI_EndRxTxTransaction>
 8002eb6:	4603      	mov	r3, r0
 8002eb8:	b118      	cbz	r0, 8002ec2 <HAL_SPI_TransmitReceive+0x204>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002eba:	2320      	movs	r3, #32
 8002ebc:	6563      	str	r3, [r4, #84]	; 0x54
    errorcode = HAL_ERROR;
 8002ebe:	2301      	movs	r3, #1
    goto error;
 8002ec0:	e71e      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002ec2:	68a2      	ldr	r2, [r4, #8]
 8002ec4:	2a00      	cmp	r2, #0
 8002ec6:	f47f af1b 	bne.w	8002d00 <HAL_SPI_TransmitReceive+0x42>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002eca:	9201      	str	r2, [sp, #4]
 8002ecc:	6822      	ldr	r2, [r4, #0]
 8002ece:	68d1      	ldr	r1, [r2, #12]
 8002ed0:	9101      	str	r1, [sp, #4]
 8002ed2:	6892      	ldr	r2, [r2, #8]
 8002ed4:	9201      	str	r2, [sp, #4]
 8002ed6:	9a01      	ldr	r2, [sp, #4]
 8002ed8:	e712      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
    errorcode = HAL_BUSY;
 8002eda:	2302      	movs	r3, #2
 8002edc:	e710      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
    errorcode = HAL_ERROR;
 8002ede:	2301      	movs	r3, #1
 8002ee0:	e70e      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
 8002ee2:	2301      	movs	r3, #1
 8002ee4:	e70c      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
 8002ee6:	2301      	movs	r3, #1
 8002ee8:	e70a      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
        errorcode = HAL_TIMEOUT;
 8002eea:	2303      	movs	r3, #3
 8002eec:	e708      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
        errorcode = HAL_TIMEOUT;
 8002eee:	2303      	movs	r3, #3
 8002ef0:	e706      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>
 8002ef2:	2303      	movs	r3, #3
 8002ef4:	e704      	b.n	8002d00 <HAL_SPI_TransmitReceive+0x42>

08002ef6 <HAL_SPI_Receive>:
{
 8002ef6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002efa:	b082      	sub	sp, #8
 8002efc:	4604      	mov	r4, r0
 8002efe:	460f      	mov	r7, r1
 8002f00:	4690      	mov	r8, r2
 8002f02:	461d      	mov	r5, r3
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8002f04:	6843      	ldr	r3, [r0, #4]
 8002f06:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8002f0a:	d007      	beq.n	8002f1c <HAL_SPI_Receive+0x26>
  __HAL_LOCK(hspi);
 8002f0c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8002f10:	2b01      	cmp	r3, #1
 8002f12:	d10f      	bne.n	8002f34 <HAL_SPI_Receive+0x3e>
 8002f14:	2002      	movs	r0, #2
}
 8002f16:	b002      	add	sp, #8
 8002f18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8002f1c:	6883      	ldr	r3, [r0, #8]
 8002f1e:	2b00      	cmp	r3, #0
 8002f20:	d1f4      	bne.n	8002f0c <HAL_SPI_Receive+0x16>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8002f22:	2304      	movs	r3, #4
 8002f24:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8002f28:	9500      	str	r5, [sp, #0]
 8002f2a:	4613      	mov	r3, r2
 8002f2c:	460a      	mov	r2, r1
 8002f2e:	f7ff fec6 	bl	8002cbe <HAL_SPI_TransmitReceive>
 8002f32:	e7f0      	b.n	8002f16 <HAL_SPI_Receive+0x20>
  __HAL_LOCK(hspi);
 8002f34:	2301      	movs	r3, #1
 8002f36:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tickstart = HAL_GetTick();
 8002f3a:	f7fd f9bf 	bl	80002bc <HAL_GetTick>
 8002f3e:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002f40:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8002f44:	b2db      	uxtb	r3, r3
 8002f46:	2b01      	cmp	r3, #1
 8002f48:	d007      	beq.n	8002f5a <HAL_SPI_Receive+0x64>
    errorcode = HAL_BUSY;
 8002f4a:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002f4c:	2301      	movs	r3, #1
 8002f4e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8002f52:	2300      	movs	r3, #0
 8002f54:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 8002f58:	e7dd      	b.n	8002f16 <HAL_SPI_Receive+0x20>
  if ((pData == NULL) || (Size == 0U))
 8002f5a:	2f00      	cmp	r7, #0
 8002f5c:	d06f      	beq.n	800303e <HAL_SPI_Receive+0x148>
 8002f5e:	f1b8 0f00 	cmp.w	r8, #0
 8002f62:	d06e      	beq.n	8003042 <HAL_SPI_Receive+0x14c>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8002f64:	2304      	movs	r3, #4
 8002f66:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002f6a:	2300      	movs	r3, #0
 8002f6c:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8002f6e:	63a7      	str	r7, [r4, #56]	; 0x38
  hspi->RxXferSize  = Size;
 8002f70:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxXferCount = Size;
 8002f74:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8002f78:	6323      	str	r3, [r4, #48]	; 0x30
  hspi->TxXferSize  = 0U;
 8002f7a:	86a3      	strh	r3, [r4, #52]	; 0x34
  hspi->TxXferCount = 0U;
 8002f7c:	86e3      	strh	r3, [r4, #54]	; 0x36
  hspi->RxISR       = NULL;
 8002f7e:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8002f80:	6463      	str	r3, [r4, #68]	; 0x44
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002f82:	68a3      	ldr	r3, [r4, #8]
 8002f84:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002f88:	d00b      	beq.n	8002fa2 <HAL_SPI_Receive+0xac>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002f8a:	6823      	ldr	r3, [r4, #0]
 8002f8c:	681a      	ldr	r2, [r3, #0]
 8002f8e:	f012 0f40 	tst.w	r2, #64	; 0x40
 8002f92:	d103      	bne.n	8002f9c <HAL_SPI_Receive+0xa6>
    __HAL_SPI_ENABLE(hspi);
 8002f94:	681a      	ldr	r2, [r3, #0]
 8002f96:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002f9a:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 8002f9c:	68e3      	ldr	r3, [r4, #12]
 8002f9e:	b183      	cbz	r3, 8002fc2 <HAL_SPI_Receive+0xcc>
 8002fa0:	e02d      	b.n	8002ffe <HAL_SPI_Receive+0x108>
    SPI_1LINE_RX(hspi);
 8002fa2:	6822      	ldr	r2, [r4, #0]
 8002fa4:	6813      	ldr	r3, [r2, #0]
 8002fa6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002faa:	6013      	str	r3, [r2, #0]
 8002fac:	e7ed      	b.n	8002f8a <HAL_SPI_Receive+0x94>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002fae:	f7fd f985 	bl	80002bc <HAL_GetTick>
 8002fb2:	1b80      	subs	r0, r0, r6
 8002fb4:	4285      	cmp	r5, r0
 8002fb6:	d802      	bhi.n	8002fbe <HAL_SPI_Receive+0xc8>
 8002fb8:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002fbc:	d143      	bne.n	8003046 <HAL_SPI_Receive+0x150>
 8002fbe:	2d00      	cmp	r5, #0
 8002fc0:	d043      	beq.n	800304a <HAL_SPI_Receive+0x154>
    while (hspi->RxXferCount > 0U)
 8002fc2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002fc4:	b29b      	uxth	r3, r3
 8002fc6:	2b00      	cmp	r3, #0
 8002fc8:	d02d      	beq.n	8003026 <HAL_SPI_Receive+0x130>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8002fca:	6823      	ldr	r3, [r4, #0]
 8002fcc:	689a      	ldr	r2, [r3, #8]
 8002fce:	f012 0f01 	tst.w	r2, #1
 8002fd2:	d0ec      	beq.n	8002fae <HAL_SPI_Receive+0xb8>
        (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8002fd4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002fd6:	7b1b      	ldrb	r3, [r3, #12]
 8002fd8:	7013      	strb	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8002fda:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002fdc:	3301      	adds	r3, #1
 8002fde:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002fe0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002fe2:	b29b      	uxth	r3, r3
 8002fe4:	3b01      	subs	r3, #1
 8002fe6:	b29b      	uxth	r3, r3
 8002fe8:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8002fea:	e7ea      	b.n	8002fc2 <HAL_SPI_Receive+0xcc>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002fec:	f7fd f966 	bl	80002bc <HAL_GetTick>
 8002ff0:	1b80      	subs	r0, r0, r6
 8002ff2:	4285      	cmp	r5, r0
 8002ff4:	d802      	bhi.n	8002ffc <HAL_SPI_Receive+0x106>
 8002ff6:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002ffa:	d128      	bne.n	800304e <HAL_SPI_Receive+0x158>
 8002ffc:	b34d      	cbz	r5, 8003052 <HAL_SPI_Receive+0x15c>
    while (hspi->RxXferCount > 0U)
 8002ffe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8003000:	b29b      	uxth	r3, r3
 8003002:	b183      	cbz	r3, 8003026 <HAL_SPI_Receive+0x130>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8003004:	6823      	ldr	r3, [r4, #0]
 8003006:	689a      	ldr	r2, [r3, #8]
 8003008:	f012 0f01 	tst.w	r2, #1
 800300c:	d0ee      	beq.n	8002fec <HAL_SPI_Receive+0xf6>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800300e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8003010:	68db      	ldr	r3, [r3, #12]
 8003012:	8013      	strh	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8003014:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003016:	3302      	adds	r3, #2
 8003018:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 800301a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800301c:	b29b      	uxth	r3, r3
 800301e:	3b01      	subs	r3, #1
 8003020:	b29b      	uxth	r3, r3
 8003022:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8003024:	e7eb      	b.n	8002ffe <HAL_SPI_Receive+0x108>
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8003026:	4632      	mov	r2, r6
 8003028:	4629      	mov	r1, r5
 800302a:	4620      	mov	r0, r4
 800302c:	f7ff fcfc 	bl	8002a28 <SPI_EndRxTransaction>
 8003030:	b108      	cbz	r0, 8003036 <HAL_SPI_Receive+0x140>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8003032:	2320      	movs	r3, #32
 8003034:	6563      	str	r3, [r4, #84]	; 0x54
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8003036:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8003038:	b96b      	cbnz	r3, 8003056 <HAL_SPI_Receive+0x160>
  HAL_StatusTypeDef errorcode = HAL_OK;
 800303a:	2000      	movs	r0, #0
 800303c:	e786      	b.n	8002f4c <HAL_SPI_Receive+0x56>
    errorcode = HAL_ERROR;
 800303e:	2001      	movs	r0, #1
 8003040:	e784      	b.n	8002f4c <HAL_SPI_Receive+0x56>
 8003042:	2001      	movs	r0, #1
 8003044:	e782      	b.n	8002f4c <HAL_SPI_Receive+0x56>
          errorcode = HAL_TIMEOUT;
 8003046:	2003      	movs	r0, #3
 8003048:	e780      	b.n	8002f4c <HAL_SPI_Receive+0x56>
 800304a:	2003      	movs	r0, #3
 800304c:	e77e      	b.n	8002f4c <HAL_SPI_Receive+0x56>
          errorcode = HAL_TIMEOUT;
 800304e:	2003      	movs	r0, #3
 8003050:	e77c      	b.n	8002f4c <HAL_SPI_Receive+0x56>
 8003052:	2003      	movs	r0, #3
 8003054:	e77a      	b.n	8002f4c <HAL_SPI_Receive+0x56>
    errorcode = HAL_ERROR;
 8003056:	2001      	movs	r0, #1
 8003058:	e778      	b.n	8002f4c <HAL_SPI_Receive+0x56>

0800305a <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800305a:	6802      	ldr	r2, [r0, #0]
 800305c:	68d3      	ldr	r3, [r2, #12]
 800305e:	f043 0301 	orr.w	r3, r3, #1
 8003062:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8003064:	6802      	ldr	r2, [r0, #0]
 8003066:	6893      	ldr	r3, [r2, #8]
 8003068:	f003 0307 	and.w	r3, r3, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800306c:	2b06      	cmp	r3, #6
 800306e:	d003      	beq.n	8003078 <HAL_TIM_Base_Start_IT+0x1e>
  {
    __HAL_TIM_ENABLE(htim);
 8003070:	6813      	ldr	r3, [r2, #0]
 8003072:	f043 0301 	orr.w	r3, r3, #1
 8003076:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8003078:	2000      	movs	r0, #0
 800307a:	4770      	bx	lr

0800307c <HAL_TIM_Base_Stop_IT>:
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  /* Disable the TIM Update interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 800307c:	6802      	ldr	r2, [r0, #0]
 800307e:	68d3      	ldr	r3, [r2, #12]
 8003080:	f023 0301 	bic.w	r3, r3, #1
 8003084:	60d3      	str	r3, [r2, #12]

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 8003086:	6803      	ldr	r3, [r0, #0]
 8003088:	6a19      	ldr	r1, [r3, #32]
 800308a:	f241 1211 	movw	r2, #4369	; 0x1111
 800308e:	4211      	tst	r1, r2
 8003090:	d108      	bne.n	80030a4 <HAL_TIM_Base_Stop_IT+0x28>
 8003092:	6a19      	ldr	r1, [r3, #32]
 8003094:	f240 4244 	movw	r2, #1092	; 0x444
 8003098:	4211      	tst	r1, r2
 800309a:	d103      	bne.n	80030a4 <HAL_TIM_Base_Stop_IT+0x28>
 800309c:	681a      	ldr	r2, [r3, #0]
 800309e:	f022 0201 	bic.w	r2, r2, #1
 80030a2:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 80030a4:	2000      	movs	r0, #0
 80030a6:	4770      	bx	lr

080030a8 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 80030a8:	4770      	bx	lr

080030aa <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80030aa:	4770      	bx	lr

080030ac <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 80030ac:	4770      	bx	lr

080030ae <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 80030ae:	4770      	bx	lr

080030b0 <HAL_TIM_IRQHandler>:
{
 80030b0:	b510      	push	{r4, lr}
 80030b2:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80030b4:	6803      	ldr	r3, [r0, #0]
 80030b6:	691a      	ldr	r2, [r3, #16]
 80030b8:	f012 0f02 	tst.w	r2, #2
 80030bc:	d011      	beq.n	80030e2 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80030be:	68da      	ldr	r2, [r3, #12]
 80030c0:	f012 0f02 	tst.w	r2, #2
 80030c4:	d00d      	beq.n	80030e2 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80030c6:	f06f 0202 	mvn.w	r2, #2
 80030ca:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80030cc:	2301      	movs	r3, #1
 80030ce:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80030d0:	6803      	ldr	r3, [r0, #0]
 80030d2:	699b      	ldr	r3, [r3, #24]
 80030d4:	f013 0f03 	tst.w	r3, #3
 80030d8:	d070      	beq.n	80031bc <HAL_TIM_IRQHandler+0x10c>
          HAL_TIM_IC_CaptureCallback(htim);
 80030da:	f7ff ffe6 	bl	80030aa <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80030de:	2300      	movs	r3, #0
 80030e0:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80030e2:	6823      	ldr	r3, [r4, #0]
 80030e4:	691a      	ldr	r2, [r3, #16]
 80030e6:	f012 0f04 	tst.w	r2, #4
 80030ea:	d012      	beq.n	8003112 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 80030ec:	68da      	ldr	r2, [r3, #12]
 80030ee:	f012 0f04 	tst.w	r2, #4
 80030f2:	d00e      	beq.n	8003112 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80030f4:	f06f 0204 	mvn.w	r2, #4
 80030f8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80030fa:	2302      	movs	r3, #2
 80030fc:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80030fe:	6823      	ldr	r3, [r4, #0]
 8003100:	699b      	ldr	r3, [r3, #24]
 8003102:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003106:	d05f      	beq.n	80031c8 <HAL_TIM_IRQHandler+0x118>
        HAL_TIM_IC_CaptureCallback(htim);
 8003108:	4620      	mov	r0, r4
 800310a:	f7ff ffce 	bl	80030aa <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800310e:	2300      	movs	r3, #0
 8003110:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8003112:	6823      	ldr	r3, [r4, #0]
 8003114:	691a      	ldr	r2, [r3, #16]
 8003116:	f012 0f08 	tst.w	r2, #8
 800311a:	d012      	beq.n	8003142 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800311c:	68da      	ldr	r2, [r3, #12]
 800311e:	f012 0f08 	tst.w	r2, #8
 8003122:	d00e      	beq.n	8003142 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8003124:	f06f 0208 	mvn.w	r2, #8
 8003128:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800312a:	2304      	movs	r3, #4
 800312c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800312e:	6823      	ldr	r3, [r4, #0]
 8003130:	69db      	ldr	r3, [r3, #28]
 8003132:	f013 0f03 	tst.w	r3, #3
 8003136:	d04e      	beq.n	80031d6 <HAL_TIM_IRQHandler+0x126>
        HAL_TIM_IC_CaptureCallback(htim);
 8003138:	4620      	mov	r0, r4
 800313a:	f7ff ffb6 	bl	80030aa <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800313e:	2300      	movs	r3, #0
 8003140:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8003142:	6823      	ldr	r3, [r4, #0]
 8003144:	691a      	ldr	r2, [r3, #16]
 8003146:	f012 0f10 	tst.w	r2, #16
 800314a:	d012      	beq.n	8003172 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800314c:	68da      	ldr	r2, [r3, #12]
 800314e:	f012 0f10 	tst.w	r2, #16
 8003152:	d00e      	beq.n	8003172 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8003154:	f06f 0210 	mvn.w	r2, #16
 8003158:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800315a:	2308      	movs	r3, #8
 800315c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800315e:	6823      	ldr	r3, [r4, #0]
 8003160:	69db      	ldr	r3, [r3, #28]
 8003162:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003166:	d03d      	beq.n	80031e4 <HAL_TIM_IRQHandler+0x134>
        HAL_TIM_IC_CaptureCallback(htim);
 8003168:	4620      	mov	r0, r4
 800316a:	f7ff ff9e 	bl	80030aa <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800316e:	2300      	movs	r3, #0
 8003170:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8003172:	6823      	ldr	r3, [r4, #0]
 8003174:	691a      	ldr	r2, [r3, #16]
 8003176:	f012 0f01 	tst.w	r2, #1
 800317a:	d003      	beq.n	8003184 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800317c:	68da      	ldr	r2, [r3, #12]
 800317e:	f012 0f01 	tst.w	r2, #1
 8003182:	d136      	bne.n	80031f2 <HAL_TIM_IRQHandler+0x142>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8003184:	6823      	ldr	r3, [r4, #0]
 8003186:	691a      	ldr	r2, [r3, #16]
 8003188:	f012 0f80 	tst.w	r2, #128	; 0x80
 800318c:	d003      	beq.n	8003196 <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800318e:	68da      	ldr	r2, [r3, #12]
 8003190:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003194:	d134      	bne.n	8003200 <HAL_TIM_IRQHandler+0x150>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8003196:	6823      	ldr	r3, [r4, #0]
 8003198:	691a      	ldr	r2, [r3, #16]
 800319a:	f012 0f40 	tst.w	r2, #64	; 0x40
 800319e:	d003      	beq.n	80031a8 <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80031a0:	68da      	ldr	r2, [r3, #12]
 80031a2:	f012 0f40 	tst.w	r2, #64	; 0x40
 80031a6:	d132      	bne.n	800320e <HAL_TIM_IRQHandler+0x15e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80031a8:	6823      	ldr	r3, [r4, #0]
 80031aa:	691a      	ldr	r2, [r3, #16]
 80031ac:	f012 0f20 	tst.w	r2, #32
 80031b0:	d003      	beq.n	80031ba <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80031b2:	68da      	ldr	r2, [r3, #12]
 80031b4:	f012 0f20 	tst.w	r2, #32
 80031b8:	d130      	bne.n	800321c <HAL_TIM_IRQHandler+0x16c>
 80031ba:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80031bc:	f7ff ff74 	bl	80030a8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80031c0:	4620      	mov	r0, r4
 80031c2:	f7ff ff73 	bl	80030ac <HAL_TIM_PWM_PulseFinishedCallback>
 80031c6:	e78a      	b.n	80030de <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80031c8:	4620      	mov	r0, r4
 80031ca:	f7ff ff6d 	bl	80030a8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80031ce:	4620      	mov	r0, r4
 80031d0:	f7ff ff6c 	bl	80030ac <HAL_TIM_PWM_PulseFinishedCallback>
 80031d4:	e79b      	b.n	800310e <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80031d6:	4620      	mov	r0, r4
 80031d8:	f7ff ff66 	bl	80030a8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80031dc:	4620      	mov	r0, r4
 80031de:	f7ff ff65 	bl	80030ac <HAL_TIM_PWM_PulseFinishedCallback>
 80031e2:	e7ac      	b.n	800313e <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80031e4:	4620      	mov	r0, r4
 80031e6:	f7ff ff5f 	bl	80030a8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80031ea:	4620      	mov	r0, r4
 80031ec:	f7ff ff5e 	bl	80030ac <HAL_TIM_PWM_PulseFinishedCallback>
 80031f0:	e7bd      	b.n	800316e <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80031f2:	f06f 0201 	mvn.w	r2, #1
 80031f6:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80031f8:	4620      	mov	r0, r4
 80031fa:	f004 fb87 	bl	800790c <HAL_TIM_PeriodElapsedCallback>
 80031fe:	e7c1      	b.n	8003184 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8003200:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8003204:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8003206:	4620      	mov	r0, r4
 8003208:	f000 f8b3 	bl	8003372 <HAL_TIMEx_BreakCallback>
 800320c:	e7c3      	b.n	8003196 <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800320e:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003212:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8003214:	4620      	mov	r0, r4
 8003216:	f7ff ff4a 	bl	80030ae <HAL_TIM_TriggerCallback>
 800321a:	e7c5      	b.n	80031a8 <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800321c:	f06f 0220 	mvn.w	r2, #32
 8003220:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8003222:	4620      	mov	r0, r4
 8003224:	f000 f8a4 	bl	8003370 <HAL_TIMEx_CommutCallback>
}
 8003228:	e7c7      	b.n	80031ba <HAL_TIM_IRQHandler+0x10a>
	...

0800322c <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800322c:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800322e:	4a31      	ldr	r2, [pc, #196]	; (80032f4 <TIM_Base_SetConfig+0xc8>)
 8003230:	4290      	cmp	r0, r2
 8003232:	d012      	beq.n	800325a <TIM_Base_SetConfig+0x2e>
 8003234:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003238:	4290      	cmp	r0, r2
 800323a:	d00e      	beq.n	800325a <TIM_Base_SetConfig+0x2e>
 800323c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003240:	d00b      	beq.n	800325a <TIM_Base_SetConfig+0x2e>
 8003242:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003246:	4290      	cmp	r0, r2
 8003248:	d007      	beq.n	800325a <TIM_Base_SetConfig+0x2e>
 800324a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800324e:	4290      	cmp	r0, r2
 8003250:	d003      	beq.n	800325a <TIM_Base_SetConfig+0x2e>
 8003252:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003256:	4290      	cmp	r0, r2
 8003258:	d103      	bne.n	8003262 <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800325a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800325e:	684a      	ldr	r2, [r1, #4]
 8003260:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8003262:	4a24      	ldr	r2, [pc, #144]	; (80032f4 <TIM_Base_SetConfig+0xc8>)
 8003264:	4290      	cmp	r0, r2
 8003266:	d02a      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 8003268:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800326c:	4290      	cmp	r0, r2
 800326e:	d026      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 8003270:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003274:	d023      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 8003276:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800327a:	4290      	cmp	r0, r2
 800327c:	d01f      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 800327e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003282:	4290      	cmp	r0, r2
 8003284:	d01b      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 8003286:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800328a:	4290      	cmp	r0, r2
 800328c:	d017      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 800328e:	f502 32a0 	add.w	r2, r2, #81920	; 0x14000
 8003292:	4290      	cmp	r0, r2
 8003294:	d013      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 8003296:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800329a:	4290      	cmp	r0, r2
 800329c:	d00f      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 800329e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80032a2:	4290      	cmp	r0, r2
 80032a4:	d00b      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 80032a6:	f5a2 329e 	sub.w	r2, r2, #80896	; 0x13c00
 80032aa:	4290      	cmp	r0, r2
 80032ac:	d007      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 80032ae:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80032b2:	4290      	cmp	r0, r2
 80032b4:	d003      	beq.n	80032be <TIM_Base_SetConfig+0x92>
 80032b6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80032ba:	4290      	cmp	r0, r2
 80032bc:	d103      	bne.n	80032c6 <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80032be:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80032c2:	68ca      	ldr	r2, [r1, #12]
 80032c4:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80032c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80032ca:	694a      	ldr	r2, [r1, #20]
 80032cc:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 80032ce:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80032d0:	688b      	ldr	r3, [r1, #8]
 80032d2:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80032d4:	680b      	ldr	r3, [r1, #0]
 80032d6:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80032d8:	4b06      	ldr	r3, [pc, #24]	; (80032f4 <TIM_Base_SetConfig+0xc8>)
 80032da:	4298      	cmp	r0, r3
 80032dc:	d006      	beq.n	80032ec <TIM_Base_SetConfig+0xc0>
 80032de:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80032e2:	4298      	cmp	r0, r3
 80032e4:	d002      	beq.n	80032ec <TIM_Base_SetConfig+0xc0>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80032e6:	2301      	movs	r3, #1
 80032e8:	6143      	str	r3, [r0, #20]
 80032ea:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 80032ec:	690b      	ldr	r3, [r1, #16]
 80032ee:	6303      	str	r3, [r0, #48]	; 0x30
 80032f0:	e7f9      	b.n	80032e6 <TIM_Base_SetConfig+0xba>
 80032f2:	bf00      	nop
 80032f4:	40012c00 	.word	0x40012c00

080032f8 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 80032f8:	b1a8      	cbz	r0, 8003326 <HAL_TIM_Base_Init+0x2e>
{
 80032fa:	b510      	push	{r4, lr}
 80032fc:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 80032fe:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8003302:	b15b      	cbz	r3, 800331c <HAL_TIM_Base_Init+0x24>
  htim->State = HAL_TIM_STATE_BUSY;
 8003304:	2302      	movs	r3, #2
 8003306:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800330a:	1d21      	adds	r1, r4, #4
 800330c:	6820      	ldr	r0, [r4, #0]
 800330e:	f7ff ff8d 	bl	800322c <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8003312:	2301      	movs	r3, #1
 8003314:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8003318:	2000      	movs	r0, #0
 800331a:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 800331c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8003320:	f005 fa86 	bl	8008830 <HAL_TIM_Base_MspInit>
 8003324:	e7ee      	b.n	8003304 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8003326:	2001      	movs	r0, #1
 8003328:	4770      	bx	lr

0800332a <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800332a:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800332e:	2b01      	cmp	r3, #1
 8003330:	d01c      	beq.n	800336c <HAL_TIMEx_MasterConfigSynchronization+0x42>
{
 8003332:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(htim);
 8003334:	2501      	movs	r5, #1
 8003336:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800333a:	2302      	movs	r3, #2
 800333c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8003340:	6804      	ldr	r4, [r0, #0]
 8003342:	6862      	ldr	r2, [r4, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8003344:	68a3      	ldr	r3, [r4, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8003346:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800334a:	680e      	ldr	r6, [r1, #0]
 800334c:	4332      	orrs	r2, r6

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 800334e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8003352:	6849      	ldr	r1, [r1, #4]
 8003354:	430b      	orrs	r3, r1

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8003356:	6062      	str	r2, [r4, #4]

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 8003358:	6802      	ldr	r2, [r0, #0]
 800335a:	6093      	str	r3, [r2, #8]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800335c:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8003360:	2300      	movs	r3, #0
 8003362:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
 8003366:	4618      	mov	r0, r3
}
 8003368:	bc70      	pop	{r4, r5, r6}
 800336a:	4770      	bx	lr
  __HAL_LOCK(htim);
 800336c:	2002      	movs	r0, #2
 800336e:	4770      	bx	lr

08003370 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8003370:	4770      	bx	lr

08003372 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8003372:	4770      	bx	lr

08003374 <SDMMC_GetCmdError>:
  */
static uint32_t SDMMC_GetCmdError(SDIO_TypeDef *SDIOx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8003374:	4b0b      	ldr	r3, [pc, #44]	; (80033a4 <SDMMC_GetCmdError+0x30>)
 8003376:	681b      	ldr	r3, [r3, #0]
 8003378:	4a0b      	ldr	r2, [pc, #44]	; (80033a8 <SDMMC_GetCmdError+0x34>)
 800337a:	fba2 2303 	umull	r2, r3, r2, r3
 800337e:	0a5a      	lsrs	r2, r3, #9
 8003380:	f241 3388 	movw	r3, #5000	; 0x1388
 8003384:	fb03 f302 	mul.w	r3, r3, r2
  
  do
  {
    if (count-- == 0U)
 8003388:	1e5a      	subs	r2, r3, #1
 800338a:	b143      	cbz	r3, 800339e <SDMMC_GetCmdError+0x2a>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDSENT));
 800338c:	6b41      	ldr	r1, [r0, #52]	; 0x34
    if (count-- == 0U)
 800338e:	4613      	mov	r3, r2
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDSENT));
 8003390:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003394:	d0f8      	beq.n	8003388 <SDMMC_GetCmdError+0x14>
  
  /* Clear all the static flags */
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 8003396:	23c5      	movs	r3, #197	; 0xc5
 8003398:	6383      	str	r3, [r0, #56]	; 0x38
  
  return SDMMC_ERROR_NONE;
 800339a:	2000      	movs	r0, #0
 800339c:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 800339e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80033a2:	4770      	bx	lr
 80033a4:	20000124 	.word	0x20000124
 80033a8:	10624dd3 	.word	0x10624dd3

080033ac <SDMMC_GetCmdResp2>:
static uint32_t SDMMC_GetCmdResp2(SDIO_TypeDef *SDIOx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80033ac:	4b15      	ldr	r3, [pc, #84]	; (8003404 <SDMMC_GetCmdResp2+0x58>)
 80033ae:	681b      	ldr	r3, [r3, #0]
 80033b0:	4a15      	ldr	r2, [pc, #84]	; (8003408 <SDMMC_GetCmdResp2+0x5c>)
 80033b2:	fba2 2303 	umull	r2, r3, r2, r3
 80033b6:	0a5a      	lsrs	r2, r3, #9
 80033b8:	f241 3388 	movw	r3, #5000	; 0x1388
 80033bc:	fb03 f302 	mul.w	r3, r3, r2
  
  do
  {
    if (count-- == 0U)
 80033c0:	1e5a      	subs	r2, r3, #1
 80033c2:	b1db      	cbz	r3, 80033fc <SDMMC_GetCmdResp2+0x50>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDIOx->STA;
 80033c4:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80033c6:	4613      	mov	r3, r2
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 80033c8:	f011 0f45 	tst.w	r1, #69	; 0x45
 80033cc:	d0f8      	beq.n	80033c0 <SDMMC_GetCmdResp2+0x14>
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 80033ce:	f411 6f00 	tst.w	r1, #2048	; 0x800
 80033d2:	d1f5      	bne.n	80033c0 <SDMMC_GetCmdResp2+0x14>
    
  if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80033d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80033d6:	f013 0f04 	tst.w	r3, #4
 80033da:	d003      	beq.n	80033e4 <SDMMC_GetCmdResp2+0x38>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80033dc:	2304      	movs	r3, #4
 80033de:	6383      	str	r3, [r0, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80033e0:	4618      	mov	r0, r3
 80033e2:	4770      	bx	lr
  }
  else if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 80033e4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80033e6:	f013 0f01 	tst.w	r3, #1
 80033ea:	d103      	bne.n	80033f4 <SDMMC_GetCmdResp2+0x48>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 80033ec:	23c5      	movs	r3, #197	; 0xc5
 80033ee:	6383      	str	r3, [r0, #56]	; 0x38
  }

  return SDMMC_ERROR_NONE;
 80033f0:	2000      	movs	r0, #0
 80033f2:	4770      	bx	lr
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80033f4:	2301      	movs	r3, #1
 80033f6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80033f8:	4618      	mov	r0, r3
 80033fa:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 80033fc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8003400:	4770      	bx	lr
 8003402:	bf00      	nop
 8003404:	20000124 	.word	0x20000124
 8003408:	10624dd3 	.word	0x10624dd3

0800340c <SDMMC_GetCmdResp3>:
static uint32_t SDMMC_GetCmdResp3(SDIO_TypeDef *SDIOx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800340c:	4b11      	ldr	r3, [pc, #68]	; (8003454 <SDMMC_GetCmdResp3+0x48>)
 800340e:	681b      	ldr	r3, [r3, #0]
 8003410:	4a11      	ldr	r2, [pc, #68]	; (8003458 <SDMMC_GetCmdResp3+0x4c>)
 8003412:	fba2 2303 	umull	r2, r3, r2, r3
 8003416:	0a5a      	lsrs	r2, r3, #9
 8003418:	f241 3388 	movw	r3, #5000	; 0x1388
 800341c:	fb03 f302 	mul.w	r3, r3, r2
  
  do
  {
    if (count-- == 0U)
 8003420:	1e5a      	subs	r2, r3, #1
 8003422:	b19b      	cbz	r3, 800344c <SDMMC_GetCmdResp3+0x40>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDIOx->STA;
 8003424:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8003426:	4613      	mov	r3, r2
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 8003428:	f011 0f45 	tst.w	r1, #69	; 0x45
 800342c:	d0f8      	beq.n	8003420 <SDMMC_GetCmdResp3+0x14>
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 800342e:	f411 6f00 	tst.w	r1, #2048	; 0x800
 8003432:	d1f5      	bne.n	8003420 <SDMMC_GetCmdResp3+0x14>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8003434:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003436:	f013 0f04 	tst.w	r3, #4
 800343a:	d003      	beq.n	8003444 <SDMMC_GetCmdResp3+0x38>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 800343c:	2304      	movs	r3, #4
 800343e:	6383      	str	r3, [r0, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8003440:	4618      	mov	r0, r3
 8003442:	4770      	bx	lr
  }
  else
  {  
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 8003444:	23c5      	movs	r3, #197	; 0xc5
 8003446:	6383      	str	r3, [r0, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 8003448:	2000      	movs	r0, #0
 800344a:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 800344c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8003450:	4770      	bx	lr
 8003452:	bf00      	nop
 8003454:	20000124 	.word	0x20000124
 8003458:	10624dd3 	.word	0x10624dd3

0800345c <SDMMC_GetCmdResp7>:
static uint32_t SDMMC_GetCmdResp7(SDIO_TypeDef *SDIOx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800345c:	4b18      	ldr	r3, [pc, #96]	; (80034c0 <SDMMC_GetCmdResp7+0x64>)
 800345e:	681b      	ldr	r3, [r3, #0]
 8003460:	4a18      	ldr	r2, [pc, #96]	; (80034c4 <SDMMC_GetCmdResp7+0x68>)
 8003462:	fba2 2303 	umull	r2, r3, r2, r3
 8003466:	0a5a      	lsrs	r2, r3, #9
 8003468:	f241 3388 	movw	r3, #5000	; 0x1388
 800346c:	fb03 f302 	mul.w	r3, r3, r2
  
  do
  {
    if (count-- == 0U)
 8003470:	1e5a      	subs	r2, r3, #1
 8003472:	b1fb      	cbz	r3, 80034b4 <SDMMC_GetCmdResp7+0x58>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDIOx->STA;
 8003474:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8003476:	4613      	mov	r3, r2
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 8003478:	f011 0f45 	tst.w	r1, #69	; 0x45
 800347c:	d0f8      	beq.n	8003470 <SDMMC_GetCmdResp7+0x14>
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 800347e:	f411 6f00 	tst.w	r1, #2048	; 0x800
 8003482:	d1f5      	bne.n	8003470 <SDMMC_GetCmdResp7+0x14>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8003484:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003486:	f013 0f04 	tst.w	r3, #4
 800348a:	d003      	beq.n	8003494 <SDMMC_GetCmdResp7+0x38>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 800348c:	2304      	movs	r3, #4
 800348e:	6383      	str	r3, [r0, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8003490:	4618      	mov	r0, r3
 8003492:	4770      	bx	lr
  }
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 8003494:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003496:	f013 0f01 	tst.w	r3, #1
 800349a:	d107      	bne.n	80034ac <SDMMC_GetCmdResp7+0x50>
  else
  {
    /* Nothing to do */
  }
  
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDREND))
 800349c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800349e:	f013 0f40 	tst.w	r3, #64	; 0x40
 80034a2:	d00a      	beq.n	80034ba <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
 80034a4:	2340      	movs	r3, #64	; 0x40
 80034a6:	6383      	str	r3, [r0, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 80034a8:	2000      	movs	r0, #0
 80034aa:	4770      	bx	lr
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80034ac:	2301      	movs	r3, #1
 80034ae:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80034b0:	4618      	mov	r0, r3
 80034b2:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 80034b4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80034b8:	4770      	bx	lr
  return SDMMC_ERROR_NONE;
 80034ba:	2000      	movs	r0, #0
  
}
 80034bc:	4770      	bx	lr
 80034be:	bf00      	nop
 80034c0:	20000124 	.word	0x20000124
 80034c4:	10624dd3 	.word	0x10624dd3

080034c8 <SDIO_Init>:
{
 80034c8:	b084      	sub	sp, #16
 80034ca:	b410      	push	{r4}
 80034cc:	ac02      	add	r4, sp, #8
 80034ce:	e884 000e 	stmia.w	r4, {r1, r2, r3}
             Init.ClockBypass         |\
 80034d2:	9a03      	ldr	r2, [sp, #12]
  tmpreg |= (Init.ClockEdge           |\
 80034d4:	460b      	mov	r3, r1
 80034d6:	4313      	orrs	r3, r2
             Init.ClockPowerSave      |\
 80034d8:	9a04      	ldr	r2, [sp, #16]
             Init.ClockBypass         |\
 80034da:	4313      	orrs	r3, r2
             Init.BusWide             |\
 80034dc:	9a05      	ldr	r2, [sp, #20]
             Init.ClockPowerSave      |\
 80034de:	4313      	orrs	r3, r2
             Init.HardwareFlowControl |\
 80034e0:	9a06      	ldr	r2, [sp, #24]
             Init.BusWide             |\
 80034e2:	4313      	orrs	r3, r2
             Init.ClockDiv
 80034e4:	9a07      	ldr	r2, [sp, #28]
             Init.HardwareFlowControl |\
 80034e6:	4313      	orrs	r3, r2
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80034e8:	6842      	ldr	r2, [r0, #4]
 80034ea:	f422 42fd 	bic.w	r2, r2, #32384	; 0x7e80
 80034ee:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 80034f2:	4313      	orrs	r3, r2
 80034f4:	6043      	str	r3, [r0, #4]
}
 80034f6:	2000      	movs	r0, #0
 80034f8:	bc10      	pop	{r4}
 80034fa:	b004      	add	sp, #16
 80034fc:	4770      	bx	lr

080034fe <SDIO_ReadFIFO>:
  return (SDIOx->FIFO);
 80034fe:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 8003502:	4770      	bx	lr

08003504 <SDIO_WriteFIFO>:
  SDIOx->FIFO = *pWriteData;
 8003504:	680b      	ldr	r3, [r1, #0]
 8003506:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
 800350a:	2000      	movs	r0, #0
 800350c:	4770      	bx	lr

0800350e <SDIO_PowerState_ON>:
{  
 800350e:	b508      	push	{r3, lr}
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8003510:	2303      	movs	r3, #3
 8003512:	6003      	str	r3, [r0, #0]
  HAL_Delay(2);
 8003514:	2002      	movs	r0, #2
 8003516:	f7fc fed7 	bl	80002c8 <HAL_Delay>
}
 800351a:	2000      	movs	r0, #0
 800351c:	bd08      	pop	{r3, pc}

0800351e <SDIO_GetPowerState>:
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 800351e:	6800      	ldr	r0, [r0, #0]
}
 8003520:	f000 0003 	and.w	r0, r0, #3
 8003524:	4770      	bx	lr

08003526 <SDIO_SendCommand>:
  SDIOx->ARG = Command->Argument;
 8003526:	680b      	ldr	r3, [r1, #0]
 8003528:	6083      	str	r3, [r0, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 800352a:	684b      	ldr	r3, [r1, #4]
                       Command->Response         |\
 800352c:	688a      	ldr	r2, [r1, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 800352e:	4313      	orrs	r3, r2
                       Command->WaitForInterrupt |\
 8003530:	68ca      	ldr	r2, [r1, #12]
                       Command->Response         |\
 8003532:	4313      	orrs	r3, r2
                       Command->CPSM);
 8003534:	690a      	ldr	r2, [r1, #16]
                       Command->WaitForInterrupt |\
 8003536:	4313      	orrs	r3, r2
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8003538:	68c2      	ldr	r2, [r0, #12]
 800353a:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 800353e:	f022 020f 	bic.w	r2, r2, #15
 8003542:	4313      	orrs	r3, r2
 8003544:	60c3      	str	r3, [r0, #12]
}
 8003546:	2000      	movs	r0, #0
 8003548:	4770      	bx	lr

0800354a <SDIO_GetCommandResponse>:
  return (uint8_t)(SDIOx->RESPCMD);
 800354a:	6900      	ldr	r0, [r0, #16]
}
 800354c:	b2c0      	uxtb	r0, r0
 800354e:	4770      	bx	lr

08003550 <SDIO_GetResponse>:
  tmp = (uint32_t)(&(SDIOx->RESP1)) + Response;
 8003550:	3014      	adds	r0, #20
  return (*(__IO uint32_t *) tmp);
 8003552:	5840      	ldr	r0, [r0, r1]
}  
 8003554:	4770      	bx	lr
	...

08003558 <SDMMC_GetCmdResp1>:
{
 8003558:	b538      	push	{r3, r4, r5, lr}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800355a:	4b52      	ldr	r3, [pc, #328]	; (80036a4 <SDMMC_GetCmdResp1+0x14c>)
 800355c:	681b      	ldr	r3, [r3, #0]
 800355e:	4c52      	ldr	r4, [pc, #328]	; (80036a8 <SDMMC_GetCmdResp1+0x150>)
 8003560:	fba4 4303 	umull	r4, r3, r4, r3
 8003564:	0a5b      	lsrs	r3, r3, #9
 8003566:	fb02 f203 	mul.w	r2, r2, r3
    if (count-- == 0U)
 800356a:	1e53      	subs	r3, r2, #1
 800356c:	2a00      	cmp	r2, #0
 800356e:	d062      	beq.n	8003636 <SDMMC_GetCmdResp1+0xde>
    sta_reg = SDIOx->STA;
 8003570:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003572:	461a      	mov	r2, r3
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 8003574:	f014 0f45 	tst.w	r4, #69	; 0x45
 8003578:	d0f7      	beq.n	800356a <SDMMC_GetCmdResp1+0x12>
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 800357a:	f414 6f00 	tst.w	r4, #2048	; 0x800
 800357e:	d1f4      	bne.n	800356a <SDMMC_GetCmdResp1+0x12>
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8003580:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003582:	f013 0f04 	tst.w	r3, #4
 8003586:	d003      	beq.n	8003590 <SDMMC_GetCmdResp1+0x38>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 8003588:	2304      	movs	r3, #4
 800358a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800358c:	4618      	mov	r0, r3
 800358e:	bd38      	pop	{r3, r4, r5, pc}
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 8003590:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003592:	f013 0f01 	tst.w	r3, #1
 8003596:	d003      	beq.n	80035a0 <SDMMC_GetCmdResp1+0x48>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 8003598:	2301      	movs	r3, #1
 800359a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800359c:	4618      	mov	r0, r3
 800359e:	bd38      	pop	{r3, r4, r5, pc}
 80035a0:	460d      	mov	r5, r1
 80035a2:	4604      	mov	r4, r0
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 80035a4:	23c5      	movs	r3, #197	; 0xc5
 80035a6:	6383      	str	r3, [r0, #56]	; 0x38
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 80035a8:	f7ff ffcf 	bl	800354a <SDIO_GetCommandResponse>
 80035ac:	42a8      	cmp	r0, r5
 80035ae:	d001      	beq.n	80035b4 <SDMMC_GetCmdResp1+0x5c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80035b0:	2001      	movs	r0, #1
 80035b2:	bd38      	pop	{r3, r4, r5, pc}
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 80035b4:	2100      	movs	r1, #0
 80035b6:	4620      	mov	r0, r4
 80035b8:	f7ff ffca 	bl	8003550 <SDIO_GetResponse>
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 80035bc:	4b3b      	ldr	r3, [pc, #236]	; (80036ac <SDMMC_GetCmdResp1+0x154>)
 80035be:	4003      	ands	r3, r0
 80035c0:	b3e3      	cbz	r3, 800363c <SDMMC_GetCmdResp1+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 80035c2:	2800      	cmp	r0, #0
 80035c4:	db3c      	blt.n	8003640 <SDMMC_GetCmdResp1+0xe8>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 80035c6:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 80035ca:	d13c      	bne.n	8003646 <SDMMC_GetCmdResp1+0xee>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 80035cc:	f010 5f00 	tst.w	r0, #536870912	; 0x20000000
 80035d0:	d001      	beq.n	80035d6 <SDMMC_GetCmdResp1+0x7e>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 80035d2:	2080      	movs	r0, #128	; 0x80
 80035d4:	bd38      	pop	{r3, r4, r5, pc}
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 80035d6:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
 80035da:	d136      	bne.n	800364a <SDMMC_GetCmdResp1+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 80035dc:	f010 6f00 	tst.w	r0, #134217728	; 0x8000000
 80035e0:	d136      	bne.n	8003650 <SDMMC_GetCmdResp1+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 80035e2:	f010 6f80 	tst.w	r0, #67108864	; 0x4000000
 80035e6:	d136      	bne.n	8003656 <SDMMC_GetCmdResp1+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 80035e8:	f010 7f80 	tst.w	r0, #16777216	; 0x1000000
 80035ec:	d136      	bne.n	800365c <SDMMC_GetCmdResp1+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 80035ee:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80035f2:	d136      	bne.n	8003662 <SDMMC_GetCmdResp1+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 80035f4:	f410 0f80 	tst.w	r0, #4194304	; 0x400000
 80035f8:	d136      	bne.n	8003668 <SDMMC_GetCmdResp1+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 80035fa:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
 80035fe:	d136      	bne.n	800366e <SDMMC_GetCmdResp1+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8003600:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8003604:	d136      	bne.n	8003674 <SDMMC_GetCmdResp1+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8003606:	f410 2f80 	tst.w	r0, #262144	; 0x40000
 800360a:	d136      	bne.n	800367a <SDMMC_GetCmdResp1+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800360c:	f410 3f00 	tst.w	r0, #131072	; 0x20000
 8003610:	d136      	bne.n	8003680 <SDMMC_GetCmdResp1+0x128>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8003612:	f410 3f80 	tst.w	r0, #65536	; 0x10000
 8003616:	d136      	bne.n	8003686 <SDMMC_GetCmdResp1+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8003618:	f410 4f00 	tst.w	r0, #32768	; 0x8000
 800361c:	d136      	bne.n	800368c <SDMMC_GetCmdResp1+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800361e:	f410 4f80 	tst.w	r0, #16384	; 0x4000
 8003622:	d136      	bne.n	8003692 <SDMMC_GetCmdResp1+0x13a>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8003624:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8003628:	d136      	bne.n	8003698 <SDMMC_GetCmdResp1+0x140>
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 800362a:	f010 0f08 	tst.w	r0, #8
 800362e:	d036      	beq.n	800369e <SDMMC_GetCmdResp1+0x146>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 8003630:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8003634:	bd38      	pop	{r3, r4, r5, pc}
      return SDMMC_ERROR_TIMEOUT;
 8003636:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800363a:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_NONE;
 800363c:	2000      	movs	r0, #0
 800363e:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8003640:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8003644:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8003646:	2040      	movs	r0, #64	; 0x40
 8003648:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800364a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800364e:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8003650:	f44f 7000 	mov.w	r0, #512	; 0x200
 8003654:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8003656:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800365a:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800365c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8003660:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_COM_CRC_FAILED;
 8003662:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003666:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_ILLEGAL_CMD;
 8003668:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800366c:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800366e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003672:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_CC_ERR;
 8003674:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8003678:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800367a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800367e:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8003680:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8003684:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8003686:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800368a:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800368c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003690:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8003692:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003696:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_ERASE_RESET;
 8003698:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800369c:	bd38      	pop	{r3, r4, r5, pc}
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800369e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
}
 80036a2:	bd38      	pop	{r3, r4, r5, pc}
 80036a4:	20000124 	.word	0x20000124
 80036a8:	10624dd3 	.word	0x10624dd3
 80036ac:	fdffe008 	.word	0xfdffe008

080036b0 <SDMMC_GetCmdResp6>:
{
 80036b0:	b570      	push	{r4, r5, r6, lr}
  register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80036b2:	4b26      	ldr	r3, [pc, #152]	; (800374c <SDMMC_GetCmdResp6+0x9c>)
 80036b4:	681b      	ldr	r3, [r3, #0]
 80036b6:	4c26      	ldr	r4, [pc, #152]	; (8003750 <SDMMC_GetCmdResp6+0xa0>)
 80036b8:	fba4 4303 	umull	r4, r3, r4, r3
 80036bc:	0a5c      	lsrs	r4, r3, #9
 80036be:	f241 3388 	movw	r3, #5000	; 0x1388
 80036c2:	fb03 f304 	mul.w	r3, r3, r4
    if (count-- == 0U)
 80036c6:	1e5c      	subs	r4, r3, #1
 80036c8:	2b00      	cmp	r3, #0
 80036ca:	d039      	beq.n	8003740 <SDMMC_GetCmdResp6+0x90>
    sta_reg = SDIOx->STA;
 80036cc:	6b45      	ldr	r5, [r0, #52]	; 0x34
 80036ce:	4623      	mov	r3, r4
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 80036d0:	f015 0f45 	tst.w	r5, #69	; 0x45
 80036d4:	d0f7      	beq.n	80036c6 <SDMMC_GetCmdResp6+0x16>
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 80036d6:	f415 6f00 	tst.w	r5, #2048	; 0x800
 80036da:	d1f4      	bne.n	80036c6 <SDMMC_GetCmdResp6+0x16>
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80036dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80036de:	f013 0f04 	tst.w	r3, #4
 80036e2:	d003      	beq.n	80036ec <SDMMC_GetCmdResp6+0x3c>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80036e4:	2304      	movs	r3, #4
 80036e6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80036e8:	4618      	mov	r0, r3
 80036ea:	bd70      	pop	{r4, r5, r6, pc}
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 80036ec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80036ee:	f013 0f01 	tst.w	r3, #1
 80036f2:	d003      	beq.n	80036fc <SDMMC_GetCmdResp6+0x4c>
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80036f4:	2301      	movs	r3, #1
 80036f6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80036f8:	4618      	mov	r0, r3
 80036fa:	bd70      	pop	{r4, r5, r6, pc}
 80036fc:	4616      	mov	r6, r2
 80036fe:	460d      	mov	r5, r1
 8003700:	4604      	mov	r4, r0
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 8003702:	f7ff ff22 	bl	800354a <SDIO_GetCommandResponse>
 8003706:	42a8      	cmp	r0, r5
 8003708:	d001      	beq.n	800370e <SDMMC_GetCmdResp6+0x5e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800370a:	2001      	movs	r0, #1
 800370c:	bd70      	pop	{r4, r5, r6, pc}
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 800370e:	23c5      	movs	r3, #197	; 0xc5
 8003710:	63a3      	str	r3, [r4, #56]	; 0x38
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 8003712:	2100      	movs	r1, #0
 8003714:	4620      	mov	r0, r4
 8003716:	f7ff ff1b 	bl	8003550 <SDIO_GetResponse>
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800371a:	f410 4f60 	tst.w	r0, #57344	; 0xe000
 800371e:	d005      	beq.n	800372c <SDMMC_GetCmdResp6+0x7c>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 8003720:	f410 4f80 	tst.w	r0, #16384	; 0x4000
 8003724:	d006      	beq.n	8003734 <SDMMC_GetCmdResp6+0x84>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8003726:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800372a:	bd70      	pop	{r4, r5, r6, pc}
    *pRCA = (uint16_t) (response_r1 >> 16);
 800372c:	0c00      	lsrs	r0, r0, #16
 800372e:	8030      	strh	r0, [r6, #0]
    return SDMMC_ERROR_NONE;
 8003730:	2000      	movs	r0, #0
 8003732:	bd70      	pop	{r4, r5, r6, pc}
  else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
 8003734:	f410 4f00 	tst.w	r0, #32768	; 0x8000
 8003738:	d005      	beq.n	8003746 <SDMMC_GetCmdResp6+0x96>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800373a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800373e:	bd70      	pop	{r4, r5, r6, pc}
      return SDMMC_ERROR_TIMEOUT;
 8003740:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8003744:	bd70      	pop	{r4, r5, r6, pc}
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8003746:	f44f 3080 	mov.w	r0, #65536	; 0x10000
}
 800374a:	bd70      	pop	{r4, r5, r6, pc}
 800374c:	20000124 	.word	0x20000124
 8003750:	10624dd3 	.word	0x10624dd3

08003754 <SDIO_ConfigData>:
  SDIOx->DTIMER = Data->DataTimeOut;
 8003754:	680b      	ldr	r3, [r1, #0]
 8003756:	6243      	str	r3, [r0, #36]	; 0x24
  SDIOx->DLEN = Data->DataLength;
 8003758:	684b      	ldr	r3, [r1, #4]
 800375a:	6283      	str	r3, [r0, #40]	; 0x28
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 800375c:	688b      	ldr	r3, [r1, #8]
                       Data->TransferDir   |\
 800375e:	68ca      	ldr	r2, [r1, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 8003760:	4313      	orrs	r3, r2
                       Data->TransferMode  |\
 8003762:	690a      	ldr	r2, [r1, #16]
                       Data->TransferDir   |\
 8003764:	4313      	orrs	r3, r2
                       Data->DPSM);
 8003766:	694a      	ldr	r2, [r1, #20]
                       Data->TransferMode  |\
 8003768:	4313      	orrs	r3, r2
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800376a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800376c:	f022 02f7 	bic.w	r2, r2, #247	; 0xf7
 8003770:	4313      	orrs	r3, r2
 8003772:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8003774:	2000      	movs	r0, #0
 8003776:	4770      	bx	lr

08003778 <SDMMC_CmdBlockLength>:
{
 8003778:	b530      	push	{r4, r5, lr}
 800377a:	b087      	sub	sp, #28
 800377c:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 800377e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 8003780:	2410      	movs	r4, #16
 8003782:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003784:	2340      	movs	r3, #64	; 0x40
 8003786:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003788:	2300      	movs	r3, #0
 800378a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800378c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003790:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003792:	a901      	add	r1, sp, #4
 8003794:	f7ff fec7 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SET_BLOCKLEN, SDIO_CMDTIMEOUT);
 8003798:	f241 3288 	movw	r2, #5000	; 0x1388
 800379c:	4621      	mov	r1, r4
 800379e:	4628      	mov	r0, r5
 80037a0:	f7ff feda 	bl	8003558 <SDMMC_GetCmdResp1>
}
 80037a4:	b007      	add	sp, #28
 80037a6:	bd30      	pop	{r4, r5, pc}

080037a8 <SDMMC_CmdReadSingleBlock>:
{
 80037a8:	b530      	push	{r4, r5, lr}
 80037aa:	b087      	sub	sp, #28
 80037ac:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 80037ae:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 80037b0:	2411      	movs	r4, #17
 80037b2:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80037b4:	2340      	movs	r3, #64	; 0x40
 80037b6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80037b8:	2300      	movs	r3, #0
 80037ba:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80037bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80037c0:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037c2:	a901      	add	r1, sp, #4
 80037c4:	f7ff feaf 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 80037c8:	f241 3288 	movw	r2, #5000	; 0x1388
 80037cc:	4621      	mov	r1, r4
 80037ce:	4628      	mov	r0, r5
 80037d0:	f7ff fec2 	bl	8003558 <SDMMC_GetCmdResp1>
}
 80037d4:	b007      	add	sp, #28
 80037d6:	bd30      	pop	{r4, r5, pc}

080037d8 <SDMMC_CmdReadMultiBlock>:
{
 80037d8:	b530      	push	{r4, r5, lr}
 80037da:	b087      	sub	sp, #28
 80037dc:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 80037de:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 80037e0:	2412      	movs	r4, #18
 80037e2:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80037e4:	2340      	movs	r3, #64	; 0x40
 80037e6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80037e8:	2300      	movs	r3, #0
 80037ea:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80037ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80037f0:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80037f2:	a901      	add	r1, sp, #4
 80037f4:	f7ff fe97 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_MULT_BLOCK, SDIO_CMDTIMEOUT);
 80037f8:	f241 3288 	movw	r2, #5000	; 0x1388
 80037fc:	4621      	mov	r1, r4
 80037fe:	4628      	mov	r0, r5
 8003800:	f7ff feaa 	bl	8003558 <SDMMC_GetCmdResp1>
}
 8003804:	b007      	add	sp, #28
 8003806:	bd30      	pop	{r4, r5, pc}

08003808 <SDMMC_CmdWriteSingleBlock>:
{
 8003808:	b530      	push	{r4, r5, lr}
 800380a:	b087      	sub	sp, #28
 800380c:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800380e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 8003810:	2418      	movs	r4, #24
 8003812:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003814:	2340      	movs	r3, #64	; 0x40
 8003816:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003818:	2300      	movs	r3, #0
 800381a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800381c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003820:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003822:	a901      	add	r1, sp, #4
 8003824:	f7ff fe7f 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 8003828:	f241 3288 	movw	r2, #5000	; 0x1388
 800382c:	4621      	mov	r1, r4
 800382e:	4628      	mov	r0, r5
 8003830:	f7ff fe92 	bl	8003558 <SDMMC_GetCmdResp1>
}
 8003834:	b007      	add	sp, #28
 8003836:	bd30      	pop	{r4, r5, pc}

08003838 <SDMMC_CmdWriteMultiBlock>:
{
 8003838:	b530      	push	{r4, r5, lr}
 800383a:	b087      	sub	sp, #28
 800383c:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800383e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8003840:	2419      	movs	r4, #25
 8003842:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003844:	2340      	movs	r3, #64	; 0x40
 8003846:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003848:	2300      	movs	r3, #0
 800384a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800384c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003850:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003852:	a901      	add	r1, sp, #4
 8003854:	f7ff fe67 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_MULT_BLOCK, SDIO_CMDTIMEOUT);
 8003858:	f241 3288 	movw	r2, #5000	; 0x1388
 800385c:	4621      	mov	r1, r4
 800385e:	4628      	mov	r0, r5
 8003860:	f7ff fe7a 	bl	8003558 <SDMMC_GetCmdResp1>
}
 8003864:	b007      	add	sp, #28
 8003866:	bd30      	pop	{r4, r5, pc}

08003868 <SDMMC_CmdStopTransfer>:
{
 8003868:	b530      	push	{r4, r5, lr}
 800386a:	b087      	sub	sp, #28
 800386c:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = 0U;
 800386e:	2300      	movs	r3, #0
 8003870:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8003872:	240c      	movs	r4, #12
 8003874:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003876:	2240      	movs	r2, #64	; 0x40
 8003878:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 800387a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800387c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003880:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003882:	a901      	add	r1, sp, #4
 8003884:	f7ff fe4f 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_STOP_TRANSMISSION, SDIO_STOPTRANSFERTIMEOUT);
 8003888:	4a03      	ldr	r2, [pc, #12]	; (8003898 <SDMMC_CmdStopTransfer+0x30>)
 800388a:	4621      	mov	r1, r4
 800388c:	4628      	mov	r0, r5
 800388e:	f7ff fe63 	bl	8003558 <SDMMC_GetCmdResp1>
}
 8003892:	b007      	add	sp, #28
 8003894:	bd30      	pop	{r4, r5, pc}
 8003896:	bf00      	nop
 8003898:	05f5e100 	.word	0x05f5e100

0800389c <SDMMC_CmdSelDesel>:
{
 800389c:	b530      	push	{r4, r5, lr}
 800389e:	b087      	sub	sp, #28
 80038a0:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 80038a2:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 80038a4:	2407      	movs	r4, #7
 80038a6:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80038a8:	2340      	movs	r3, #64	; 0x40
 80038aa:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80038ac:	2300      	movs	r3, #0
 80038ae:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80038b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80038b4:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80038b6:	a901      	add	r1, sp, #4
 80038b8:	f7ff fe35 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEL_DESEL_CARD, SDIO_CMDTIMEOUT);
 80038bc:	f241 3288 	movw	r2, #5000	; 0x1388
 80038c0:	4621      	mov	r1, r4
 80038c2:	4628      	mov	r0, r5
 80038c4:	f7ff fe48 	bl	8003558 <SDMMC_GetCmdResp1>
}
 80038c8:	b007      	add	sp, #28
 80038ca:	bd30      	pop	{r4, r5, pc}

080038cc <SDMMC_CmdGoIdleState>:
{
 80038cc:	b510      	push	{r4, lr}
 80038ce:	b086      	sub	sp, #24
 80038d0:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0U;
 80038d2:	2300      	movs	r3, #0
 80038d4:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 80038d6:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_NO;
 80038d8:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80038da:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80038dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80038e0:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80038e2:	a901      	add	r1, sp, #4
 80038e4:	f7ff fe1f 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdError(SDIOx);
 80038e8:	4620      	mov	r0, r4
 80038ea:	f7ff fd43 	bl	8003374 <SDMMC_GetCmdError>
}
 80038ee:	b006      	add	sp, #24
 80038f0:	bd10      	pop	{r4, pc}

080038f2 <SDMMC_CmdOperCond>:
{
 80038f2:	b510      	push	{r4, lr}
 80038f4:	b086      	sub	sp, #24
 80038f6:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 80038f8:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 80038fc:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 80038fe:	2308      	movs	r3, #8
 8003900:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003902:	2340      	movs	r3, #64	; 0x40
 8003904:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003906:	2300      	movs	r3, #0
 8003908:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800390a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800390e:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003910:	a901      	add	r1, sp, #4
 8003912:	f7ff fe08 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp7(SDIOx);
 8003916:	4620      	mov	r0, r4
 8003918:	f7ff fda0 	bl	800345c <SDMMC_GetCmdResp7>
}
 800391c:	b006      	add	sp, #24
 800391e:	bd10      	pop	{r4, pc}

08003920 <SDMMC_CmdAppCommand>:
{
 8003920:	b530      	push	{r4, r5, lr}
 8003922:	b087      	sub	sp, #28
 8003924:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 8003926:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 8003928:	2437      	movs	r4, #55	; 0x37
 800392a:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800392c:	2340      	movs	r3, #64	; 0x40
 800392e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003930:	2300      	movs	r3, #0
 8003932:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003934:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003938:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800393a:	a901      	add	r1, sp, #4
 800393c:	f7ff fdf3 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_CMD, SDIO_CMDTIMEOUT);
 8003940:	f241 3288 	movw	r2, #5000	; 0x1388
 8003944:	4621      	mov	r1, r4
 8003946:	4628      	mov	r0, r5
 8003948:	f7ff fe06 	bl	8003558 <SDMMC_GetCmdResp1>
}
 800394c:	b007      	add	sp, #28
 800394e:	bd30      	pop	{r4, r5, pc}

08003950 <SDMMC_CmdAppOperCommand>:
{
 8003950:	b510      	push	{r4, lr}
 8003952:	b086      	sub	sp, #24
 8003954:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 8003956:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 800395a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800395e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 8003960:	2329      	movs	r3, #41	; 0x29
 8003962:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003964:	2340      	movs	r3, #64	; 0x40
 8003966:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003968:	2300      	movs	r3, #0
 800396a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 800396c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003970:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003972:	a901      	add	r1, sp, #4
 8003974:	f7ff fdd7 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp3(SDIOx);
 8003978:	4620      	mov	r0, r4
 800397a:	f7ff fd47 	bl	800340c <SDMMC_GetCmdResp3>
}
 800397e:	b006      	add	sp, #24
 8003980:	bd10      	pop	{r4, pc}

08003982 <SDMMC_CmdBusWidth>:
{
 8003982:	b530      	push	{r4, r5, lr}
 8003984:	b087      	sub	sp, #28
 8003986:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
 8003988:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
 800398a:	2406      	movs	r4, #6
 800398c:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 800398e:	2340      	movs	r3, #64	; 0x40
 8003990:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003992:	2300      	movs	r3, #0
 8003994:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003996:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800399a:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 800399c:	a901      	add	r1, sp, #4
 800399e:	f7ff fdc2 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDIO_CMDTIMEOUT);
 80039a2:	f241 3288 	movw	r2, #5000	; 0x1388
 80039a6:	4621      	mov	r1, r4
 80039a8:	4628      	mov	r0, r5
 80039aa:	f7ff fdd5 	bl	8003558 <SDMMC_GetCmdResp1>
}
 80039ae:	b007      	add	sp, #28
 80039b0:	bd30      	pop	{r4, r5, pc}

080039b2 <SDMMC_CmdSendSCR>:
{
 80039b2:	b530      	push	{r4, r5, lr}
 80039b4:	b087      	sub	sp, #28
 80039b6:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = 0U;
 80039b8:	2300      	movs	r3, #0
 80039ba:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 80039bc:	2433      	movs	r4, #51	; 0x33
 80039be:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80039c0:	2240      	movs	r2, #64	; 0x40
 80039c2:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80039c4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80039c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80039ca:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80039cc:	a901      	add	r1, sp, #4
 80039ce:	f7ff fdaa 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_SEND_SCR, SDIO_CMDTIMEOUT);
 80039d2:	f241 3288 	movw	r2, #5000	; 0x1388
 80039d6:	4621      	mov	r1, r4
 80039d8:	4628      	mov	r0, r5
 80039da:	f7ff fdbd 	bl	8003558 <SDMMC_GetCmdResp1>
}
 80039de:	b007      	add	sp, #28
 80039e0:	bd30      	pop	{r4, r5, pc}

080039e2 <SDMMC_CmdSendCID>:
{
 80039e2:	b510      	push	{r4, lr}
 80039e4:	b086      	sub	sp, #24
 80039e6:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0U;
 80039e8:	2300      	movs	r3, #0
 80039ea:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 80039ec:	2202      	movs	r2, #2
 80039ee:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 80039f0:	22c0      	movs	r2, #192	; 0xc0
 80039f2:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80039f4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80039f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80039fa:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80039fc:	a901      	add	r1, sp, #4
 80039fe:	f7ff fd92 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 8003a02:	4620      	mov	r0, r4
 8003a04:	f7ff fcd2 	bl	80033ac <SDMMC_GetCmdResp2>
}
 8003a08:	b006      	add	sp, #24
 8003a0a:	bd10      	pop	{r4, pc}

08003a0c <SDMMC_CmdSendCSD>:
{
 8003a0c:	b510      	push	{r4, lr}
 8003a0e:	b086      	sub	sp, #24
 8003a10:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
 8003a12:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 8003a14:	2309      	movs	r3, #9
 8003a16:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 8003a18:	23c0      	movs	r3, #192	; 0xc0
 8003a1a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003a1c:	2300      	movs	r3, #0
 8003a1e:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003a20:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003a24:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003a26:	a901      	add	r1, sp, #4
 8003a28:	f7ff fd7d 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 8003a2c:	4620      	mov	r0, r4
 8003a2e:	f7ff fcbd 	bl	80033ac <SDMMC_GetCmdResp2>
}
 8003a32:	b006      	add	sp, #24
 8003a34:	bd10      	pop	{r4, pc}

08003a36 <SDMMC_CmdSetRelAdd>:
{
 8003a36:	b570      	push	{r4, r5, r6, lr}
 8003a38:	b086      	sub	sp, #24
 8003a3a:	4605      	mov	r5, r0
 8003a3c:	460e      	mov	r6, r1
  sdmmc_cmdinit.Argument         = 0U;
 8003a3e:	2300      	movs	r3, #0
 8003a40:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 8003a42:	2403      	movs	r4, #3
 8003a44:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003a46:	2240      	movs	r2, #64	; 0x40
 8003a48:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003a4a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003a4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003a50:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003a52:	a901      	add	r1, sp, #4
 8003a54:	f7ff fd67 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp6(SDIOx, SDMMC_CMD_SET_REL_ADDR, pRCA);
 8003a58:	4632      	mov	r2, r6
 8003a5a:	4621      	mov	r1, r4
 8003a5c:	4628      	mov	r0, r5
 8003a5e:	f7ff fe27 	bl	80036b0 <SDMMC_GetCmdResp6>
}
 8003a62:	b006      	add	sp, #24
 8003a64:	bd70      	pop	{r4, r5, r6, pc}

08003a66 <SDMMC_CmdSendStatus>:
{
 8003a66:	b530      	push	{r4, r5, lr}
 8003a68:	b087      	sub	sp, #28
 8003a6a:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = Argument;
 8003a6c:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 8003a6e:	240d      	movs	r4, #13
 8003a70:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8003a72:	2340      	movs	r3, #64	; 0x40
 8003a74:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8003a76:	2300      	movs	r3, #0
 8003a78:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8003a7a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003a7e:	9305      	str	r3, [sp, #20]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8003a80:	a901      	add	r1, sp, #4
 8003a82:	f7ff fd50 	bl	8003526 <SDIO_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEND_STATUS, SDIO_CMDTIMEOUT);
 8003a86:	f241 3288 	movw	r2, #5000	; 0x1388
 8003a8a:	4621      	mov	r1, r4
 8003a8c:	4628      	mov	r0, r5
 8003a8e:	f7ff fd63 	bl	8003558 <SDMMC_GetCmdResp1>
}
 8003a92:	b007      	add	sp, #28
 8003a94:	bd30      	pop	{r4, r5, pc}

08003a96 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 8003a96:	b084      	sub	sp, #16
 8003a98:	a801      	add	r0, sp, #4
 8003a9a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 8003a9e:	2000      	movs	r0, #0
 8003aa0:	b004      	add	sp, #16
 8003aa2:	4770      	bx	lr

08003aa4 <USB_EnableGlobalInt>:
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM;

  /* Set interrupt mask */
  USBx->CNTR |= winterruptmask;
 8003aa4:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 8003aa8:	b29b      	uxth	r3, r3
 8003aaa:	f443 433f 	orr.w	r3, r3, #48896	; 0xbf00
 8003aae:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40

  return HAL_OK;
}
 8003ab2:	2000      	movs	r0, #0
 8003ab4:	4770      	bx	lr

08003ab6 <USB_DisableGlobalInt>:
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM;

  /* Clear interrupt mask */
  USBx->CNTR &= ~winterruptmask;
 8003ab6:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 8003aba:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8003abe:	045b      	lsls	r3, r3, #17
 8003ac0:	0c5b      	lsrs	r3, r3, #17
 8003ac2:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40

  return HAL_OK;
}
 8003ac6:	2000      	movs	r0, #0
 8003ac8:	4770      	bx	lr

08003aca <USB_SetCurrentMode>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 8003aca:	2000      	movs	r0, #0
 8003acc:	4770      	bx	lr

08003ace <USB_DevInit>:
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 8003ace:	b084      	sub	sp, #16
 8003ad0:	b538      	push	{r3, r4, r5, lr}
 8003ad2:	ac05      	add	r4, sp, #20
 8003ad4:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = USB_CNTR_FRES;
 8003ad8:	2301      	movs	r3, #1
 8003ada:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40

  /*CNTR_FRES = 0*/
  USBx->CNTR = 0;
 8003ade:	2400      	movs	r4, #0
 8003ae0:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40

  /*Clear pending interrupts*/
  USBx->ISTR = 0;
 8003ae4:	f8a0 4044 	strh.w	r4, [r0, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 8003ae8:	f8a0 4050 	strh.w	r4, [r0, #80]	; 0x50

  /* Enable USB Device Interrupt mask */
  (void)USB_EnableGlobalInt(USBx);
 8003aec:	f7ff ffda 	bl	8003aa4 <USB_EnableGlobalInt>

  return HAL_OK;
}
 8003af0:	4620      	mov	r0, r4
 8003af2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003af6:	b004      	add	sp, #16
 8003af8:	4770      	bx	lr

08003afa <USB_ActivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8003afa:	b430      	push	{r4, r5}
 8003afc:	4603      	mov	r3, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 8003afe:	780c      	ldrb	r4, [r1, #0]
 8003b00:	f830 2024 	ldrh.w	r2, [r0, r4, lsl #2]
 8003b04:	b292      	uxth	r2, r2
 8003b06:	f422 42ec 	bic.w	r2, r2, #30208	; 0x7600
 8003b0a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003b0e:	b292      	uxth	r2, r2

  /* initialize Endpoint */
  switch (ep->type)
 8003b10:	78c8      	ldrb	r0, [r1, #3]
 8003b12:	2803      	cmp	r0, #3
 8003b14:	d85c      	bhi.n	8003bd0 <USB_ActivateEndpoint+0xd6>
 8003b16:	e8df f000 	tbb	[pc, r0]
 8003b1a:	574f      	.short	0x574f
 8003b1c:	5302      	.short	0x5302
  HAL_StatusTypeDef ret = HAL_OK;
 8003b1e:	2000      	movs	r0, #0
    default:
      ret = HAL_ERROR;
      break;
  }

  PCD_SET_ENDPOINT(USBx, ep->num, wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX);
 8003b20:	f248 0580 	movw	r5, #32896	; 0x8080
 8003b24:	432a      	orrs	r2, r5
 8003b26:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 8003b2a:	780c      	ldrb	r4, [r1, #0]
 8003b2c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003b30:	b292      	uxth	r2, r2
 8003b32:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003b36:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003b3a:	4322      	orrs	r2, r4
 8003b3c:	432a      	orrs	r2, r5
 8003b3e:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]

  if (ep->doublebuffer == 0U)
 8003b42:	7b0a      	ldrb	r2, [r1, #12]
 8003b44:	2a00      	cmp	r2, #0
 8003b46:	f040 80b9 	bne.w	8003cbc <USB_ActivateEndpoint+0x1c2>
  {
    if (ep->is_in != 0U)
 8003b4a:	784a      	ldrb	r2, [r1, #1]
 8003b4c:	2a00      	cmp	r2, #0
 8003b4e:	d050      	beq.n	8003bf2 <USB_ActivateEndpoint+0xf8>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8003b50:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8003b54:	b292      	uxth	r2, r2
 8003b56:	441a      	add	r2, r3
 8003b58:	780c      	ldrb	r4, [r1, #0]
 8003b5a:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8003b5e:	88cc      	ldrh	r4, [r1, #6]
 8003b60:	f024 0401 	bic.w	r4, r4, #1
 8003b64:	b2a4      	uxth	r4, r4
 8003b66:	f8a2 4400 	strh.w	r4, [r2, #1024]	; 0x400
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003b6a:	780c      	ldrb	r4, [r1, #0]
 8003b6c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003b70:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003b74:	d00c      	beq.n	8003b90 <USB_ActivateEndpoint+0x96>
 8003b76:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003b7a:	b292      	uxth	r2, r2
 8003b7c:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003b80:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003b84:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003b88:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8003b8c:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]

      if (ep->type != EP_TYPE_ISOC)
 8003b90:	78ca      	ldrb	r2, [r1, #3]
 8003b92:	2a01      	cmp	r2, #1
 8003b94:	d01e      	beq.n	8003bd4 <USB_ActivateEndpoint+0xda>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8003b96:	7809      	ldrb	r1, [r1, #0]
 8003b98:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8003b9c:	b292      	uxth	r2, r2
 8003b9e:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003ba2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003ba6:	f082 0220 	eor.w	r2, r2, #32
 8003baa:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003bae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003bb2:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
 8003bb6:	e066      	b.n	8003c86 <USB_ActivateEndpoint+0x18c>
      wEpRegVal |= USB_EP_CONTROL;
 8003bb8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  HAL_StatusTypeDef ret = HAL_OK;
 8003bbc:	2000      	movs	r0, #0
      break;
 8003bbe:	e7af      	b.n	8003b20 <USB_ActivateEndpoint+0x26>
      wEpRegVal |= USB_EP_INTERRUPT;
 8003bc0:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
  HAL_StatusTypeDef ret = HAL_OK;
 8003bc4:	2000      	movs	r0, #0
      break;
 8003bc6:	e7ab      	b.n	8003b20 <USB_ActivateEndpoint+0x26>
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 8003bc8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  HAL_StatusTypeDef ret = HAL_OK;
 8003bcc:	2000      	movs	r0, #0
      break;
 8003bce:	e7a7      	b.n	8003b20 <USB_ActivateEndpoint+0x26>
      ret = HAL_ERROR;
 8003bd0:	2001      	movs	r0, #1
 8003bd2:	e7a5      	b.n	8003b20 <USB_ActivateEndpoint+0x26>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003bd4:	7809      	ldrb	r1, [r1, #0]
 8003bd6:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8003bda:	b292      	uxth	r2, r2
 8003bdc:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003be0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003be4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003be8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003bec:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
 8003bf0:	e049      	b.n	8003c86 <USB_ActivateEndpoint+0x18c>
      }
    }
    else
    {
      /*Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8003bf2:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8003bf6:	b292      	uxth	r2, r2
 8003bf8:	441a      	add	r2, r3
 8003bfa:	780c      	ldrb	r4, [r1, #0]
 8003bfc:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8003c00:	88cc      	ldrh	r4, [r1, #6]
 8003c02:	f024 0401 	bic.w	r4, r4, #1
 8003c06:	b2a4      	uxth	r4, r4
 8003c08:	f8a2 4408 	strh.w	r4, [r2, #1032]	; 0x408
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8003c0c:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8003c10:	b292      	uxth	r2, r2
 8003c12:	441a      	add	r2, r3
 8003c14:	780c      	ldrb	r4, [r1, #0]
 8003c16:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8003c1a:	690c      	ldr	r4, [r1, #16]
 8003c1c:	bbac      	cbnz	r4, 8003c8a <USB_ActivateEndpoint+0x190>
 8003c1e:	f8b2 440c 	ldrh.w	r4, [r2, #1036]	; 0x40c
 8003c22:	b2a4      	uxth	r4, r4
 8003c24:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 8003c28:	b2a4      	uxth	r4, r4
 8003c2a:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
 8003c2e:	f8b2 440c 	ldrh.w	r4, [r2, #1036]	; 0x40c
 8003c32:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8003c36:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8003c3a:	b2a4      	uxth	r4, r4
 8003c3c:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003c40:	780c      	ldrb	r4, [r1, #0]
 8003c42:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003c46:	f412 4f80 	tst.w	r2, #16384	; 0x4000
 8003c4a:	d00c      	beq.n	8003c66 <USB_ActivateEndpoint+0x16c>
 8003c4c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003c50:	b292      	uxth	r2, r2
 8003c52:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003c56:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003c5a:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003c5e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003c62:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003c66:	7809      	ldrb	r1, [r1, #0]
 8003c68:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8003c6c:	b292      	uxth	r2, r2
 8003c6e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003c72:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003c76:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 8003c7a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003c7e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003c82:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }

  return ret;
}
 8003c86:	bc30      	pop	{r4, r5}
 8003c88:	4770      	bx	lr
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8003c8a:	2c3e      	cmp	r4, #62	; 0x3e
 8003c8c:	d809      	bhi.n	8003ca2 <USB_ActivateEndpoint+0x1a8>
 8003c8e:	0865      	lsrs	r5, r4, #1
 8003c90:	f014 0f01 	tst.w	r4, #1
 8003c94:	d000      	beq.n	8003c98 <USB_ActivateEndpoint+0x19e>
 8003c96:	3501      	adds	r5, #1
 8003c98:	02ad      	lsls	r5, r5, #10
 8003c9a:	b2ad      	uxth	r5, r5
 8003c9c:	f8a2 540c 	strh.w	r5, [r2, #1036]	; 0x40c
 8003ca0:	e7ce      	b.n	8003c40 <USB_ActivateEndpoint+0x146>
 8003ca2:	0965      	lsrs	r5, r4, #5
 8003ca4:	f014 0f1f 	tst.w	r4, #31
 8003ca8:	d100      	bne.n	8003cac <USB_ActivateEndpoint+0x1b2>
 8003caa:	3d01      	subs	r5, #1
 8003cac:	ea6f 64c5 	mvn.w	r4, r5, lsl #27
 8003cb0:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8003cb4:	b2a4      	uxth	r4, r4
 8003cb6:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
 8003cba:	e7c1      	b.n	8003c40 <USB_ActivateEndpoint+0x146>
    PCD_SET_EP_DBUF(USBx, ep->num);
 8003cbc:	780c      	ldrb	r4, [r1, #0]
 8003cbe:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003cc2:	b292      	uxth	r2, r2
 8003cc4:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003cc8:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003ccc:	f442 4201 	orr.w	r2, r2, #33024	; 0x8100
 8003cd0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003cd4:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 8003cd8:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8003cdc:	b292      	uxth	r2, r2
 8003cde:	441a      	add	r2, r3
 8003ce0:	780c      	ldrb	r4, [r1, #0]
 8003ce2:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8003ce6:	890c      	ldrh	r4, [r1, #8]
 8003ce8:	f024 0401 	bic.w	r4, r4, #1
 8003cec:	b2a4      	uxth	r4, r4
 8003cee:	f8a2 4400 	strh.w	r4, [r2, #1024]	; 0x400
 8003cf2:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8003cf6:	b292      	uxth	r2, r2
 8003cf8:	441a      	add	r2, r3
 8003cfa:	780c      	ldrb	r4, [r1, #0]
 8003cfc:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 8003d00:	894c      	ldrh	r4, [r1, #10]
 8003d02:	f024 0401 	bic.w	r4, r4, #1
 8003d06:	b2a4      	uxth	r4, r4
 8003d08:	f8a2 4408 	strh.w	r4, [r2, #1032]	; 0x408
    if (ep->is_in == 0U)
 8003d0c:	784a      	ldrb	r2, [r1, #1]
 8003d0e:	2a00      	cmp	r2, #0
 8003d10:	d14e      	bne.n	8003db0 <USB_ActivateEndpoint+0x2b6>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003d12:	780c      	ldrb	r4, [r1, #0]
 8003d14:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003d18:	f412 4f80 	tst.w	r2, #16384	; 0x4000
 8003d1c:	d00c      	beq.n	8003d38 <USB_ActivateEndpoint+0x23e>
 8003d1e:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003d22:	b292      	uxth	r2, r2
 8003d24:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003d28:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003d2c:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003d30:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003d34:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003d38:	780c      	ldrb	r4, [r1, #0]
 8003d3a:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003d3e:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003d42:	d00c      	beq.n	8003d5e <USB_ActivateEndpoint+0x264>
 8003d44:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003d48:	b292      	uxth	r2, r2
 8003d4a:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003d4e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003d52:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003d56:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8003d5a:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_TX_DTOG(USBx, ep->num);
 8003d5e:	780c      	ldrb	r4, [r1, #0]
 8003d60:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003d64:	b292      	uxth	r2, r2
 8003d66:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003d6a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003d6e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003d72:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8003d76:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003d7a:	780d      	ldrb	r5, [r1, #0]
 8003d7c:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8003d80:	b292      	uxth	r2, r2
 8003d82:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003d86:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003d8a:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 8003d8e:	f248 0480 	movw	r4, #32896	; 0x8080
 8003d92:	4322      	orrs	r2, r4
 8003d94:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003d98:	7809      	ldrb	r1, [r1, #0]
 8003d9a:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8003d9e:	b292      	uxth	r2, r2
 8003da0:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003da4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003da8:	4322      	orrs	r2, r4
 8003daa:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
 8003dae:	e76a      	b.n	8003c86 <USB_ActivateEndpoint+0x18c>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003db0:	780c      	ldrb	r4, [r1, #0]
 8003db2:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003db6:	f412 4f80 	tst.w	r2, #16384	; 0x4000
 8003dba:	d00c      	beq.n	8003dd6 <USB_ActivateEndpoint+0x2dc>
 8003dbc:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003dc0:	b292      	uxth	r2, r2
 8003dc2:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003dc6:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003dca:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003dce:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003dd2:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003dd6:	780c      	ldrb	r4, [r1, #0]
 8003dd8:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003ddc:	f012 0f40 	tst.w	r2, #64	; 0x40
 8003de0:	d00c      	beq.n	8003dfc <USB_ActivateEndpoint+0x302>
 8003de2:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003de6:	b292      	uxth	r2, r2
 8003de8:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003dec:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003df0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003df4:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8003df8:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_RX_DTOG(USBx, ep->num);
 8003dfc:	780c      	ldrb	r4, [r1, #0]
 8003dfe:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003e02:	b292      	uxth	r2, r2
 8003e04:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003e08:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003e0c:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003e10:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003e14:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      if (ep->type != EP_TYPE_ISOC)
 8003e18:	78ca      	ldrb	r2, [r1, #3]
 8003e1a:	2a01      	cmp	r2, #1
 8003e1c:	d01e      	beq.n	8003e5c <USB_ActivateEndpoint+0x362>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8003e1e:	780c      	ldrb	r4, [r1, #0]
 8003e20:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003e24:	b292      	uxth	r2, r2
 8003e26:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003e2a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003e2e:	f082 0220 	eor.w	r2, r2, #32
 8003e32:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003e36:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003e3a:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8003e3e:	7809      	ldrb	r1, [r1, #0]
 8003e40:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8003e44:	b292      	uxth	r2, r2
 8003e46:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003e4a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003e4e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003e52:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003e56:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
 8003e5a:	e714      	b.n	8003c86 <USB_ActivateEndpoint+0x18c>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003e5c:	780c      	ldrb	r4, [r1, #0]
 8003e5e:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8003e62:	b292      	uxth	r2, r2
 8003e64:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8003e68:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003e6c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003e70:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003e74:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
 8003e78:	e7e1      	b.n	8003e3e <USB_ActivateEndpoint+0x344>

08003e7a <USB_DeactivateEndpoint>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0U)
 8003e7a:	7b0b      	ldrb	r3, [r1, #12]
 8003e7c:	2b00      	cmp	r3, #0
 8003e7e:	d146      	bne.n	8003f0e <USB_DeactivateEndpoint+0x94>
  {
    if (ep->is_in != 0U)
 8003e80:	784b      	ldrb	r3, [r1, #1]
 8003e82:	b313      	cbz	r3, 8003eca <USB_DeactivateEndpoint+0x50>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003e84:	780a      	ldrb	r2, [r1, #0]
 8003e86:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003e8a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003e8e:	d00c      	beq.n	8003eaa <USB_DeactivateEndpoint+0x30>
 8003e90:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003e94:	b29b      	uxth	r3, r3
 8003e96:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003e9a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003e9e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003ea2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003ea6:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003eaa:	780a      	ldrb	r2, [r1, #0]
 8003eac:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003eb0:	b29b      	uxth	r3, r3
 8003eb2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003eb6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003eba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003ebe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003ec2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }

  return HAL_OK;
}
 8003ec6:	2000      	movs	r0, #0
 8003ec8:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003eca:	780a      	ldrb	r2, [r1, #0]
 8003ecc:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003ed0:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8003ed4:	d00c      	beq.n	8003ef0 <USB_DeactivateEndpoint+0x76>
 8003ed6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003eda:	b29b      	uxth	r3, r3
 8003edc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003ee0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003ee4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003ee8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003eec:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8003ef0:	780a      	ldrb	r2, [r1, #0]
 8003ef2:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003ef6:	b29b      	uxth	r3, r3
 8003ef8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003efc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003f00:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003f04:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003f08:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8003f0c:	e7db      	b.n	8003ec6 <USB_DeactivateEndpoint+0x4c>
{
 8003f0e:	b410      	push	{r4}
    if (ep->is_in == 0U)
 8003f10:	784b      	ldrb	r3, [r1, #1]
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	d14e      	bne.n	8003fb4 <USB_DeactivateEndpoint+0x13a>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003f16:	780a      	ldrb	r2, [r1, #0]
 8003f18:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f1c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8003f20:	d00c      	beq.n	8003f3c <USB_DeactivateEndpoint+0xc2>
 8003f22:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f26:	b29b      	uxth	r3, r3
 8003f28:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003f2c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003f30:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003f34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003f38:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003f3c:	780a      	ldrb	r2, [r1, #0]
 8003f3e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f42:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003f46:	d00c      	beq.n	8003f62 <USB_DeactivateEndpoint+0xe8>
 8003f48:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f4c:	b29b      	uxth	r3, r3
 8003f4e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003f52:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003f56:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003f5a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003f5e:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_TX_DTOG(USBx, ep->num);
 8003f62:	780a      	ldrb	r2, [r1, #0]
 8003f64:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f68:	b29b      	uxth	r3, r3
 8003f6a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003f6e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003f72:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003f76:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003f7a:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8003f7e:	780b      	ldrb	r3, [r1, #0]
 8003f80:	f830 2023 	ldrh.w	r2, [r0, r3, lsl #2]
 8003f84:	b292      	uxth	r2, r2
 8003f86:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003f8a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003f8e:	f248 0480 	movw	r4, #32896	; 0x8080
 8003f92:	4322      	orrs	r2, r4
 8003f94:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8003f98:	780a      	ldrb	r2, [r1, #0]
 8003f9a:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003f9e:	b29b      	uxth	r3, r3
 8003fa0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003fa4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003fa8:	4323      	orrs	r3, r4
 8003faa:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003fae:	2000      	movs	r0, #0
 8003fb0:	bc10      	pop	{r4}
 8003fb2:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8003fb4:	780a      	ldrb	r2, [r1, #0]
 8003fb6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003fba:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8003fbe:	d00c      	beq.n	8003fda <USB_DeactivateEndpoint+0x160>
 8003fc0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003fc4:	b29b      	uxth	r3, r3
 8003fc6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003fca:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003fce:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8003fd2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003fd6:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8003fda:	780a      	ldrb	r2, [r1, #0]
 8003fdc:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003fe0:	f013 0f40 	tst.w	r3, #64	; 0x40
 8003fe4:	d00c      	beq.n	8004000 <USB_DeactivateEndpoint+0x186>
 8003fe6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003fea:	b29b      	uxth	r3, r3
 8003fec:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003ff0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003ff4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003ff8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003ffc:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_RX_DTOG(USBx, ep->num);
 8004000:	780a      	ldrb	r2, [r1, #0]
 8004002:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8004006:	b29b      	uxth	r3, r3
 8004008:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800400c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004010:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8004014:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004018:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800401c:	780b      	ldrb	r3, [r1, #0]
 800401e:	f830 2023 	ldrh.w	r2, [r0, r3, lsl #2]
 8004022:	b292      	uxth	r2, r2
 8004024:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8004028:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800402c:	f248 0480 	movw	r4, #32896	; 0x8080
 8004030:	4322      	orrs	r2, r4
 8004032:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8004036:	780a      	ldrb	r2, [r1, #0]
 8004038:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800403c:	b29b      	uxth	r3, r3
 800403e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004042:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004046:	4323      	orrs	r3, r4
 8004048:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 800404c:	e7af      	b.n	8003fae <USB_DeactivateEndpoint+0x134>

0800404e <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->is_in != 0U)
 800404e:	784b      	ldrb	r3, [r1, #1]
 8004050:	b98b      	cbnz	r3, 8004076 <USB_EPSetStall+0x28>
  {
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
  }
  else
  {
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 8004052:	780a      	ldrb	r2, [r1, #0]
 8004054:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8004058:	b29b      	uxth	r3, r3
 800405a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800405e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004062:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8004066:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800406a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800406e:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
  }

  return HAL_OK;
}
 8004072:	2000      	movs	r0, #0
 8004074:	4770      	bx	lr
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8004076:	780a      	ldrb	r2, [r1, #0]
 8004078:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800407c:	b29b      	uxth	r3, r3
 800407e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8004082:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004086:	f083 0310 	eor.w	r3, r3, #16
 800408a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800408e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004092:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8004096:	e7ec      	b.n	8004072 <USB_EPSetStall+0x24>

08004098 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0U)
 8004098:	7b0b      	ldrb	r3, [r1, #12]
 800409a:	2b00      	cmp	r3, #0
 800409c:	d14b      	bne.n	8004136 <USB_EPClearStall+0x9e>
  {
    if (ep->is_in != 0U)
 800409e:	784b      	ldrb	r3, [r1, #1]
 80040a0:	b333      	cbz	r3, 80040f0 <USB_EPClearStall+0x58>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80040a2:	780a      	ldrb	r2, [r1, #0]
 80040a4:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80040a8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80040ac:	d00c      	beq.n	80040c8 <USB_EPClearStall+0x30>
 80040ae:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80040b2:	b29b      	uxth	r3, r3
 80040b4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80040b8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80040bc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80040c0:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80040c4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]

      if (ep->type != EP_TYPE_ISOC)
 80040c8:	78cb      	ldrb	r3, [r1, #3]
 80040ca:	2b01      	cmp	r3, #1
 80040cc:	d033      	beq.n	8004136 <USB_EPClearStall+0x9e>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 80040ce:	780a      	ldrb	r2, [r1, #0]
 80040d0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80040d4:	b29b      	uxth	r3, r3
 80040d6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80040da:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80040de:	f083 0320 	eor.w	r3, r3, #32
 80040e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80040e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80040ea:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 80040ee:	e022      	b.n	8004136 <USB_EPClearStall+0x9e>
      }
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80040f0:	780a      	ldrb	r2, [r1, #0]
 80040f2:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80040f6:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80040fa:	d00c      	beq.n	8004116 <USB_EPClearStall+0x7e>
 80040fc:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8004100:	b29b      	uxth	r3, r3
 8004102:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8004106:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800410a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800410e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004112:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]

      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8004116:	780a      	ldrb	r2, [r1, #0]
 8004118:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 800411c:	b29b      	uxth	r3, r3
 800411e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004122:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004126:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800412a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800412e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004132:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    }
  }

  return HAL_OK;
}
 8004136:	2000      	movs	r0, #0
 8004138:	4770      	bx	lr

0800413a <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_TypeDef *USBx, uint8_t address)
{
  if (address == 0U)
 800413a:	b911      	cbnz	r1, 8004142 <USB_SetDevAddress+0x8>
  {
    /* set device address and enable function */
    USBx->DADDR = USB_DADDR_EF;
 800413c:	2380      	movs	r3, #128	; 0x80
 800413e:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
  }

  return HAL_OK;
}
 8004142:	2000      	movs	r0, #0
 8004144:	4770      	bx	lr

08004146 <USB_DevConnect>:
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 8004146:	2000      	movs	r0, #0
 8004148:	4770      	bx	lr

0800414a <USB_DevDisconnect>:
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 800414a:	2000      	movs	r0, #0
 800414c:	4770      	bx	lr

0800414e <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts(USB_TypeDef *USBx)
{
  uint32_t tmpreg;

  tmpreg = USBx->ISTR;
 800414e:	f8b0 0044 	ldrh.w	r0, [r0, #68]	; 0x44
  return tmpreg;
}
 8004152:	b280      	uxth	r0, r0
 8004154:	4770      	bx	lr

08004156 <USB_EP0_OutStart>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 8004156:	2000      	movs	r0, #0
 8004158:	4770      	bx	lr

0800415a <USB_WritePMA>:
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800415a:	3301      	adds	r3, #1
 800415c:	085b      	lsrs	r3, r3, #1
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp1, temp2;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800415e:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8004162:	f502 6280 	add.w	r2, r2, #1024	; 0x400

  for (i = n; i != 0U; i--)
 8004166:	b163      	cbz	r3, 8004182 <USB_WritePMA+0x28>
{
 8004168:	b410      	push	{r4}
  {
    temp1 = *pBuf;
 800416a:	780c      	ldrb	r4, [r1, #0]
    pBuf++;
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
 800416c:	7848      	ldrb	r0, [r1, #1]
    *pdwVal = (uint16_t)temp2;
 800416e:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
 8004172:	f822 4b04 	strh.w	r4, [r2], #4

#if PMA_ACCESS > 1U
    pdwVal++;
#endif

    pBuf++;
 8004176:	3102      	adds	r1, #2
  for (i = n; i != 0U; i--)
 8004178:	3b01      	subs	r3, #1
 800417a:	2b00      	cmp	r3, #0
 800417c:	d1f5      	bne.n	800416a <USB_WritePMA+0x10>
  }
}
 800417e:	bc10      	pop	{r4}
 8004180:	4770      	bx	lr
 8004182:	4770      	bx	lr

08004184 <USB_EPStartXfer>:
{
 8004184:	b570      	push	{r4, r5, r6, lr}
  if (ep->is_in == 1U)
 8004186:	784c      	ldrb	r4, [r1, #1]
 8004188:	2c01      	cmp	r4, #1
 800418a:	d037      	beq.n	80041fc <USB_EPStartXfer+0x78>
    if (ep->xfer_len > ep->maxpacket)
 800418c:	698a      	ldr	r2, [r1, #24]
 800418e:	690b      	ldr	r3, [r1, #16]
 8004190:	429a      	cmp	r2, r3
 8004192:	f240 810b 	bls.w	80043ac <USB_EPStartXfer+0x228>
      ep->xfer_len -= len;
 8004196:	1ad2      	subs	r2, r2, r3
 8004198:	618a      	str	r2, [r1, #24]
    if (ep->doublebuffer == 0U)
 800419a:	7b0a      	ldrb	r2, [r1, #12]
 800419c:	2a00      	cmp	r2, #0
 800419e:	f040 8122 	bne.w	80043e6 <USB_EPStartXfer+0x262>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 80041a2:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 80041a6:	b292      	uxth	r2, r2
 80041a8:	4402      	add	r2, r0
 80041aa:	780c      	ldrb	r4, [r1, #0]
 80041ac:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 80041b0:	2b00      	cmp	r3, #0
 80041b2:	f040 80ff 	bne.w	80043b4 <USB_EPStartXfer+0x230>
 80041b6:	f8b2 340c 	ldrh.w	r3, [r2, #1036]	; 0x40c
 80041ba:	b29b      	uxth	r3, r3
 80041bc:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80041c0:	b29b      	uxth	r3, r3
 80041c2:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
 80041c6:	f8b2 340c 	ldrh.w	r3, [r2, #1036]	; 0x40c
 80041ca:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80041ce:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80041d2:	b29b      	uxth	r3, r3
 80041d4:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80041d8:	780a      	ldrb	r2, [r1, #0]
 80041da:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80041de:	b29b      	uxth	r3, r3
 80041e0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80041e4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80041e8:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80041ec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80041f0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80041f4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 80041f8:	2000      	movs	r0, #0
 80041fa:	bd70      	pop	{r4, r5, r6, pc}
    if (ep->xfer_len > ep->maxpacket)
 80041fc:	698a      	ldr	r2, [r1, #24]
 80041fe:	690b      	ldr	r3, [r1, #16]
 8004200:	429a      	cmp	r2, r3
 8004202:	d926      	bls.n	8004252 <USB_EPStartXfer+0xce>
      ep->xfer_len -= len;
 8004204:	1ad2      	subs	r2, r2, r3
 8004206:	618a      	str	r2, [r1, #24]
 8004208:	460e      	mov	r6, r1
 800420a:	4605      	mov	r5, r0
    if (ep->doublebuffer == 0U)
 800420c:	7b0a      	ldrb	r2, [r1, #12]
 800420e:	b322      	cbz	r2, 800425a <USB_EPStartXfer+0xd6>
      if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 8004210:	780a      	ldrb	r2, [r1, #0]
 8004212:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 8004216:	f011 0f40 	tst.w	r1, #64	; 0x40
 800421a:	d078      	beq.n	800430e <USB_EPStartXfer+0x18a>
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800421c:	2c00      	cmp	r4, #0
 800421e:	d145      	bne.n	80042ac <USB_EPStartXfer+0x128>
 8004220:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 8004224:	b289      	uxth	r1, r1
 8004226:	4401      	add	r1, r0
 8004228:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 800422c:	bb2b      	cbnz	r3, 800427a <USB_EPStartXfer+0xf6>
 800422e:	f8b2 140c 	ldrh.w	r1, [r2, #1036]	; 0x40c
 8004232:	b289      	uxth	r1, r1
 8004234:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
 8004238:	b289      	uxth	r1, r1
 800423a:	f8a2 140c 	strh.w	r1, [r2, #1036]	; 0x40c
 800423e:	f8b2 140c 	ldrh.w	r1, [r2, #1036]	; 0x40c
 8004242:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8004246:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 800424a:	b289      	uxth	r1, r1
 800424c:	f8a2 140c 	strh.w	r1, [r2, #1036]	; 0x40c
 8004250:	e035      	b.n	80042be <USB_EPStartXfer+0x13a>
      ep->xfer_len = 0U;
 8004252:	2300      	movs	r3, #0
 8004254:	618b      	str	r3, [r1, #24]
      len = ep->xfer_len;
 8004256:	4613      	mov	r3, r2
 8004258:	e7d6      	b.n	8004208 <USB_EPStartXfer+0x84>
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 800425a:	b29c      	uxth	r4, r3
 800425c:	4623      	mov	r3, r4
 800425e:	88ca      	ldrh	r2, [r1, #6]
 8004260:	6949      	ldr	r1, [r1, #20]
 8004262:	f7ff ff7a 	bl	800415a <USB_WritePMA>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8004266:	f8b5 3050 	ldrh.w	r3, [r5, #80]	; 0x50
 800426a:	b29b      	uxth	r3, r3
 800426c:	442b      	add	r3, r5
 800426e:	7832      	ldrb	r2, [r6, #0]
 8004270:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8004274:	f8a3 4404 	strh.w	r4, [r3, #1028]	; 0x404
 8004278:	e038      	b.n	80042ec <USB_EPStartXfer+0x168>
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800427a:	2b3e      	cmp	r3, #62	; 0x3e
 800427c:	d809      	bhi.n	8004292 <USB_EPStartXfer+0x10e>
 800427e:	0859      	lsrs	r1, r3, #1
 8004280:	f013 0f01 	tst.w	r3, #1
 8004284:	d000      	beq.n	8004288 <USB_EPStartXfer+0x104>
 8004286:	3101      	adds	r1, #1
 8004288:	0289      	lsls	r1, r1, #10
 800428a:	b289      	uxth	r1, r1
 800428c:	f8a2 140c 	strh.w	r1, [r2, #1036]	; 0x40c
 8004290:	e015      	b.n	80042be <USB_EPStartXfer+0x13a>
 8004292:	0959      	lsrs	r1, r3, #5
 8004294:	f013 0f1f 	tst.w	r3, #31
 8004298:	d100      	bne.n	800429c <USB_EPStartXfer+0x118>
 800429a:	3901      	subs	r1, #1
 800429c:	ea6f 61c1 	mvn.w	r1, r1, lsl #27
 80042a0:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 80042a4:	b289      	uxth	r1, r1
 80042a6:	f8a2 140c 	strh.w	r1, [r2, #1036]	; 0x40c
 80042aa:	e008      	b.n	80042be <USB_EPStartXfer+0x13a>
 80042ac:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 80042b0:	b289      	uxth	r1, r1
 80042b2:	4401      	add	r1, r0
 80042b4:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 80042b8:	b299      	uxth	r1, r3
 80042ba:	f8a2 140c 	strh.w	r1, [r2, #1036]	; 0x40c
        pmabuffer = ep->pmaaddr1;
 80042be:	8972      	ldrh	r2, [r6, #10]
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80042c0:	b29b      	uxth	r3, r3
 80042c2:	6971      	ldr	r1, [r6, #20]
 80042c4:	4628      	mov	r0, r5
 80042c6:	f7ff ff48 	bl	800415a <USB_WritePMA>
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 80042ca:	7873      	ldrb	r3, [r6, #1]
 80042cc:	2b00      	cmp	r3, #0
 80042ce:	d15c      	bne.n	800438a <USB_EPStartXfer+0x206>
 80042d0:	7832      	ldrb	r2, [r6, #0]
 80042d2:	f835 3022 	ldrh.w	r3, [r5, r2, lsl #2]
 80042d6:	b29b      	uxth	r3, r3
 80042d8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80042dc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80042e0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80042e4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80042e8:	f825 3022 	strh.w	r3, [r5, r2, lsl #2]
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 80042ec:	7832      	ldrb	r2, [r6, #0]
 80042ee:	f835 3022 	ldrh.w	r3, [r5, r2, lsl #2]
 80042f2:	b29b      	uxth	r3, r3
 80042f4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80042f8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80042fc:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8004300:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004304:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004308:	f825 3022 	strh.w	r3, [r5, r2, lsl #2]
 800430c:	e774      	b.n	80041f8 <USB_EPStartXfer+0x74>
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800430e:	bb8c      	cbnz	r4, 8004374 <USB_EPStartXfer+0x1f0>
 8004310:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 8004314:	b289      	uxth	r1, r1
 8004316:	4401      	add	r1, r0
 8004318:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 800431c:	b98b      	cbnz	r3, 8004342 <USB_EPStartXfer+0x1be>
 800431e:	f8b2 1404 	ldrh.w	r1, [r2, #1028]	; 0x404
 8004322:	b289      	uxth	r1, r1
 8004324:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
 8004328:	b289      	uxth	r1, r1
 800432a:	f8a2 1404 	strh.w	r1, [r2, #1028]	; 0x404
 800432e:	f8b2 1404 	ldrh.w	r1, [r2, #1028]	; 0x404
 8004332:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8004336:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 800433a:	b289      	uxth	r1, r1
 800433c:	f8a2 1404 	strh.w	r1, [r2, #1028]	; 0x404
 8004340:	e021      	b.n	8004386 <USB_EPStartXfer+0x202>
 8004342:	2b3e      	cmp	r3, #62	; 0x3e
 8004344:	d809      	bhi.n	800435a <USB_EPStartXfer+0x1d6>
 8004346:	0859      	lsrs	r1, r3, #1
 8004348:	f013 0f01 	tst.w	r3, #1
 800434c:	d000      	beq.n	8004350 <USB_EPStartXfer+0x1cc>
 800434e:	3101      	adds	r1, #1
 8004350:	0289      	lsls	r1, r1, #10
 8004352:	b289      	uxth	r1, r1
 8004354:	f8a2 1404 	strh.w	r1, [r2, #1028]	; 0x404
 8004358:	e015      	b.n	8004386 <USB_EPStartXfer+0x202>
 800435a:	0959      	lsrs	r1, r3, #5
 800435c:	f013 0f1f 	tst.w	r3, #31
 8004360:	d100      	bne.n	8004364 <USB_EPStartXfer+0x1e0>
 8004362:	3901      	subs	r1, #1
 8004364:	ea6f 61c1 	mvn.w	r1, r1, lsl #27
 8004368:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 800436c:	b289      	uxth	r1, r1
 800436e:	f8a2 1404 	strh.w	r1, [r2, #1028]	; 0x404
 8004372:	e008      	b.n	8004386 <USB_EPStartXfer+0x202>
 8004374:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 8004378:	b289      	uxth	r1, r1
 800437a:	4401      	add	r1, r0
 800437c:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 8004380:	b299      	uxth	r1, r3
 8004382:	f8a2 1404 	strh.w	r1, [r2, #1028]	; 0x404
        pmabuffer = ep->pmaaddr0;
 8004386:	8932      	ldrh	r2, [r6, #8]
 8004388:	e79a      	b.n	80042c0 <USB_EPStartXfer+0x13c>
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 800438a:	2b01      	cmp	r3, #1
 800438c:	d1ae      	bne.n	80042ec <USB_EPStartXfer+0x168>
 800438e:	7832      	ldrb	r2, [r6, #0]
 8004390:	f835 3022 	ldrh.w	r3, [r5, r2, lsl #2]
 8004394:	b29b      	uxth	r3, r3
 8004396:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800439a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800439e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80043a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80043a6:	f825 3022 	strh.w	r3, [r5, r2, lsl #2]
 80043aa:	e79f      	b.n	80042ec <USB_EPStartXfer+0x168>
      ep->xfer_len = 0U;
 80043ac:	2300      	movs	r3, #0
 80043ae:	618b      	str	r3, [r1, #24]
      len = ep->xfer_len;
 80043b0:	4613      	mov	r3, r2
 80043b2:	e6f2      	b.n	800419a <USB_EPStartXfer+0x16>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 80043b4:	2b3e      	cmp	r3, #62	; 0x3e
 80043b6:	d809      	bhi.n	80043cc <USB_EPStartXfer+0x248>
 80043b8:	085c      	lsrs	r4, r3, #1
 80043ba:	f013 0f01 	tst.w	r3, #1
 80043be:	d000      	beq.n	80043c2 <USB_EPStartXfer+0x23e>
 80043c0:	3401      	adds	r4, #1
 80043c2:	02a4      	lsls	r4, r4, #10
 80043c4:	b2a4      	uxth	r4, r4
 80043c6:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
 80043ca:	e705      	b.n	80041d8 <USB_EPStartXfer+0x54>
 80043cc:	095c      	lsrs	r4, r3, #5
 80043ce:	f013 0f1f 	tst.w	r3, #31
 80043d2:	d100      	bne.n	80043d6 <USB_EPStartXfer+0x252>
 80043d4:	3c01      	subs	r4, #1
 80043d6:	ea6f 64c4 	mvn.w	r4, r4, lsl #27
 80043da:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 80043de:	b2a4      	uxth	r4, r4
 80043e0:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
 80043e4:	e6f8      	b.n	80041d8 <USB_EPStartXfer+0x54>
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 80043e6:	b9c4      	cbnz	r4, 800441a <USB_EPStartXfer+0x296>
 80043e8:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 80043ec:	b292      	uxth	r2, r2
 80043ee:	4402      	add	r2, r0
 80043f0:	780c      	ldrb	r4, [r1, #0]
 80043f2:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 80043f6:	bb6b      	cbnz	r3, 8004454 <USB_EPStartXfer+0x2d0>
 80043f8:	f8b2 4404 	ldrh.w	r4, [r2, #1028]	; 0x404
 80043fc:	b2a4      	uxth	r4, r4
 80043fe:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
 8004402:	b2a4      	uxth	r4, r4
 8004404:	f8a2 4404 	strh.w	r4, [r2, #1028]	; 0x404
 8004408:	f8b2 4404 	ldrh.w	r4, [r2, #1028]	; 0x404
 800440c:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8004410:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8004414:	b2a4      	uxth	r4, r4
 8004416:	f8a2 4404 	strh.w	r4, [r2, #1028]	; 0x404
 800441a:	784a      	ldrb	r2, [r1, #1]
 800441c:	2a00      	cmp	r2, #0
 800441e:	d14b      	bne.n	80044b8 <USB_EPStartXfer+0x334>
 8004420:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8004424:	b292      	uxth	r2, r2
 8004426:	4402      	add	r2, r0
 8004428:	780c      	ldrb	r4, [r1, #0]
 800442a:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 800442e:	bb53      	cbnz	r3, 8004486 <USB_EPStartXfer+0x302>
 8004430:	f8b2 340c 	ldrh.w	r3, [r2, #1036]	; 0x40c
 8004434:	b29b      	uxth	r3, r3
 8004436:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 800443a:	b29b      	uxth	r3, r3
 800443c:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
 8004440:	f8b2 340c 	ldrh.w	r3, [r2, #1036]	; 0x40c
 8004444:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8004448:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800444c:	b29b      	uxth	r3, r3
 800444e:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
 8004452:	e6c1      	b.n	80041d8 <USB_EPStartXfer+0x54>
 8004454:	2b3e      	cmp	r3, #62	; 0x3e
 8004456:	d809      	bhi.n	800446c <USB_EPStartXfer+0x2e8>
 8004458:	085c      	lsrs	r4, r3, #1
 800445a:	f013 0f01 	tst.w	r3, #1
 800445e:	d000      	beq.n	8004462 <USB_EPStartXfer+0x2de>
 8004460:	3401      	adds	r4, #1
 8004462:	02a4      	lsls	r4, r4, #10
 8004464:	b2a4      	uxth	r4, r4
 8004466:	f8a2 4404 	strh.w	r4, [r2, #1028]	; 0x404
 800446a:	e7d6      	b.n	800441a <USB_EPStartXfer+0x296>
 800446c:	095c      	lsrs	r4, r3, #5
 800446e:	f013 0f1f 	tst.w	r3, #31
 8004472:	d100      	bne.n	8004476 <USB_EPStartXfer+0x2f2>
 8004474:	3c01      	subs	r4, #1
 8004476:	ea6f 64c4 	mvn.w	r4, r4, lsl #27
 800447a:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 800447e:	b2a4      	uxth	r4, r4
 8004480:	f8a2 4404 	strh.w	r4, [r2, #1028]	; 0x404
 8004484:	e7c9      	b.n	800441a <USB_EPStartXfer+0x296>
 8004486:	2b3e      	cmp	r3, #62	; 0x3e
 8004488:	d809      	bhi.n	800449e <USB_EPStartXfer+0x31a>
 800448a:	085c      	lsrs	r4, r3, #1
 800448c:	f013 0f01 	tst.w	r3, #1
 8004490:	d000      	beq.n	8004494 <USB_EPStartXfer+0x310>
 8004492:	3401      	adds	r4, #1
 8004494:	02a4      	lsls	r4, r4, #10
 8004496:	b2a4      	uxth	r4, r4
 8004498:	f8a2 440c 	strh.w	r4, [r2, #1036]	; 0x40c
 800449c:	e69c      	b.n	80041d8 <USB_EPStartXfer+0x54>
 800449e:	095c      	lsrs	r4, r3, #5
 80044a0:	f013 0f1f 	tst.w	r3, #31
 80044a4:	d100      	bne.n	80044a8 <USB_EPStartXfer+0x324>
 80044a6:	3c01      	subs	r4, #1
 80044a8:	ea6f 63c4 	mvn.w	r3, r4, lsl #27
 80044ac:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80044b0:	b29b      	uxth	r3, r3
 80044b2:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
 80044b6:	e68f      	b.n	80041d8 <USB_EPStartXfer+0x54>
 80044b8:	2a01      	cmp	r2, #1
 80044ba:	f47f ae8d 	bne.w	80041d8 <USB_EPStartXfer+0x54>
 80044be:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 80044c2:	b292      	uxth	r2, r2
 80044c4:	4402      	add	r2, r0
 80044c6:	780c      	ldrb	r4, [r1, #0]
 80044c8:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 80044cc:	b29b      	uxth	r3, r3
 80044ce:	f8a2 340c 	strh.w	r3, [r2, #1036]	; 0x40c
 80044d2:	e681      	b.n	80041d8 <USB_EPStartXfer+0x54>

080044d4 <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 80044d4:	b430      	push	{r4, r5}
  uint32_t n = (uint32_t)wNBytes >> 1;
 80044d6:	085d      	lsrs	r5, r3, #1
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80044d8:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 80044dc:	f502 6280 	add.w	r2, r2, #1024	; 0x400

  for (i = n; i != 0U; i--)
 80044e0:	e007      	b.n	80044f2 <USB_ReadPMA+0x1e>
  {
    temp = *(__IO uint16_t *)pdwVal;
 80044e2:	f832 4b04 	ldrh.w	r4, [r2], #4
 80044e6:	b2a4      	uxth	r4, r4
    pdwVal++;
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 80044e8:	700c      	strb	r4, [r1, #0]
    pBuf++;
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 80044ea:	0a24      	lsrs	r4, r4, #8
 80044ec:	704c      	strb	r4, [r1, #1]
    pBuf++;
 80044ee:	3102      	adds	r1, #2
  for (i = n; i != 0U; i--)
 80044f0:	3d01      	subs	r5, #1
 80044f2:	2d00      	cmp	r5, #0
 80044f4:	d1f5      	bne.n	80044e2 <USB_ReadPMA+0xe>
#if PMA_ACCESS > 1U
    pdwVal++;
#endif
  }

  if ((wNBytes % 2U) != 0U)
 80044f6:	f013 0f01 	tst.w	r3, #1
 80044fa:	d001      	beq.n	8004500 <USB_ReadPMA+0x2c>
  {
    temp = *pdwVal;
 80044fc:	8813      	ldrh	r3, [r2, #0]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 80044fe:	700b      	strb	r3, [r1, #0]
  }
}
 8004500:	bc30      	pop	{r4, r5}
 8004502:	4770      	bx	lr

08004504 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8004504:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8004506:	f8d0 42b8 	ldr.w	r4, [r0, #696]	; 0x2b8

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800450a:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800450e:	b15b      	cbz	r3, 8004528 <USBD_CDC_EP0_RxReady+0x24>
 8004510:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8004514:	28ff      	cmp	r0, #255	; 0xff
 8004516:	d007      	beq.n	8004528 <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8004518:	689b      	ldr	r3, [r3, #8]
 800451a:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 800451e:	4621      	mov	r1, r4
 8004520:	4798      	blx	r3
                                                      (uint8_t *)(void *)hcdc->data,
                                                      (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 8004522:	23ff      	movs	r3, #255	; 0xff
 8004524:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200

  }
  return USBD_OK;
}
 8004528:	2000      	movs	r0, #0
 800452a:	bd10      	pop	{r4, pc}

0800452c <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_CfgFSDesc);
 800452c:	2343      	movs	r3, #67	; 0x43
 800452e:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 8004530:	4800      	ldr	r0, [pc, #0]	; (8004534 <USBD_CDC_GetFSCfgDesc+0x8>)
 8004532:	4770      	bx	lr
 8004534:	20000040 	.word	0x20000040

08004538 <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_CfgHSDesc);
 8004538:	2343      	movs	r3, #67	; 0x43
 800453a:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 800453c:	4800      	ldr	r0, [pc, #0]	; (8004540 <USBD_CDC_GetHSCfgDesc+0x8>)
 800453e:	4770      	bx	lr
 8004540:	20000084 	.word	0x20000084

08004544 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_OtherSpeedCfgDesc);
 8004544:	2343      	movs	r3, #67	; 0x43
 8004546:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 8004548:	4800      	ldr	r0, [pc, #0]	; (800454c <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 800454a:	4770      	bx	lr
 800454c:	200000d4 	.word	0x200000d4

08004550 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
  *length = sizeof(USBD_CDC_DeviceQualifierDesc);
 8004550:	230a      	movs	r3, #10
 8004552:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 8004554:	4800      	ldr	r0, [pc, #0]	; (8004558 <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 8004556:	4770      	bx	lr
 8004558:	200000c8 	.word	0x200000c8

0800455c <USBD_CDC_DataOut>:
{
 800455c:	b538      	push	{r3, r4, r5, lr}
 800455e:	4604      	mov	r4, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 8004560:	f8d0 52b8 	ldr.w	r5, [r0, #696]	; 0x2b8
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8004564:	f004 fb80 	bl	8008c68 <USBD_LL_GetRxDataSize>
 8004568:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  if (pdev->pClassData != NULL)
 800456c:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 8004570:	b14b      	cbz	r3, 8004586 <USBD_CDC_DataOut+0x2a>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8004572:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8004576:	68db      	ldr	r3, [r3, #12]
 8004578:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 800457c:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 8004580:	4798      	blx	r3
    return USBD_OK;
 8004582:	2000      	movs	r0, #0
 8004584:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 8004586:	2002      	movs	r0, #2
}
 8004588:	bd38      	pop	{r3, r4, r5, pc}

0800458a <USBD_CDC_DataIn>:
{
 800458a:	b538      	push	{r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800458c:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
  PCD_HandleTypeDef *hpcd = pdev->pData;
 8004590:	f8d0 52c0 	ldr.w	r5, [r0, #704]	; 0x2c0
  if (pdev->pClassData != NULL)
 8004594:	b1ea      	cbz	r2, 80045d2 <USBD_CDC_DataIn+0x48>
    if ((pdev->ep_in[epnum].total_length > 0U) && ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 8004596:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 800459a:	00a3      	lsls	r3, r4, #2
 800459c:	4403      	add	r3, r0
 800459e:	69db      	ldr	r3, [r3, #28]
 80045a0:	b13b      	cbz	r3, 80045b2 <USBD_CDC_DataIn+0x28>
 80045a2:	eb05 1541 	add.w	r5, r5, r1, lsl #5
 80045a6:	6bad      	ldr	r5, [r5, #56]	; 0x38
 80045a8:	fbb3 f4f5 	udiv	r4, r3, r5
 80045ac:	fb05 3314 	mls	r3, r5, r4, r3
 80045b0:	b11b      	cbz	r3, 80045ba <USBD_CDC_DataIn+0x30>
      hcdc->TxState = 0U;
 80045b2:	2000      	movs	r0, #0
 80045b4:	f8c2 0214 	str.w	r0, [r2, #532]	; 0x214
 80045b8:	bd38      	pop	{r3, r4, r5, pc}
      pdev->ep_in[epnum].total_length = 0U;
 80045ba:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 80045be:	0093      	lsls	r3, r2, #2
 80045c0:	4403      	add	r3, r0
 80045c2:	2400      	movs	r4, #0
 80045c4:	61dc      	str	r4, [r3, #28]
      USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 80045c6:	4623      	mov	r3, r4
 80045c8:	4622      	mov	r2, r4
 80045ca:	f004 fb3d 	bl	8008c48 <USBD_LL_Transmit>
    return USBD_OK;
 80045ce:	4620      	mov	r0, r4
      USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 80045d0:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 80045d2:	2002      	movs	r0, #2
}
 80045d4:	bd38      	pop	{r3, r4, r5, pc}

080045d6 <USBD_CDC_Setup>:
{
 80045d6:	b570      	push	{r4, r5, r6, lr}
 80045d8:	b082      	sub	sp, #8
 80045da:	4605      	mov	r5, r0
 80045dc:	460c      	mov	r4, r1
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 80045de:	f8d0 62b8 	ldr.w	r6, [r0, #696]	; 0x2b8
  uint8_t ifalt = 0U;
 80045e2:	2300      	movs	r3, #0
 80045e4:	f88d 3007 	strb.w	r3, [sp, #7]
  uint16_t status_info = 0U;
 80045e8:	f8ad 3004 	strh.w	r3, [sp, #4]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80045ec:	780b      	ldrb	r3, [r1, #0]
 80045ee:	f013 0260 	ands.w	r2, r3, #96	; 0x60
 80045f2:	d027      	beq.n	8004644 <USBD_CDC_Setup+0x6e>
 80045f4:	2a20      	cmp	r2, #32
 80045f6:	d154      	bne.n	80046a2 <USBD_CDC_Setup+0xcc>
      if (req->wLength)
 80045f8:	88ca      	ldrh	r2, [r1, #6]
 80045fa:	b1da      	cbz	r2, 8004634 <USBD_CDC_Setup+0x5e>
        if (req->bmRequest & 0x80U)
 80045fc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8004600:	d10b      	bne.n	800461a <USBD_CDC_Setup+0x44>
          hcdc->CmdOpCode = req->bRequest;
 8004602:	784b      	ldrb	r3, [r1, #1]
 8004604:	f886 3200 	strb.w	r3, [r6, #512]	; 0x200
          hcdc->CmdLength = (uint8_t)req->wLength;
 8004608:	798b      	ldrb	r3, [r1, #6]
 800460a:	f886 3201 	strb.w	r3, [r6, #513]	; 0x201
          USBD_CtlPrepareRx(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 800460e:	88ca      	ldrh	r2, [r1, #6]
 8004610:	4631      	mov	r1, r6
 8004612:	f000 fdee 	bl	80051f2 <USBD_CtlPrepareRx>
  uint8_t ret = USBD_OK;
 8004616:	2000      	movs	r0, #0
 8004618:	e046      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800461a:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 800461e:	689b      	ldr	r3, [r3, #8]
 8004620:	4631      	mov	r1, r6
 8004622:	7860      	ldrb	r0, [r4, #1]
 8004624:	4798      	blx	r3
          USBD_CtlSendData(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 8004626:	88e2      	ldrh	r2, [r4, #6]
 8004628:	4631      	mov	r1, r6
 800462a:	4628      	mov	r0, r5
 800462c:	f000 fdcc 	bl	80051c8 <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 8004630:	2000      	movs	r0, #0
 8004632:	e039      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8004634:	f8d0 32bc 	ldr.w	r3, [r0, #700]	; 0x2bc
 8004638:	689b      	ldr	r3, [r3, #8]
 800463a:	2200      	movs	r2, #0
 800463c:	7848      	ldrb	r0, [r1, #1]
 800463e:	4798      	blx	r3
  uint8_t ret = USBD_OK;
 8004640:	2000      	movs	r0, #0
 8004642:	e031      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
      switch (req->bRequest)
 8004644:	784b      	ldrb	r3, [r1, #1]
 8004646:	2b0a      	cmp	r3, #10
 8004648:	d014      	beq.n	8004674 <USBD_CDC_Setup+0x9e>
 800464a:	2b0b      	cmp	r3, #11
 800464c:	d021      	beq.n	8004692 <USBD_CDC_Setup+0xbc>
 800464e:	b11b      	cbz	r3, 8004658 <USBD_CDC_Setup+0x82>
          USBD_CtlError(pdev, req);
 8004650:	f000 fa79 	bl	8004b46 <USBD_CtlError>
          ret = USBD_FAIL;
 8004654:	2002      	movs	r0, #2
          break;
 8004656:	e027      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004658:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800465c:	2b03      	cmp	r3, #3
 800465e:	d003      	beq.n	8004668 <USBD_CDC_Setup+0x92>
            USBD_CtlError(pdev, req);
 8004660:	f000 fa71 	bl	8004b46 <USBD_CtlError>
            ret = USBD_FAIL;
 8004664:	2002      	movs	r0, #2
 8004666:	e01f      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&status_info, 2U);
 8004668:	2202      	movs	r2, #2
 800466a:	a901      	add	r1, sp, #4
 800466c:	f000 fdac 	bl	80051c8 <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 8004670:	2000      	movs	r0, #0
 8004672:	e019      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004674:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004678:	2b03      	cmp	r3, #3
 800467a:	d003      	beq.n	8004684 <USBD_CDC_Setup+0xae>
            USBD_CtlError(pdev, req);
 800467c:	f000 fa63 	bl	8004b46 <USBD_CtlError>
            ret = USBD_FAIL;
 8004680:	2002      	movs	r0, #2
 8004682:	e011      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
            USBD_CtlSendData(pdev, &ifalt, 1U);
 8004684:	2201      	movs	r2, #1
 8004686:	f10d 0107 	add.w	r1, sp, #7
 800468a:	f000 fd9d 	bl	80051c8 <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 800468e:	2000      	movs	r0, #0
 8004690:	e00a      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8004692:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004696:	2b03      	cmp	r3, #3
 8004698:	d008      	beq.n	80046ac <USBD_CDC_Setup+0xd6>
            USBD_CtlError(pdev, req);
 800469a:	f000 fa54 	bl	8004b46 <USBD_CtlError>
            ret = USBD_FAIL;
 800469e:	2002      	movs	r0, #2
 80046a0:	e002      	b.n	80046a8 <USBD_CDC_Setup+0xd2>
      USBD_CtlError(pdev, req);
 80046a2:	f000 fa50 	bl	8004b46 <USBD_CtlError>
      ret = USBD_FAIL;
 80046a6:	2002      	movs	r0, #2
}
 80046a8:	b002      	add	sp, #8
 80046aa:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t ret = USBD_OK;
 80046ac:	2000      	movs	r0, #0
 80046ae:	e7fb      	b.n	80046a8 <USBD_CDC_Setup+0xd2>

080046b0 <USBD_CDC_DeInit>:
{
 80046b0:	b538      	push	{r3, r4, r5, lr}
 80046b2:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev, CDC_IN_EP);
 80046b4:	2181      	movs	r1, #129	; 0x81
 80046b6:	f004 fa94 	bl	8008be2 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 80046ba:	2500      	movs	r5, #0
 80046bc:	62e5      	str	r5, [r4, #44]	; 0x2c
  USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 80046be:	2101      	movs	r1, #1
 80046c0:	4620      	mov	r0, r4
 80046c2:	f004 fa8e 	bl	8008be2 <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 80046c6:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
  USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 80046ca:	2182      	movs	r1, #130	; 0x82
 80046cc:	4620      	mov	r0, r4
 80046ce:	f004 fa88 	bl	8008be2 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 80046d2:	6425      	str	r5, [r4, #64]	; 0x40
  if (pdev->pClassData != NULL)
 80046d4:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 80046d8:	b14b      	cbz	r3, 80046ee <USBD_CDC_DeInit+0x3e>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 80046da:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 80046de:	685b      	ldr	r3, [r3, #4]
 80046e0:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 80046e2:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
 80046e6:	f004 fac9 	bl	8008c7c <USBD_static_free>
    pdev->pClassData = NULL;
 80046ea:	f8c4 52b8 	str.w	r5, [r4, #696]	; 0x2b8
}
 80046ee:	2000      	movs	r0, #0
 80046f0:	bd38      	pop	{r3, r4, r5, pc}

080046f2 <USBD_CDC_Init>:
{
 80046f2:	b538      	push	{r3, r4, r5, lr}
 80046f4:	4604      	mov	r4, r0
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 80046f6:	7c03      	ldrb	r3, [r0, #16]
 80046f8:	bba3      	cbnz	r3, 8004764 <USBD_CDC_Init+0x72>
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 80046fa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80046fe:	2202      	movs	r2, #2
 8004700:	2181      	movs	r1, #129	; 0x81
 8004702:	f004 fa63 	bl	8008bcc <USBD_LL_OpenEP>
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 8004706:	2501      	movs	r5, #1
 8004708:	62e5      	str	r5, [r4, #44]	; 0x2c
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800470a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800470e:	2202      	movs	r2, #2
 8004710:	4629      	mov	r1, r5
 8004712:	4620      	mov	r0, r4
 8004714:	f004 fa5a 	bl	8008bcc <USBD_LL_OpenEP>
    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8004718:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
  USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 800471c:	2308      	movs	r3, #8
 800471e:	2203      	movs	r2, #3
 8004720:	2182      	movs	r1, #130	; 0x82
 8004722:	4620      	mov	r0, r4
 8004724:	f004 fa52 	bl	8008bcc <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 8004728:	2301      	movs	r3, #1
 800472a:	6423      	str	r3, [r4, #64]	; 0x40
  pdev->pClassData = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 800472c:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8004730:	f004 faa0 	bl	8008c74 <USBD_static_malloc>
 8004734:	4605      	mov	r5, r0
 8004736:	f8c4 02b8 	str.w	r0, [r4, #696]	; 0x2b8
  if (pdev->pClassData == NULL)
 800473a:	b368      	cbz	r0, 8004798 <USBD_CDC_Init+0xa6>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 800473c:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8004740:	681b      	ldr	r3, [r3, #0]
 8004742:	4798      	blx	r3
    hcdc->TxState = 0U;
 8004744:	2300      	movs	r3, #0
 8004746:	f8c5 3214 	str.w	r3, [r5, #532]	; 0x214
    hcdc->RxState = 0U;
 800474a:	f8c5 3218 	str.w	r3, [r5, #536]	; 0x218
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800474e:	7c23      	ldrb	r3, [r4, #16]
 8004750:	b1c3      	cbz	r3, 8004784 <USBD_CDC_Init+0x92>
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8004752:	2340      	movs	r3, #64	; 0x40
 8004754:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
 8004758:	2101      	movs	r1, #1
 800475a:	4620      	mov	r0, r4
 800475c:	f004 fa7c 	bl	8008c58 <USBD_LL_PrepareReceive>
  uint8_t ret = 0U;
 8004760:	2000      	movs	r0, #0
 8004762:	bd38      	pop	{r3, r4, r5, pc}
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 8004764:	2340      	movs	r3, #64	; 0x40
 8004766:	2202      	movs	r2, #2
 8004768:	2181      	movs	r1, #129	; 0x81
 800476a:	f004 fa2f 	bl	8008bcc <USBD_LL_OpenEP>
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800476e:	2501      	movs	r5, #1
 8004770:	62e5      	str	r5, [r4, #44]	; 0x2c
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8004772:	2340      	movs	r3, #64	; 0x40
 8004774:	2202      	movs	r2, #2
 8004776:	4629      	mov	r1, r5
 8004778:	4620      	mov	r0, r4
 800477a:	f004 fa27 	bl	8008bcc <USBD_LL_OpenEP>
    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 800477e:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
 8004782:	e7cb      	b.n	800471c <USBD_CDC_Init+0x2a>
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8004784:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004788:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
 800478c:	2101      	movs	r1, #1
 800478e:	4620      	mov	r0, r4
 8004790:	f004 fa62 	bl	8008c58 <USBD_LL_PrepareReceive>
  uint8_t ret = 0U;
 8004794:	2000      	movs	r0, #0
 8004796:	bd38      	pop	{r3, r4, r5, pc}
    ret = 1U;
 8004798:	2001      	movs	r0, #1
}
 800479a:	bd38      	pop	{r3, r4, r5, pc}

0800479c <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface(USBD_HandleTypeDef   *pdev,
                                    USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;

  if (fops != NULL)
 800479c:	b119      	cbz	r1, 80047a6 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData = fops;
 800479e:	f8c0 12bc 	str.w	r1, [r0, #700]	; 0x2bc
    ret = USBD_OK;
 80047a2:	2000      	movs	r0, #0
 80047a4:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 80047a6:	2002      	movs	r0, #2
  }

  return ret;
}
 80047a8:	4770      	bx	lr

080047aa <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff,
                              uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 80047aa:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8

  hcdc->TxBuffer = pbuff;
 80047ae:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 80047b2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return USBD_OK;
}
 80047b6:	2000      	movs	r0, #0
 80047b8:	4770      	bx	lr

080047ba <USBD_CDC_SetRxBuffer>:
  * @retval status
  */
uint8_t  USBD_CDC_SetRxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 80047ba:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8

  hcdc->RxBuffer = pbuff;
 80047be:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204

  return USBD_OK;
}
 80047c2:	2000      	movs	r0, #0
 80047c4:	4770      	bx	lr

080047c6 <USBD_CDC_TransmitPacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 80047c6:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8

  if (pdev->pClassData != NULL)
 80047ca:	b1a2      	cbz	r2, 80047f6 <USBD_CDC_TransmitPacket+0x30>
{
 80047cc:	b508      	push	{r3, lr}
  {
    if (hcdc->TxState == 0U)
 80047ce:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
 80047d2:	b10b      	cbz	r3, 80047d8 <USBD_CDC_TransmitPacket+0x12>

      return USBD_OK;
    }
    else
    {
      return USBD_BUSY;
 80047d4:	2001      	movs	r0, #1
  }
  else
  {
    return USBD_FAIL;
  }
}
 80047d6:	bd08      	pop	{r3, pc}
      hcdc->TxState = 1U;
 80047d8:	2301      	movs	r3, #1
 80047da:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
      pdev->ep_in[CDC_IN_EP & 0xFU].total_length = hcdc->TxLength;
 80047de:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
 80047e2:	6303      	str	r3, [r0, #48]	; 0x30
      USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer,
 80047e4:	f8b2 3210 	ldrh.w	r3, [r2, #528]	; 0x210
 80047e8:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
 80047ec:	2181      	movs	r1, #129	; 0x81
 80047ee:	f004 fa2b 	bl	8008c48 <USBD_LL_Transmit>
      return USBD_OK;
 80047f2:	2000      	movs	r0, #0
 80047f4:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 80047f6:	2002      	movs	r0, #2
 80047f8:	4770      	bx	lr

080047fa <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 80047fa:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8

  /* Suspend or Resume USB Out process */
  if (pdev->pClassData != NULL)
 80047fe:	b19a      	cbz	r2, 8004828 <USBD_CDC_ReceivePacket+0x2e>
{
 8004800:	b508      	push	{r3, lr}
  {
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004802:	7c03      	ldrb	r3, [r0, #16]
 8004804:	b13b      	cbz	r3, 8004816 <USBD_CDC_ReceivePacket+0x1c>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004806:	2340      	movs	r3, #64	; 0x40
 8004808:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 800480c:	2101      	movs	r1, #1
 800480e:	f004 fa23 	bl	8008c58 <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 8004812:	2000      	movs	r0, #0
 8004814:	bd08      	pop	{r3, pc}
      USBD_LL_PrepareReceive(pdev,
 8004816:	f44f 7300 	mov.w	r3, #512	; 0x200
 800481a:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 800481e:	2101      	movs	r1, #1
 8004820:	f004 fa1a 	bl	8008c58 <USBD_LL_PrepareReceive>
    return USBD_OK;
 8004824:	2000      	movs	r0, #0
 8004826:	bd08      	pop	{r3, pc}
  }
  else
  {
    return USBD_FAIL;
 8004828:	2002      	movs	r0, #2
 800482a:	4770      	bx	lr

0800482c <USBD_Init>:
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 800482c:	b198      	cbz	r0, 8004856 <USBD_Init+0x2a>
{
 800482e:	b508      	push	{r3, lr}
 8004830:	4603      	mov	r3, r0
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if (pdev->pClass != NULL)
 8004832:	f8d0 02b4 	ldr.w	r0, [r0, #692]	; 0x2b4
 8004836:	b110      	cbz	r0, 800483e <USBD_Init+0x12>
  {
    pdev->pClass = NULL;
 8004838:	2000      	movs	r0, #0
 800483a:	f8c3 02b4 	str.w	r0, [r3, #692]	; 0x2b4
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 800483e:	b109      	cbz	r1, 8004844 <USBD_Init+0x18>
  {
    pdev->pDesc = pdesc;
 8004840:	f8c3 12b0 	str.w	r1, [r3, #688]	; 0x2b0
 8004844:	4618      	mov	r0, r3
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004846:	2301      	movs	r3, #1
 8004848:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  pdev->id = id;
 800484c:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 800484e:	f004 f973 	bl	8008b38 <USBD_LL_Init>

  return USBD_OK;
 8004852:	2000      	movs	r0, #0
 8004854:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8004856:	2002      	movs	r0, #2
 8004858:	4770      	bx	lr

0800485a <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef status = USBD_OK;
  if (pclass != NULL)
 800485a:	b119      	cbz	r1, 8004864 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 800485c:	f8c0 12b4 	str.w	r1, [r0, #692]	; 0x2b4
    status = USBD_OK;
 8004860:	2000      	movs	r0, #0
 8004862:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 8004864:	2002      	movs	r0, #2
  }

  return status;
}
 8004866:	4770      	bx	lr

08004868 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start(USBD_HandleTypeDef *pdev)
{
 8004868:	b508      	push	{r3, lr}
  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 800486a:	f004 f9a7 	bl	8008bbc <USBD_LL_Start>

  return USBD_OK;
}
 800486e:	2000      	movs	r0, #0
 8004870:	bd08      	pop	{r3, pc}

08004872 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8004872:	b508      	push	{r3, lr}
  USBD_StatusTypeDef ret = USBD_FAIL;

  if (pdev->pClass != NULL)
 8004874:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004878:	b123      	cbz	r3, 8004884 <USBD_SetClassConfig+0x12>
  {
    /* Set configuration  and Start the Class*/
    if (pdev->pClass->Init(pdev, cfgidx) == 0U)
 800487a:	681b      	ldr	r3, [r3, #0]
 800487c:	4798      	blx	r3
 800487e:	b118      	cbz	r0, 8004888 <USBD_SetClassConfig+0x16>
  USBD_StatusTypeDef ret = USBD_FAIL;
 8004880:	2002      	movs	r0, #2
 8004882:	bd08      	pop	{r3, pc}
 8004884:	2002      	movs	r0, #2
 8004886:	bd08      	pop	{r3, pc}
    {
      ret = USBD_OK;
 8004888:	2000      	movs	r0, #0
    }
  }

  return ret;
}
 800488a:	bd08      	pop	{r3, pc}

0800488c <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800488c:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 800488e:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004892:	685b      	ldr	r3, [r3, #4]
 8004894:	4798      	blx	r3

  return USBD_OK;
}
 8004896:	2000      	movs	r0, #0
 8004898:	bd08      	pop	{r3, pc}

0800489a <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800489a:	b538      	push	{r3, r4, r5, lr}
 800489c:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 800489e:	f500 752a 	add.w	r5, r0, #680	; 0x2a8
 80048a2:	4628      	mov	r0, r5
 80048a4:	f000 f93b 	bl	8004b1e <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 80048a8:	2301      	movs	r3, #1
 80048aa:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 80048ae:	f8b4 32ae 	ldrh.w	r3, [r4, #686]	; 0x2ae
 80048b2:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 80048b6:	f894 12a8 	ldrb.w	r1, [r4, #680]	; 0x2a8
 80048ba:	f001 031f 	and.w	r3, r1, #31
 80048be:	2b01      	cmp	r3, #1
 80048c0:	d00e      	beq.n	80048e0 <USBD_LL_SetupStage+0x46>
 80048c2:	b13b      	cbz	r3, 80048d4 <USBD_LL_SetupStage+0x3a>
 80048c4:	2b02      	cmp	r3, #2
 80048c6:	d010      	beq.n	80048ea <USBD_LL_SetupStage+0x50>
    case USB_REQ_RECIPIENT_ENDPOINT:
      USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 80048c8:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80048cc:	4620      	mov	r0, r4
 80048ce:	f004 f990 	bl	8008bf2 <USBD_LL_StallEP>
      break;
 80048d2:	e003      	b.n	80048dc <USBD_LL_SetupStage+0x42>
      USBD_StdDevReq(pdev, &pdev->request);
 80048d4:	4629      	mov	r1, r5
 80048d6:	4620      	mov	r0, r4
 80048d8:	f000 faef 	bl	8004eba <USBD_StdDevReq>
  }

  return USBD_OK;
}
 80048dc:	2000      	movs	r0, #0
 80048de:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdItfReq(pdev, &pdev->request);
 80048e0:	4629      	mov	r1, r5
 80048e2:	4620      	mov	r0, r4
 80048e4:	f000 fb1d 	bl	8004f22 <USBD_StdItfReq>
      break;
 80048e8:	e7f8      	b.n	80048dc <USBD_LL_SetupStage+0x42>
      USBD_StdEPReq(pdev, &pdev->request);
 80048ea:	4629      	mov	r1, r5
 80048ec:	4620      	mov	r0, r4
 80048ee:	f000 fb48 	bl	8004f82 <USBD_StdEPReq>
      break;
 80048f2:	e7f3      	b.n	80048dc <USBD_LL_SetupStage+0x42>

080048f4 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 80048f4:	b538      	push	{r3, r4, r5, lr}
 80048f6:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 80048f8:	bba9      	cbnz	r1, 8004966 <USBD_LL_DataOutStage+0x72>
 80048fa:	4610      	mov	r0, r2
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 80048fc:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8004900:	2b03      	cmp	r3, #3
 8004902:	d003      	beq.n	800490c <USBD_LL_DataOutStage+0x18>
        USBD_CtlSendStatus(pdev);
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 8004904:	2b05      	cmp	r3, #5
 8004906:	d025      	beq.n	8004954 <USBD_LL_DataOutStage+0x60>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8004908:	2000      	movs	r0, #0
 800490a:	bd38      	pop	{r3, r4, r5, pc}
      if (pep->rem_length > pep->maxpacket)
 800490c:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
 8004910:	f8d4 2164 	ldr.w	r2, [r4, #356]	; 0x164
 8004914:	4293      	cmp	r3, r2
 8004916:	d90d      	bls.n	8004934 <USBD_LL_DataOutStage+0x40>
        pep->rem_length -= pep->maxpacket;
 8004918:	1a9b      	subs	r3, r3, r2
 800491a:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
        USBD_CtlContinueRx(pdev, pdata,
 800491e:	429a      	cmp	r2, r3
 8004920:	d906      	bls.n	8004930 <USBD_LL_DataOutStage+0x3c>
 8004922:	b29a      	uxth	r2, r3
 8004924:	4601      	mov	r1, r0
 8004926:	4620      	mov	r0, r4
 8004928:	f000 fc72 	bl	8005210 <USBD_CtlContinueRx>
  return USBD_OK;
 800492c:	2000      	movs	r0, #0
 800492e:	bd38      	pop	{r3, r4, r5, pc}
        USBD_CtlContinueRx(pdev, pdata,
 8004930:	b292      	uxth	r2, r2
 8004932:	e7f7      	b.n	8004924 <USBD_LL_DataOutStage+0x30>
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8004934:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004938:	691b      	ldr	r3, [r3, #16]
 800493a:	b11b      	cbz	r3, 8004944 <USBD_LL_DataOutStage+0x50>
            (pdev->dev_state == USBD_STATE_CONFIGURED))
 800493c:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8004940:	2a03      	cmp	r2, #3
 8004942:	d004      	beq.n	800494e <USBD_LL_DataOutStage+0x5a>
        USBD_CtlSendStatus(pdev);
 8004944:	4620      	mov	r0, r4
 8004946:	f000 fc6b 	bl	8005220 <USBD_CtlSendStatus>
  return USBD_OK;
 800494a:	2000      	movs	r0, #0
 800494c:	bd38      	pop	{r3, r4, r5, pc}
          pdev->pClass->EP0_RxReady(pdev);
 800494e:	4620      	mov	r0, r4
 8004950:	4798      	blx	r3
 8004952:	e7f7      	b.n	8004944 <USBD_LL_DataOutStage+0x50>
        pdev->ep0_state = USBD_EP0_IDLE;
 8004954:	2500      	movs	r5, #0
 8004956:	f8c4 5294 	str.w	r5, [r4, #660]	; 0x294
        USBD_LL_StallEP(pdev, 0U);
 800495a:	4629      	mov	r1, r5
 800495c:	4620      	mov	r0, r4
 800495e:	f004 f948 	bl	8008bf2 <USBD_LL_StallEP>
  return USBD_OK;
 8004962:	4628      	mov	r0, r5
 8004964:	bd38      	pop	{r3, r4, r5, pc}
 8004966:	460a      	mov	r2, r1
  else if ((pdev->pClass->DataOut != NULL) &&
 8004968:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800496c:	699b      	ldr	r3, [r3, #24]
 800496e:	b14b      	cbz	r3, 8004984 <USBD_LL_DataOutStage+0x90>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 8004970:	f890 129c 	ldrb.w	r1, [r0, #668]	; 0x29c
  else if ((pdev->pClass->DataOut != NULL) &&
 8004974:	2903      	cmp	r1, #3
 8004976:	d001      	beq.n	800497c <USBD_LL_DataOutStage+0x88>
    return USBD_FAIL;
 8004978:	2002      	movs	r0, #2
}
 800497a:	bd38      	pop	{r3, r4, r5, pc}
    pdev->pClass->DataOut(pdev, epnum);
 800497c:	4611      	mov	r1, r2
 800497e:	4798      	blx	r3
  return USBD_OK;
 8004980:	2000      	movs	r0, #0
    pdev->pClass->DataOut(pdev, epnum);
 8004982:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 8004984:	2002      	movs	r0, #2
 8004986:	bd38      	pop	{r3, r4, r5, pc}

08004988 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8004988:	b510      	push	{r4, lr}
 800498a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 800498c:	2900      	cmp	r1, #0
 800498e:	d154      	bne.n	8004a3a <USBD_LL_DataInStage+0xb2>
 8004990:	4610      	mov	r0, r2
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 8004992:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8004996:	2b02      	cmp	r3, #2
 8004998:	d00c      	beq.n	80049b4 <USBD_LL_DataInStage+0x2c>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 800499a:	2b04      	cmp	r3, #4
 800499c:	d000      	beq.n	80049a0 <USBD_LL_DataInStage+0x18>
 800499e:	b91b      	cbnz	r3, 80049a8 <USBD_LL_DataInStage+0x20>
          (pdev->ep0_state == USBD_EP0_IDLE))
      {
        USBD_LL_StallEP(pdev, 0x80U);
 80049a0:	2180      	movs	r1, #128	; 0x80
 80049a2:	4620      	mov	r0, r4
 80049a4:	f004 f925 	bl	8008bf2 <USBD_LL_StallEP>
      }
    }

    if (pdev->dev_test_mode == 1U)
 80049a8:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 80049ac:	2b01      	cmp	r3, #1
 80049ae:	d040      	beq.n	8004a32 <USBD_LL_DataInStage+0xaa>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 80049b0:	2000      	movs	r0, #0
 80049b2:	bd10      	pop	{r4, pc}
      if (pep->rem_length > pep->maxpacket)
 80049b4:	6a23      	ldr	r3, [r4, #32]
 80049b6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80049b8:	4293      	cmp	r3, r2
 80049ba:	d81b      	bhi.n	80049f4 <USBD_LL_DataInStage+0x6c>
        if ((pep->total_length % pep->maxpacket == 0U) &&
 80049bc:	69e1      	ldr	r1, [r4, #28]
 80049be:	fbb1 f3f2 	udiv	r3, r1, r2
 80049c2:	fb02 1313 	mls	r3, r2, r3, r1
 80049c6:	b92b      	cbnz	r3, 80049d4 <USBD_LL_DataInStage+0x4c>
 80049c8:	428a      	cmp	r2, r1
 80049ca:	d803      	bhi.n	80049d4 <USBD_LL_DataInStage+0x4c>
            (pep->total_length < pdev->ep0_data_len))
 80049cc:	f8d4 3298 	ldr.w	r3, [r4, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 80049d0:	4299      	cmp	r1, r3
 80049d2:	d31d      	bcc.n	8004a10 <USBD_LL_DataInStage+0x88>
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 80049d4:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 80049d8:	68db      	ldr	r3, [r3, #12]
 80049da:	b11b      	cbz	r3, 80049e4 <USBD_LL_DataInStage+0x5c>
              (pdev->dev_state == USBD_STATE_CONFIGURED))
 80049dc:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 80049e0:	2a03      	cmp	r2, #3
 80049e2:	d023      	beq.n	8004a2c <USBD_LL_DataInStage+0xa4>
          USBD_LL_StallEP(pdev, 0x80U);
 80049e4:	2180      	movs	r1, #128	; 0x80
 80049e6:	4620      	mov	r0, r4
 80049e8:	f004 f903 	bl	8008bf2 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 80049ec:	4620      	mov	r0, r4
 80049ee:	f000 fc22 	bl	8005236 <USBD_CtlReceiveStatus>
 80049f2:	e7d9      	b.n	80049a8 <USBD_LL_DataInStage+0x20>
        pep->rem_length -= pep->maxpacket;
 80049f4:	1a9a      	subs	r2, r3, r2
 80049f6:	6222      	str	r2, [r4, #32]
        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 80049f8:	b292      	uxth	r2, r2
 80049fa:	4601      	mov	r1, r0
 80049fc:	4620      	mov	r0, r4
 80049fe:	f000 fbf0 	bl	80051e2 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8004a02:	2300      	movs	r3, #0
 8004a04:	461a      	mov	r2, r3
 8004a06:	4619      	mov	r1, r3
 8004a08:	4620      	mov	r0, r4
 8004a0a:	f004 f925 	bl	8008c58 <USBD_LL_PrepareReceive>
 8004a0e:	e7cb      	b.n	80049a8 <USBD_LL_DataInStage+0x20>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 8004a10:	2200      	movs	r2, #0
 8004a12:	4611      	mov	r1, r2
 8004a14:	4620      	mov	r0, r4
 8004a16:	f000 fbe4 	bl	80051e2 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 8004a1a:	2100      	movs	r1, #0
 8004a1c:	f8c4 1298 	str.w	r1, [r4, #664]	; 0x298
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8004a20:	460b      	mov	r3, r1
 8004a22:	460a      	mov	r2, r1
 8004a24:	4620      	mov	r0, r4
 8004a26:	f004 f917 	bl	8008c58 <USBD_LL_PrepareReceive>
 8004a2a:	e7bd      	b.n	80049a8 <USBD_LL_DataInStage+0x20>
            pdev->pClass->EP0_TxSent(pdev);
 8004a2c:	4620      	mov	r0, r4
 8004a2e:	4798      	blx	r3
 8004a30:	e7d8      	b.n	80049e4 <USBD_LL_DataInStage+0x5c>
      pdev->dev_test_mode = 0U;
 8004a32:	2000      	movs	r0, #0
 8004a34:	f884 02a0 	strb.w	r0, [r4, #672]	; 0x2a0
 8004a38:	bd10      	pop	{r4, pc}
 8004a3a:	460a      	mov	r2, r1
  else if ((pdev->pClass->DataIn != NULL) &&
 8004a3c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004a40:	695b      	ldr	r3, [r3, #20]
 8004a42:	b14b      	cbz	r3, 8004a58 <USBD_LL_DataInStage+0xd0>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 8004a44:	f890 129c 	ldrb.w	r1, [r0, #668]	; 0x29c
  else if ((pdev->pClass->DataIn != NULL) &&
 8004a48:	2903      	cmp	r1, #3
 8004a4a:	d001      	beq.n	8004a50 <USBD_LL_DataInStage+0xc8>
    return USBD_FAIL;
 8004a4c:	2002      	movs	r0, #2
}
 8004a4e:	bd10      	pop	{r4, pc}
    pdev->pClass->DataIn(pdev, epnum);
 8004a50:	4611      	mov	r1, r2
 8004a52:	4798      	blx	r3
  return USBD_OK;
 8004a54:	2000      	movs	r0, #0
    pdev->pClass->DataIn(pdev, epnum);
 8004a56:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 8004a58:	2002      	movs	r0, #2
 8004a5a:	bd10      	pop	{r4, pc}

08004a5c <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8004a5c:	b570      	push	{r4, r5, r6, lr}
 8004a5e:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004a60:	2340      	movs	r3, #64	; 0x40
 8004a62:	2200      	movs	r2, #0
 8004a64:	4611      	mov	r1, r2
 8004a66:	f004 f8b1 	bl	8008bcc <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8004a6a:	2501      	movs	r5, #1
 8004a6c:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8004a70:	2640      	movs	r6, #64	; 0x40
 8004a72:	f8c4 6164 	str.w	r6, [r4, #356]	; 0x164

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004a76:	4633      	mov	r3, r6
 8004a78:	2200      	movs	r2, #0
 8004a7a:	2180      	movs	r1, #128	; 0x80
 8004a7c:	4620      	mov	r0, r4
 8004a7e:	f004 f8a5 	bl	8008bcc <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8004a82:	61a5      	str	r5, [r4, #24]

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8004a84:	6266      	str	r6, [r4, #36]	; 0x24

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004a86:	f884 529c 	strb.w	r5, [r4, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 8004a8a:	2300      	movs	r3, #0
 8004a8c:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
  pdev->dev_config = 0U;
 8004a90:	6063      	str	r3, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 8004a92:	f8c4 32a4 	str.w	r3, [r4, #676]	; 0x2a4

  if (pdev->pClassData)
 8004a96:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 8004a9a:	b12b      	cbz	r3, 8004aa8 <USBD_LL_Reset+0x4c>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8004a9c:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004aa0:	685b      	ldr	r3, [r3, #4]
 8004aa2:	2100      	movs	r1, #0
 8004aa4:	4620      	mov	r0, r4
 8004aa6:	4798      	blx	r3
  }

  return USBD_OK;
}
 8004aa8:	2000      	movs	r0, #0
 8004aaa:	bd70      	pop	{r4, r5, r6, pc}

08004aac <USBD_LL_SetSpeed>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8004aac:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 8004aae:	2000      	movs	r0, #0
 8004ab0:	4770      	bx	lr

08004ab2 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8004ab2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004ab6:	f880 329d 	strb.w	r3, [r0, #669]	; 0x29d
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8004aba:	2304      	movs	r3, #4
 8004abc:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  return USBD_OK;
}
 8004ac0:	2000      	movs	r0, #0
 8004ac2:	4770      	bx	lr

08004ac4 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8004ac4:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004ac8:	2b04      	cmp	r3, #4
 8004aca:	d001      	beq.n	8004ad0 <USBD_LL_Resume+0xc>
  {
    pdev->dev_state = pdev->dev_old_state;
  }

  return USBD_OK;
}
 8004acc:	2000      	movs	r0, #0
 8004ace:	4770      	bx	lr
    pdev->dev_state = pdev->dev_old_state;
 8004ad0:	f890 329d 	ldrb.w	r3, [r0, #669]	; 0x29d
 8004ad4:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
 8004ad8:	e7f8      	b.n	8004acc <USBD_LL_Resume+0x8>

08004ada <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8004ada:	b508      	push	{r3, lr}
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004adc:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004ae0:	2b03      	cmp	r3, #3
 8004ae2:	d001      	beq.n	8004ae8 <USBD_LL_SOF+0xe>
      pdev->pClass->SOF(pdev);
    }
  }

  return USBD_OK;
}
 8004ae4:	2000      	movs	r0, #0
 8004ae6:	bd08      	pop	{r3, pc}
    if (pdev->pClass->SOF != NULL)
 8004ae8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004aec:	69db      	ldr	r3, [r3, #28]
 8004aee:	2b00      	cmp	r3, #0
 8004af0:	d0f8      	beq.n	8004ae4 <USBD_LL_SOF+0xa>
      pdev->pClass->SOF(pdev);
 8004af2:	4798      	blx	r3
 8004af4:	e7f6      	b.n	8004ae4 <USBD_LL_SOF+0xa>

08004af6 <USBD_GetLen>:
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;
 8004af6:	2300      	movs	r3, #0

  while (*buf != '\0')
 8004af8:	e002      	b.n	8004b00 <USBD_GetLen+0xa>
  {
    len++;
 8004afa:	3301      	adds	r3, #1
 8004afc:	b2db      	uxtb	r3, r3
    buf++;
 8004afe:	3001      	adds	r0, #1
  while (*buf != '\0')
 8004b00:	7802      	ldrb	r2, [r0, #0]
 8004b02:	2a00      	cmp	r2, #0
 8004b04:	d1f9      	bne.n	8004afa <USBD_GetLen+0x4>
  }

  return len;
}
 8004b06:	4618      	mov	r0, r3
 8004b08:	4770      	bx	lr

08004b0a <USBD_SetFeature>:
{
 8004b0a:	b508      	push	{r3, lr}
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8004b0c:	884b      	ldrh	r3, [r1, #2]
 8004b0e:	2b01      	cmp	r3, #1
 8004b10:	d000      	beq.n	8004b14 <USBD_SetFeature+0xa>
 8004b12:	bd08      	pop	{r3, pc}
    pdev->dev_remote_wakeup = 1U;
 8004b14:	f8c0 32a4 	str.w	r3, [r0, #676]	; 0x2a4
    USBD_CtlSendStatus(pdev);
 8004b18:	f000 fb82 	bl	8005220 <USBD_CtlSendStatus>
}
 8004b1c:	e7f9      	b.n	8004b12 <USBD_SetFeature+0x8>

08004b1e <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pdata);
 8004b1e:	780b      	ldrb	r3, [r1, #0]
 8004b20:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pdata + 1U);
 8004b22:	784b      	ldrb	r3, [r1, #1]
 8004b24:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pdata + 2U);
 8004b26:	788b      	ldrb	r3, [r1, #2]
 8004b28:	78ca      	ldrb	r2, [r1, #3]
 8004b2a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004b2e:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pdata + 4U);
 8004b30:	790b      	ldrb	r3, [r1, #4]
 8004b32:	794a      	ldrb	r2, [r1, #5]
 8004b34:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004b38:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pdata + 6U);
 8004b3a:	798b      	ldrb	r3, [r1, #6]
 8004b3c:	79ca      	ldrb	r2, [r1, #7]
 8004b3e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004b42:	80c3      	strh	r3, [r0, #6]
 8004b44:	4770      	bx	lr

08004b46 <USBD_CtlError>:
{
 8004b46:	b510      	push	{r4, lr}
 8004b48:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev, 0x80U);
 8004b4a:	2180      	movs	r1, #128	; 0x80
 8004b4c:	f004 f851 	bl	8008bf2 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 8004b50:	2100      	movs	r1, #0
 8004b52:	4620      	mov	r0, r4
 8004b54:	f004 f84d 	bl	8008bf2 <USBD_LL_StallEP>
 8004b58:	bd10      	pop	{r4, pc}

08004b5a <USBD_GetDescriptor>:
{
 8004b5a:	b530      	push	{r4, r5, lr}
 8004b5c:	b083      	sub	sp, #12
 8004b5e:	4605      	mov	r5, r0
 8004b60:	460c      	mov	r4, r1
  uint16_t len = 0U;
 8004b62:	2300      	movs	r3, #0
 8004b64:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->wValue >> 8)
 8004b68:	884a      	ldrh	r2, [r1, #2]
 8004b6a:	0a13      	lsrs	r3, r2, #8
 8004b6c:	3b01      	subs	r3, #1
 8004b6e:	2b06      	cmp	r3, #6
 8004b70:	f200 80c2 	bhi.w	8004cf8 <USBD_GetDescriptor+0x19e>
 8004b74:	e8df f003 	tbb	[pc, r3]
 8004b78:	c0301a04 	.word	0xc0301a04
 8004b7c:	9ec0      	.short	0x9ec0
 8004b7e:	ae          	.byte	0xae
 8004b7f:	00          	.byte	0x00
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8004b80:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004b84:	681b      	ldr	r3, [r3, #0]
 8004b86:	f10d 0106 	add.w	r1, sp, #6
 8004b8a:	7c00      	ldrb	r0, [r0, #16]
 8004b8c:	4798      	blx	r3
  uint8_t err = 0U;
 8004b8e:	2300      	movs	r3, #0
  if (err != 0U)
 8004b90:	b953      	cbnz	r3, 8004ba8 <USBD_GetDescriptor+0x4e>
    if ((len != 0U) && (req->wLength != 0U))
 8004b92:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8004b96:	b11a      	cbz	r2, 8004ba0 <USBD_GetDescriptor+0x46>
 8004b98:	88e3      	ldrh	r3, [r4, #6]
 8004b9a:	2b00      	cmp	r3, #0
 8004b9c:	f040 80b2 	bne.w	8004d04 <USBD_GetDescriptor+0x1aa>
    if (req->wLength == 0U)
 8004ba0:	88e3      	ldrh	r3, [r4, #6]
 8004ba2:	2b00      	cmp	r3, #0
 8004ba4:	f000 80b8 	beq.w	8004d18 <USBD_GetDescriptor+0x1be>
}
 8004ba8:	b003      	add	sp, #12
 8004baa:	bd30      	pop	{r4, r5, pc}
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004bac:	7c03      	ldrb	r3, [r0, #16]
 8004bae:	b94b      	cbnz	r3, 8004bc4 <USBD_GetDescriptor+0x6a>
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 8004bb0:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004bb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004bb6:	f10d 0006 	add.w	r0, sp, #6
 8004bba:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004bbc:	2302      	movs	r3, #2
 8004bbe:	7043      	strb	r3, [r0, #1]
  uint8_t err = 0U;
 8004bc0:	2300      	movs	r3, #0
 8004bc2:	e7e5      	b.n	8004b90 <USBD_GetDescriptor+0x36>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 8004bc4:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004bc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004bca:	f10d 0006 	add.w	r0, sp, #6
 8004bce:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004bd0:	2302      	movs	r3, #2
 8004bd2:	7043      	strb	r3, [r0, #1]
  uint8_t err = 0U;
 8004bd4:	2300      	movs	r3, #0
 8004bd6:	e7db      	b.n	8004b90 <USBD_GetDescriptor+0x36>
      switch ((uint8_t)(req->wValue))
 8004bd8:	b2d2      	uxtb	r2, r2
 8004bda:	2a05      	cmp	r2, #5
 8004bdc:	d864      	bhi.n	8004ca8 <USBD_GetDescriptor+0x14e>
 8004bde:	e8df f002 	tbb	[pc, r2]
 8004be2:	1303      	.short	0x1303
 8004be4:	53433323 	.word	0x53433323
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8004be8:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004bec:	685b      	ldr	r3, [r3, #4]
 8004bee:	b12b      	cbz	r3, 8004bfc <USBD_GetDescriptor+0xa2>
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8004bf0:	f10d 0106 	add.w	r1, sp, #6
 8004bf4:	7c00      	ldrb	r0, [r0, #16]
 8004bf6:	4798      	blx	r3
  uint8_t err = 0U;
 8004bf8:	2300      	movs	r3, #0
 8004bfa:	e7c9      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004bfc:	4621      	mov	r1, r4
 8004bfe:	f7ff ffa2 	bl	8004b46 <USBD_CtlError>
            err++;
 8004c02:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004c04:	2000      	movs	r0, #0
 8004c06:	e7c3      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8004c08:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004c0c:	689b      	ldr	r3, [r3, #8]
 8004c0e:	b12b      	cbz	r3, 8004c1c <USBD_GetDescriptor+0xc2>
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8004c10:	f10d 0106 	add.w	r1, sp, #6
 8004c14:	7c00      	ldrb	r0, [r0, #16]
 8004c16:	4798      	blx	r3
  uint8_t err = 0U;
 8004c18:	2300      	movs	r3, #0
 8004c1a:	e7b9      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004c1c:	4621      	mov	r1, r4
 8004c1e:	f7ff ff92 	bl	8004b46 <USBD_CtlError>
            err++;
 8004c22:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004c24:	2000      	movs	r0, #0
 8004c26:	e7b3      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8004c28:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004c2c:	68db      	ldr	r3, [r3, #12]
 8004c2e:	b12b      	cbz	r3, 8004c3c <USBD_GetDescriptor+0xe2>
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8004c30:	f10d 0106 	add.w	r1, sp, #6
 8004c34:	7c00      	ldrb	r0, [r0, #16]
 8004c36:	4798      	blx	r3
  uint8_t err = 0U;
 8004c38:	2300      	movs	r3, #0
 8004c3a:	e7a9      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004c3c:	4621      	mov	r1, r4
 8004c3e:	f7ff ff82 	bl	8004b46 <USBD_CtlError>
            err++;
 8004c42:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004c44:	2000      	movs	r0, #0
 8004c46:	e7a3      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8004c48:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004c4c:	691b      	ldr	r3, [r3, #16]
 8004c4e:	b12b      	cbz	r3, 8004c5c <USBD_GetDescriptor+0x102>
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8004c50:	f10d 0106 	add.w	r1, sp, #6
 8004c54:	7c00      	ldrb	r0, [r0, #16]
 8004c56:	4798      	blx	r3
  uint8_t err = 0U;
 8004c58:	2300      	movs	r3, #0
 8004c5a:	e799      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004c5c:	4621      	mov	r1, r4
 8004c5e:	f7ff ff72 	bl	8004b46 <USBD_CtlError>
            err++;
 8004c62:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004c64:	2000      	movs	r0, #0
 8004c66:	e793      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8004c68:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004c6c:	695b      	ldr	r3, [r3, #20]
 8004c6e:	b12b      	cbz	r3, 8004c7c <USBD_GetDescriptor+0x122>
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8004c70:	f10d 0106 	add.w	r1, sp, #6
 8004c74:	7c00      	ldrb	r0, [r0, #16]
 8004c76:	4798      	blx	r3
  uint8_t err = 0U;
 8004c78:	2300      	movs	r3, #0
 8004c7a:	e789      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004c7c:	4621      	mov	r1, r4
 8004c7e:	f7ff ff62 	bl	8004b46 <USBD_CtlError>
            err++;
 8004c82:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004c84:	2000      	movs	r0, #0
 8004c86:	e783      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8004c88:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 8004c8c:	699b      	ldr	r3, [r3, #24]
 8004c8e:	b12b      	cbz	r3, 8004c9c <USBD_GetDescriptor+0x142>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8004c90:	f10d 0106 	add.w	r1, sp, #6
 8004c94:	7c00      	ldrb	r0, [r0, #16]
 8004c96:	4798      	blx	r3
  uint8_t err = 0U;
 8004c98:	2300      	movs	r3, #0
 8004c9a:	e779      	b.n	8004b90 <USBD_GetDescriptor+0x36>
            USBD_CtlError(pdev, req);
 8004c9c:	4621      	mov	r1, r4
 8004c9e:	f7ff ff52 	bl	8004b46 <USBD_CtlError>
            err++;
 8004ca2:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004ca4:	2000      	movs	r0, #0
 8004ca6:	e773      	b.n	8004b90 <USBD_GetDescriptor+0x36>
          USBD_CtlError(pdev, req);
 8004ca8:	4621      	mov	r1, r4
 8004caa:	f7ff ff4c 	bl	8004b46 <USBD_CtlError>
          err++;
 8004cae:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004cb0:	2000      	movs	r0, #0
 8004cb2:	e76d      	b.n	8004b90 <USBD_GetDescriptor+0x36>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004cb4:	7c03      	ldrb	r3, [r0, #16]
 8004cb6:	b93b      	cbnz	r3, 8004cc8 <USBD_GetDescriptor+0x16e>
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8004cb8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004cbc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004cbe:	f10d 0006 	add.w	r0, sp, #6
 8004cc2:	4798      	blx	r3
  uint8_t err = 0U;
 8004cc4:	2300      	movs	r3, #0
 8004cc6:	e763      	b.n	8004b90 <USBD_GetDescriptor+0x36>
        USBD_CtlError(pdev, req);
 8004cc8:	4621      	mov	r1, r4
 8004cca:	f7ff ff3c 	bl	8004b46 <USBD_CtlError>
        err++;
 8004cce:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004cd0:	2000      	movs	r0, #0
 8004cd2:	e75d      	b.n	8004b90 <USBD_GetDescriptor+0x36>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004cd4:	7c03      	ldrb	r3, [r0, #16]
 8004cd6:	b94b      	cbnz	r3, 8004cec <USBD_GetDescriptor+0x192>
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8004cd8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004cdc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004cde:	f10d 0006 	add.w	r0, sp, #6
 8004ce2:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8004ce4:	2307      	movs	r3, #7
 8004ce6:	7043      	strb	r3, [r0, #1]
  uint8_t err = 0U;
 8004ce8:	2300      	movs	r3, #0
 8004cea:	e751      	b.n	8004b90 <USBD_GetDescriptor+0x36>
        USBD_CtlError(pdev, req);
 8004cec:	4621      	mov	r1, r4
 8004cee:	f7ff ff2a 	bl	8004b46 <USBD_CtlError>
        err++;
 8004cf2:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004cf4:	2000      	movs	r0, #0
 8004cf6:	e74b      	b.n	8004b90 <USBD_GetDescriptor+0x36>
      USBD_CtlError(pdev, req);
 8004cf8:	4621      	mov	r1, r4
 8004cfa:	f7ff ff24 	bl	8004b46 <USBD_CtlError>
      err++;
 8004cfe:	2301      	movs	r3, #1
  uint8_t *pbuf = NULL;
 8004d00:	2000      	movs	r0, #0
      break;
 8004d02:	e745      	b.n	8004b90 <USBD_GetDescriptor+0x36>
      len = MIN(len, req->wLength);
 8004d04:	429a      	cmp	r2, r3
 8004d06:	bf28      	it	cs
 8004d08:	461a      	movcs	r2, r3
 8004d0a:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8004d0e:	4601      	mov	r1, r0
 8004d10:	4628      	mov	r0, r5
 8004d12:	f000 fa59 	bl	80051c8 <USBD_CtlSendData>
 8004d16:	e743      	b.n	8004ba0 <USBD_GetDescriptor+0x46>
      (void)USBD_CtlSendStatus(pdev);
 8004d18:	4628      	mov	r0, r5
 8004d1a:	f000 fa81 	bl	8005220 <USBD_CtlSendStatus>
 8004d1e:	e743      	b.n	8004ba8 <USBD_GetDescriptor+0x4e>

08004d20 <USBD_SetAddress>:
{
 8004d20:	b538      	push	{r3, r4, r5, lr}
 8004d22:	4604      	mov	r4, r0
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8004d24:	888b      	ldrh	r3, [r1, #4]
 8004d26:	b9f3      	cbnz	r3, 8004d66 <USBD_SetAddress+0x46>
 8004d28:	88cb      	ldrh	r3, [r1, #6]
 8004d2a:	b9e3      	cbnz	r3, 8004d66 <USBD_SetAddress+0x46>
 8004d2c:	884b      	ldrh	r3, [r1, #2]
 8004d2e:	2b7f      	cmp	r3, #127	; 0x7f
 8004d30:	d819      	bhi.n	8004d66 <USBD_SetAddress+0x46>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8004d32:	f003 057f 	and.w	r5, r3, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004d36:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004d3a:	2b03      	cmp	r3, #3
 8004d3c:	d00c      	beq.n	8004d58 <USBD_SetAddress+0x38>
      pdev->dev_address = dev_addr;
 8004d3e:	f880 529e 	strb.w	r5, [r0, #670]	; 0x29e
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8004d42:	4629      	mov	r1, r5
 8004d44:	f003 ff78 	bl	8008c38 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8004d48:	4620      	mov	r0, r4
 8004d4a:	f000 fa69 	bl	8005220 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8004d4e:	b135      	cbz	r5, 8004d5e <USBD_SetAddress+0x3e>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004d50:	2302      	movs	r3, #2
 8004d52:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 8004d56:	bd38      	pop	{r3, r4, r5, pc}
      USBD_CtlError(pdev, req);
 8004d58:	f7ff fef5 	bl	8004b46 <USBD_CtlError>
 8004d5c:	bd38      	pop	{r3, r4, r5, pc}
        pdev->dev_state = USBD_STATE_DEFAULT;
 8004d5e:	2301      	movs	r3, #1
 8004d60:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 8004d64:	bd38      	pop	{r3, r4, r5, pc}
    USBD_CtlError(pdev, req);
 8004d66:	4620      	mov	r0, r4
 8004d68:	f7ff feed 	bl	8004b46 <USBD_CtlError>
 8004d6c:	bd38      	pop	{r3, r4, r5, pc}
	...

08004d70 <USBD_SetConfig>:
{
 8004d70:	b538      	push	{r3, r4, r5, lr}
 8004d72:	4604      	mov	r4, r0
 8004d74:	460d      	mov	r5, r1
  cfgidx = (uint8_t)(req->wValue);
 8004d76:	7889      	ldrb	r1, [r1, #2]
 8004d78:	4b28      	ldr	r3, [pc, #160]	; (8004e1c <USBD_SetConfig+0xac>)
 8004d7a:	7019      	strb	r1, [r3, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8004d7c:	2901      	cmp	r1, #1
 8004d7e:	d80e      	bhi.n	8004d9e <USBD_SetConfig+0x2e>
    switch (pdev->dev_state)
 8004d80:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004d84:	2b02      	cmp	r3, #2
 8004d86:	d00e      	beq.n	8004da6 <USBD_SetConfig+0x36>
 8004d88:	2b03      	cmp	r3, #3
 8004d8a:	d021      	beq.n	8004dd0 <USBD_SetConfig+0x60>
        USBD_CtlError(pdev, req);
 8004d8c:	4629      	mov	r1, r5
 8004d8e:	f7ff feda 	bl	8004b46 <USBD_CtlError>
        USBD_ClrClassConfig(pdev, cfgidx);
 8004d92:	4b22      	ldr	r3, [pc, #136]	; (8004e1c <USBD_SetConfig+0xac>)
 8004d94:	7819      	ldrb	r1, [r3, #0]
 8004d96:	4620      	mov	r0, r4
 8004d98:	f7ff fd78 	bl	800488c <USBD_ClrClassConfig>
 8004d9c:	bd38      	pop	{r3, r4, r5, pc}
    USBD_CtlError(pdev, req);
 8004d9e:	4629      	mov	r1, r5
 8004da0:	f7ff fed1 	bl	8004b46 <USBD_CtlError>
 8004da4:	bd38      	pop	{r3, r4, r5, pc}
        if (cfgidx)
 8004da6:	b181      	cbz	r1, 8004dca <USBD_SetConfig+0x5a>
          pdev->dev_config = cfgidx;
 8004da8:	6041      	str	r1, [r0, #4]
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8004daa:	2303      	movs	r3, #3
 8004dac:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004db0:	f7ff fd5f 	bl	8004872 <USBD_SetClassConfig>
 8004db4:	2802      	cmp	r0, #2
 8004db6:	d003      	beq.n	8004dc0 <USBD_SetConfig+0x50>
          USBD_CtlSendStatus(pdev);
 8004db8:	4620      	mov	r0, r4
 8004dba:	f000 fa31 	bl	8005220 <USBD_CtlSendStatus>
 8004dbe:	bd38      	pop	{r3, r4, r5, pc}
            USBD_CtlError(pdev, req);
 8004dc0:	4629      	mov	r1, r5
 8004dc2:	4620      	mov	r0, r4
 8004dc4:	f7ff febf 	bl	8004b46 <USBD_CtlError>
            return;
 8004dc8:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlSendStatus(pdev);
 8004dca:	f000 fa29 	bl	8005220 <USBD_CtlSendStatus>
 8004dce:	bd38      	pop	{r3, r4, r5, pc}
        if (cfgidx == 0U)
 8004dd0:	b189      	cbz	r1, 8004df6 <USBD_SetConfig+0x86>
        else if (cfgidx != pdev->dev_config)
 8004dd2:	6843      	ldr	r3, [r0, #4]
 8004dd4:	4299      	cmp	r1, r3
 8004dd6:	d01d      	beq.n	8004e14 <USBD_SetConfig+0xa4>
          USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8004dd8:	b2d9      	uxtb	r1, r3
 8004dda:	f7ff fd57 	bl	800488c <USBD_ClrClassConfig>
          pdev->dev_config = cfgidx;
 8004dde:	4b0f      	ldr	r3, [pc, #60]	; (8004e1c <USBD_SetConfig+0xac>)
 8004de0:	7819      	ldrb	r1, [r3, #0]
 8004de2:	6061      	str	r1, [r4, #4]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004de4:	4620      	mov	r0, r4
 8004de6:	f7ff fd44 	bl	8004872 <USBD_SetClassConfig>
 8004dea:	2802      	cmp	r0, #2
 8004dec:	d00d      	beq.n	8004e0a <USBD_SetConfig+0x9a>
          USBD_CtlSendStatus(pdev);
 8004dee:	4620      	mov	r0, r4
 8004df0:	f000 fa16 	bl	8005220 <USBD_CtlSendStatus>
 8004df4:	bd38      	pop	{r3, r4, r5, pc}
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8004df6:	2302      	movs	r3, #2
 8004df8:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          pdev->dev_config = cfgidx;
 8004dfc:	6041      	str	r1, [r0, #4]
          USBD_ClrClassConfig(pdev, cfgidx);
 8004dfe:	f7ff fd45 	bl	800488c <USBD_ClrClassConfig>
          USBD_CtlSendStatus(pdev);
 8004e02:	4620      	mov	r0, r4
 8004e04:	f000 fa0c 	bl	8005220 <USBD_CtlSendStatus>
 8004e08:	bd38      	pop	{r3, r4, r5, pc}
            USBD_CtlError(pdev, req);
 8004e0a:	4629      	mov	r1, r5
 8004e0c:	4620      	mov	r0, r4
 8004e0e:	f7ff fe9a 	bl	8004b46 <USBD_CtlError>
            return;
 8004e12:	bd38      	pop	{r3, r4, r5, pc}
          USBD_CtlSendStatus(pdev);
 8004e14:	f000 fa04 	bl	8005220 <USBD_CtlSendStatus>
 8004e18:	bd38      	pop	{r3, r4, r5, pc}
 8004e1a:	bf00      	nop
 8004e1c:	20000208 	.word	0x20000208

08004e20 <USBD_GetConfig>:
{
 8004e20:	b508      	push	{r3, lr}
  if (req->wLength != 1U)
 8004e22:	88cb      	ldrh	r3, [r1, #6]
 8004e24:	2b01      	cmp	r3, #1
 8004e26:	d10b      	bne.n	8004e40 <USBD_GetConfig+0x20>
    switch (pdev->dev_state)
 8004e28:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004e2c:	b19b      	cbz	r3, 8004e56 <USBD_GetConfig+0x36>
 8004e2e:	2b02      	cmp	r3, #2
 8004e30:	d909      	bls.n	8004e46 <USBD_GetConfig+0x26>
 8004e32:	2b03      	cmp	r3, #3
 8004e34:	d10f      	bne.n	8004e56 <USBD_GetConfig+0x36>
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8004e36:	2201      	movs	r2, #1
 8004e38:	1d01      	adds	r1, r0, #4
 8004e3a:	f000 f9c5 	bl	80051c8 <USBD_CtlSendData>
        break;
 8004e3e:	bd08      	pop	{r3, pc}
    USBD_CtlError(pdev, req);
 8004e40:	f7ff fe81 	bl	8004b46 <USBD_CtlError>
 8004e44:	bd08      	pop	{r3, pc}
        pdev->dev_default_config = 0U;
 8004e46:	4601      	mov	r1, r0
 8004e48:	2300      	movs	r3, #0
 8004e4a:	f841 3f08 	str.w	r3, [r1, #8]!
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 8004e4e:	2201      	movs	r2, #1
 8004e50:	f000 f9ba 	bl	80051c8 <USBD_CtlSendData>
        break;
 8004e54:	bd08      	pop	{r3, pc}
        USBD_CtlError(pdev, req);
 8004e56:	f7ff fe76 	bl	8004b46 <USBD_CtlError>
 8004e5a:	bd08      	pop	{r3, pc}

08004e5c <USBD_GetStatus>:
{
 8004e5c:	b508      	push	{r3, lr}
  switch (pdev->dev_state)
 8004e5e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004e62:	3b01      	subs	r3, #1
 8004e64:	2b02      	cmp	r3, #2
 8004e66:	d812      	bhi.n	8004e8e <USBD_GetStatus+0x32>
      if (req->wLength != 0x2U)
 8004e68:	88cb      	ldrh	r3, [r1, #6]
 8004e6a:	2b02      	cmp	r3, #2
 8004e6c:	d10c      	bne.n	8004e88 <USBD_GetStatus+0x2c>
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 8004e6e:	2301      	movs	r3, #1
 8004e70:	60c3      	str	r3, [r0, #12]
      if (pdev->dev_remote_wakeup)
 8004e72:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
 8004e76:	b10b      	cbz	r3, 8004e7c <USBD_GetStatus+0x20>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 8004e78:	2303      	movs	r3, #3
 8004e7a:	60c3      	str	r3, [r0, #12]
      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 8004e7c:	2202      	movs	r2, #2
 8004e7e:	f100 010c 	add.w	r1, r0, #12
 8004e82:	f000 f9a1 	bl	80051c8 <USBD_CtlSendData>
      break;
 8004e86:	bd08      	pop	{r3, pc}
        USBD_CtlError(pdev, req);
 8004e88:	f7ff fe5d 	bl	8004b46 <USBD_CtlError>
        break;
 8004e8c:	bd08      	pop	{r3, pc}
      USBD_CtlError(pdev, req);
 8004e8e:	f7ff fe5a 	bl	8004b46 <USBD_CtlError>
 8004e92:	bd08      	pop	{r3, pc}

08004e94 <USBD_ClrFeature>:
{
 8004e94:	b508      	push	{r3, lr}
  switch (pdev->dev_state)
 8004e96:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004e9a:	3b01      	subs	r3, #1
 8004e9c:	2b02      	cmp	r3, #2
 8004e9e:	d809      	bhi.n	8004eb4 <USBD_ClrFeature+0x20>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8004ea0:	884b      	ldrh	r3, [r1, #2]
 8004ea2:	2b01      	cmp	r3, #1
 8004ea4:	d000      	beq.n	8004ea8 <USBD_ClrFeature+0x14>
 8004ea6:	bd08      	pop	{r3, pc}
        pdev->dev_remote_wakeup = 0U;
 8004ea8:	2300      	movs	r3, #0
 8004eaa:	f8c0 32a4 	str.w	r3, [r0, #676]	; 0x2a4
        USBD_CtlSendStatus(pdev);
 8004eae:	f000 f9b7 	bl	8005220 <USBD_CtlSendStatus>
 8004eb2:	bd08      	pop	{r3, pc}
      USBD_CtlError(pdev, req);
 8004eb4:	f7ff fe47 	bl	8004b46 <USBD_CtlError>
}
 8004eb8:	e7f5      	b.n	8004ea6 <USBD_ClrFeature+0x12>

08004eba <USBD_StdDevReq>:
{
 8004eba:	b508      	push	{r3, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004ebc:	780b      	ldrb	r3, [r1, #0]
 8004ebe:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004ec2:	2b20      	cmp	r3, #32
 8004ec4:	d005      	beq.n	8004ed2 <USBD_StdDevReq+0x18>
 8004ec6:	2b40      	cmp	r3, #64	; 0x40
 8004ec8:	d003      	beq.n	8004ed2 <USBD_StdDevReq+0x18>
 8004eca:	b143      	cbz	r3, 8004ede <USBD_StdDevReq+0x24>
      USBD_CtlError(pdev, req);
 8004ecc:	f7ff fe3b 	bl	8004b46 <USBD_CtlError>
      break;
 8004ed0:	e003      	b.n	8004eda <USBD_StdDevReq+0x20>
      pdev->pClass->Setup(pdev, req);
 8004ed2:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004ed6:	689b      	ldr	r3, [r3, #8]
 8004ed8:	4798      	blx	r3
}
 8004eda:	2000      	movs	r0, #0
 8004edc:	bd08      	pop	{r3, pc}
      switch (req->bRequest)
 8004ede:	784b      	ldrb	r3, [r1, #1]
 8004ee0:	2b09      	cmp	r3, #9
 8004ee2:	d81b      	bhi.n	8004f1c <USBD_StdDevReq+0x62>
 8004ee4:	e8df f003 	tbb	[pc, r3]
 8004ee8:	141a1711 	.word	0x141a1711
 8004eec:	1a05081a 	.word	0x1a05081a
 8004ef0:	0b0e      	.short	0x0b0e
          USBD_GetDescriptor(pdev, req);
 8004ef2:	f7ff fe32 	bl	8004b5a <USBD_GetDescriptor>
          break;
 8004ef6:	e7f0      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_SetAddress(pdev, req);
 8004ef8:	f7ff ff12 	bl	8004d20 <USBD_SetAddress>
          break;
 8004efc:	e7ed      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_SetConfig(pdev, req);
 8004efe:	f7ff ff37 	bl	8004d70 <USBD_SetConfig>
          break;
 8004f02:	e7ea      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_GetConfig(pdev, req);
 8004f04:	f7ff ff8c 	bl	8004e20 <USBD_GetConfig>
          break;
 8004f08:	e7e7      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_GetStatus(pdev, req);
 8004f0a:	f7ff ffa7 	bl	8004e5c <USBD_GetStatus>
          break;
 8004f0e:	e7e4      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_SetFeature(pdev, req);
 8004f10:	f7ff fdfb 	bl	8004b0a <USBD_SetFeature>
          break;
 8004f14:	e7e1      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_ClrFeature(pdev, req);
 8004f16:	f7ff ffbd 	bl	8004e94 <USBD_ClrFeature>
          break;
 8004f1a:	e7de      	b.n	8004eda <USBD_StdDevReq+0x20>
          USBD_CtlError(pdev, req);
 8004f1c:	f7ff fe13 	bl	8004b46 <USBD_CtlError>
          break;
 8004f20:	e7db      	b.n	8004eda <USBD_StdDevReq+0x20>

08004f22 <USBD_StdItfReq>:
{
 8004f22:	b538      	push	{r3, r4, r5, lr}
 8004f24:	4605      	mov	r5, r0
 8004f26:	460c      	mov	r4, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f28:	780b      	ldrb	r3, [r1, #0]
 8004f2a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004f2e:	2b20      	cmp	r3, #32
 8004f30:	d005      	beq.n	8004f3e <USBD_StdItfReq+0x1c>
 8004f32:	2b40      	cmp	r3, #64	; 0x40
 8004f34:	d003      	beq.n	8004f3e <USBD_StdItfReq+0x1c>
 8004f36:	b113      	cbz	r3, 8004f3e <USBD_StdItfReq+0x1c>
      USBD_CtlError(pdev, req);
 8004f38:	f7ff fe05 	bl	8004b46 <USBD_CtlError>
      break;
 8004f3c:	e00b      	b.n	8004f56 <USBD_StdItfReq+0x34>
      switch (pdev->dev_state)
 8004f3e:	f895 329c 	ldrb.w	r3, [r5, #668]	; 0x29c
 8004f42:	3b01      	subs	r3, #1
 8004f44:	2b02      	cmp	r3, #2
 8004f46:	d817      	bhi.n	8004f78 <USBD_StdItfReq+0x56>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8004f48:	7923      	ldrb	r3, [r4, #4]
 8004f4a:	2b01      	cmp	r3, #1
 8004f4c:	d905      	bls.n	8004f5a <USBD_StdItfReq+0x38>
            USBD_CtlError(pdev, req);
 8004f4e:	4621      	mov	r1, r4
 8004f50:	4628      	mov	r0, r5
 8004f52:	f7ff fdf8 	bl	8004b46 <USBD_CtlError>
}
 8004f56:	2000      	movs	r0, #0
 8004f58:	bd38      	pop	{r3, r4, r5, pc}
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8004f5a:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
 8004f5e:	689b      	ldr	r3, [r3, #8]
 8004f60:	4621      	mov	r1, r4
 8004f62:	4628      	mov	r0, r5
 8004f64:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8004f66:	88e3      	ldrh	r3, [r4, #6]
 8004f68:	2b00      	cmp	r3, #0
 8004f6a:	d1f4      	bne.n	8004f56 <USBD_StdItfReq+0x34>
 8004f6c:	2800      	cmp	r0, #0
 8004f6e:	d1f2      	bne.n	8004f56 <USBD_StdItfReq+0x34>
              USBD_CtlSendStatus(pdev);
 8004f70:	4628      	mov	r0, r5
 8004f72:	f000 f955 	bl	8005220 <USBD_CtlSendStatus>
 8004f76:	e7ee      	b.n	8004f56 <USBD_StdItfReq+0x34>
          USBD_CtlError(pdev, req);
 8004f78:	4621      	mov	r1, r4
 8004f7a:	4628      	mov	r0, r5
 8004f7c:	f7ff fde3 	bl	8004b46 <USBD_CtlError>
          break;
 8004f80:	e7e9      	b.n	8004f56 <USBD_StdItfReq+0x34>

08004f82 <USBD_StdEPReq>:
{
 8004f82:	b538      	push	{r3, r4, r5, lr}
 8004f84:	4604      	mov	r4, r0
  ep_addr  = LOBYTE(req->wIndex);
 8004f86:	888a      	ldrh	r2, [r1, #4]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004f88:	780b      	ldrb	r3, [r1, #0]
 8004f8a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004f8e:	2b20      	cmp	r3, #32
 8004f90:	d008      	beq.n	8004fa4 <USBD_StdEPReq+0x22>
 8004f92:	b2d0      	uxtb	r0, r2
 8004f94:	2b40      	cmp	r3, #64	; 0x40
 8004f96:	d005      	beq.n	8004fa4 <USBD_StdEPReq+0x22>
 8004f98:	b15b      	cbz	r3, 8004fb2 <USBD_StdEPReq+0x30>
      USBD_CtlError(pdev, req);
 8004f9a:	4620      	mov	r0, r4
 8004f9c:	f7ff fdd3 	bl	8004b46 <USBD_CtlError>
  return ret;
 8004fa0:	2000      	movs	r0, #0
      break;
 8004fa2:	bd38      	pop	{r3, r4, r5, pc}
      pdev->pClass->Setup(pdev, req);
 8004fa4:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004fa8:	689b      	ldr	r3, [r3, #8]
 8004faa:	4620      	mov	r0, r4
 8004fac:	4798      	blx	r3
  return ret;
 8004fae:	2000      	movs	r0, #0
      break;
 8004fb0:	bd38      	pop	{r3, r4, r5, pc}
      if ((req->bmRequest & 0x60U) == 0x20U)
 8004fb2:	2b20      	cmp	r3, #32
 8004fb4:	d012      	beq.n	8004fdc <USBD_StdEPReq+0x5a>
      switch (req->bRequest)
 8004fb6:	784b      	ldrb	r3, [r1, #1]
 8004fb8:	2b01      	cmp	r3, #1
 8004fba:	d038      	beq.n	800502e <USBD_StdEPReq+0xac>
 8004fbc:	2b00      	cmp	r3, #0
 8004fbe:	d064      	beq.n	800508a <USBD_StdEPReq+0x108>
 8004fc0:	2b03      	cmp	r3, #3
 8004fc2:	f040 80de 	bne.w	8005182 <USBD_StdEPReq+0x200>
          switch (pdev->dev_state)
 8004fc6:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8004fca:	2b02      	cmp	r3, #2
 8004fcc:	d00c      	beq.n	8004fe8 <USBD_StdEPReq+0x66>
 8004fce:	2b03      	cmp	r3, #3
 8004fd0:	d01c      	beq.n	800500c <USBD_StdEPReq+0x8a>
              USBD_CtlError(pdev, req);
 8004fd2:	4620      	mov	r0, r4
 8004fd4:	f7ff fdb7 	bl	8004b46 <USBD_CtlError>
  return ret;
 8004fd8:	2000      	movs	r0, #0
              break;
 8004fda:	bd38      	pop	{r3, r4, r5, pc}
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8004fdc:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 8004fe0:	689b      	ldr	r3, [r3, #8]
 8004fe2:	4620      	mov	r0, r4
 8004fe4:	4798      	blx	r3
        return ret;
 8004fe6:	bd38      	pop	{r3, r4, r5, pc}
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8004fe8:	b158      	cbz	r0, 8005002 <USBD_StdEPReq+0x80>
 8004fea:	2880      	cmp	r0, #128	; 0x80
 8004fec:	d009      	beq.n	8005002 <USBD_StdEPReq+0x80>
                USBD_LL_StallEP(pdev, ep_addr);
 8004fee:	4601      	mov	r1, r0
 8004ff0:	4620      	mov	r0, r4
 8004ff2:	f003 fdfe 	bl	8008bf2 <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 8004ff6:	2180      	movs	r1, #128	; 0x80
 8004ff8:	4620      	mov	r0, r4
 8004ffa:	f003 fdfa 	bl	8008bf2 <USBD_LL_StallEP>
  return ret;
 8004ffe:	2000      	movs	r0, #0
                USBD_LL_StallEP(pdev, 0x80U);
 8005000:	bd38      	pop	{r3, r4, r5, pc}
                USBD_CtlError(pdev, req);
 8005002:	4620      	mov	r0, r4
 8005004:	f7ff fd9f 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005008:	2000      	movs	r0, #0
 800500a:	bd38      	pop	{r3, r4, r5, pc}
              if (req->wValue == USB_FEATURE_EP_HALT)
 800500c:	884b      	ldrh	r3, [r1, #2]
 800500e:	b923      	cbnz	r3, 800501a <USBD_StdEPReq+0x98>
                if ((ep_addr != 0x00U) &&
 8005010:	b118      	cbz	r0, 800501a <USBD_StdEPReq+0x98>
 8005012:	2880      	cmp	r0, #128	; 0x80
 8005014:	d001      	beq.n	800501a <USBD_StdEPReq+0x98>
                    (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8005016:	88cb      	ldrh	r3, [r1, #6]
 8005018:	b123      	cbz	r3, 8005024 <USBD_StdEPReq+0xa2>
              USBD_CtlSendStatus(pdev);
 800501a:	4620      	mov	r0, r4
 800501c:	f000 f900 	bl	8005220 <USBD_CtlSendStatus>
  return ret;
 8005020:	2000      	movs	r0, #0
              break;
 8005022:	bd38      	pop	{r3, r4, r5, pc}
                  USBD_LL_StallEP(pdev, ep_addr);
 8005024:	4601      	mov	r1, r0
 8005026:	4620      	mov	r0, r4
 8005028:	f003 fde3 	bl	8008bf2 <USBD_LL_StallEP>
 800502c:	e7f5      	b.n	800501a <USBD_StdEPReq+0x98>
          switch (pdev->dev_state)
 800502e:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8005032:	2b02      	cmp	r3, #2
 8005034:	d006      	beq.n	8005044 <USBD_StdEPReq+0xc2>
 8005036:	2b03      	cmp	r3, #3
 8005038:	d016      	beq.n	8005068 <USBD_StdEPReq+0xe6>
              USBD_CtlError(pdev, req);
 800503a:	4620      	mov	r0, r4
 800503c:	f7ff fd83 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005040:	2000      	movs	r0, #0
              break;
 8005042:	bd38      	pop	{r3, r4, r5, pc}
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8005044:	b158      	cbz	r0, 800505e <USBD_StdEPReq+0xdc>
 8005046:	2880      	cmp	r0, #128	; 0x80
 8005048:	d009      	beq.n	800505e <USBD_StdEPReq+0xdc>
                USBD_LL_StallEP(pdev, ep_addr);
 800504a:	4601      	mov	r1, r0
 800504c:	4620      	mov	r0, r4
 800504e:	f003 fdd0 	bl	8008bf2 <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 8005052:	2180      	movs	r1, #128	; 0x80
 8005054:	4620      	mov	r0, r4
 8005056:	f003 fdcc 	bl	8008bf2 <USBD_LL_StallEP>
  return ret;
 800505a:	2000      	movs	r0, #0
                USBD_LL_StallEP(pdev, 0x80U);
 800505c:	bd38      	pop	{r3, r4, r5, pc}
                USBD_CtlError(pdev, req);
 800505e:	4620      	mov	r0, r4
 8005060:	f7ff fd71 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005064:	2000      	movs	r0, #0
 8005066:	bd38      	pop	{r3, r4, r5, pc}
              if (req->wValue == USB_FEATURE_EP_HALT)
 8005068:	884b      	ldrh	r3, [r1, #2]
 800506a:	2b00      	cmp	r3, #0
 800506c:	f040 808e 	bne.w	800518c <USBD_StdEPReq+0x20a>
                if ((ep_addr & 0x7FU) != 0x00U)
 8005070:	f010 0f7f 	tst.w	r0, #127	; 0x7f
 8005074:	d104      	bne.n	8005080 <USBD_StdEPReq+0xfe>
                USBD_CtlSendStatus(pdev);
 8005076:	4620      	mov	r0, r4
 8005078:	f000 f8d2 	bl	8005220 <USBD_CtlSendStatus>
  return ret;
 800507c:	2000      	movs	r0, #0
 800507e:	bd38      	pop	{r3, r4, r5, pc}
                  USBD_LL_ClearStallEP(pdev, ep_addr);
 8005080:	4601      	mov	r1, r0
 8005082:	4620      	mov	r0, r4
 8005084:	f003 fdbd 	bl	8008c02 <USBD_LL_ClearStallEP>
 8005088:	e7f5      	b.n	8005076 <USBD_StdEPReq+0xf4>
          switch (pdev->dev_state)
 800508a:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 800508e:	2b02      	cmp	r3, #2
 8005090:	d006      	beq.n	80050a0 <USBD_StdEPReq+0x11e>
 8005092:	2b03      	cmp	r3, #3
 8005094:	d02a      	beq.n	80050ec <USBD_StdEPReq+0x16a>
              USBD_CtlError(pdev, req);
 8005096:	4620      	mov	r0, r4
 8005098:	f7ff fd55 	bl	8004b46 <USBD_CtlError>
  return ret;
 800509c:	2000      	movs	r0, #0
              break;
 800509e:	bd38      	pop	{r3, r4, r5, pc}
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80050a0:	b108      	cbz	r0, 80050a6 <USBD_StdEPReq+0x124>
 80050a2:	2880      	cmp	r0, #128	; 0x80
 80050a4:	d113      	bne.n	80050ce <USBD_StdEPReq+0x14c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80050a6:	f012 0f80 	tst.w	r2, #128	; 0x80
 80050aa:	d115      	bne.n	80050d8 <USBD_StdEPReq+0x156>
                    &pdev->ep_out[ep_addr & 0x7FU];
 80050ac:	f000 007f 	and.w	r0, r0, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80050b0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80050b4:	0083      	lsls	r3, r0, #2
 80050b6:	f503 71a8 	add.w	r1, r3, #336	; 0x150
 80050ba:	4421      	add	r1, r4
 80050bc:	3104      	adds	r1, #4
              pep->status = 0x0000U;
 80050be:	2500      	movs	r5, #0
 80050c0:	600d      	str	r5, [r1, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 80050c2:	2202      	movs	r2, #2
 80050c4:	4620      	mov	r0, r4
 80050c6:	f000 f87f 	bl	80051c8 <USBD_CtlSendData>
  return ret;
 80050ca:	4628      	mov	r0, r5
              break;
 80050cc:	bd38      	pop	{r3, r4, r5, pc}
                USBD_CtlError(pdev, req);
 80050ce:	4620      	mov	r0, r4
 80050d0:	f7ff fd39 	bl	8004b46 <USBD_CtlError>
  return ret;
 80050d4:	2000      	movs	r0, #0
                break;
 80050d6:	bd38      	pop	{r3, r4, r5, pc}
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80050d8:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80050dc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80050e0:	0083      	lsls	r3, r0, #2
 80050e2:	f103 0110 	add.w	r1, r3, #16
 80050e6:	4421      	add	r1, r4
 80050e8:	3104      	adds	r1, #4
 80050ea:	e7e8      	b.n	80050be <USBD_StdEPReq+0x13c>
              if ((ep_addr & 0x80U) == 0x80U)
 80050ec:	b252      	sxtb	r2, r2
 80050ee:	2a00      	cmp	r2, #0
 80050f0:	db1e      	blt.n	8005130 <USBD_StdEPReq+0x1ae>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 80050f2:	f000 030f 	and.w	r3, r0, #15
 80050f6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80050fa:	009d      	lsls	r5, r3, #2
 80050fc:	4425      	add	r5, r4
 80050fe:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
 8005102:	b31b      	cbz	r3, 800514c <USBD_StdEPReq+0x1ca>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005104:	2a00      	cmp	r2, #0
 8005106:	db26      	blt.n	8005156 <USBD_StdEPReq+0x1d4>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8005108:	f000 027f 	and.w	r2, r0, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800510c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8005110:	0093      	lsls	r3, r2, #2
 8005112:	f503 75a8 	add.w	r5, r3, #336	; 0x150
 8005116:	4425      	add	r5, r4
 8005118:	3504      	adds	r5, #4
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 800511a:	b330      	cbz	r0, 800516a <USBD_StdEPReq+0x1e8>
 800511c:	2880      	cmp	r0, #128	; 0x80
 800511e:	d024      	beq.n	800516a <USBD_StdEPReq+0x1e8>
              else if (USBD_LL_IsStallEP(pdev, ep_addr))
 8005120:	4601      	mov	r1, r0
 8005122:	4620      	mov	r0, r4
 8005124:	f003 fd75 	bl	8008c12 <USBD_LL_IsStallEP>
 8005128:	b340      	cbz	r0, 800517c <USBD_StdEPReq+0x1fa>
                pep->status = 0x0001U;
 800512a:	2301      	movs	r3, #1
 800512c:	602b      	str	r3, [r5, #0]
 800512e:	e01e      	b.n	800516e <USBD_StdEPReq+0x1ec>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8005130:	f000 030f 	and.w	r3, r0, #15
 8005134:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005138:	009d      	lsls	r5, r3, #2
 800513a:	4425      	add	r5, r4
 800513c:	69ab      	ldr	r3, [r5, #24]
 800513e:	2b00      	cmp	r3, #0
 8005140:	d1e0      	bne.n	8005104 <USBD_StdEPReq+0x182>
                  USBD_CtlError(pdev, req);
 8005142:	4620      	mov	r0, r4
 8005144:	f7ff fcff 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005148:	2000      	movs	r0, #0
                  break;
 800514a:	bd38      	pop	{r3, r4, r5, pc}
                  USBD_CtlError(pdev, req);
 800514c:	4620      	mov	r0, r4
 800514e:	f7ff fcfa 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005152:	2000      	movs	r0, #0
                  break;
 8005154:	bd38      	pop	{r3, r4, r5, pc}
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8005156:	f000 027f 	and.w	r2, r0, #127	; 0x7f
 800515a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800515e:	0093      	lsls	r3, r2, #2
 8005160:	f103 0510 	add.w	r5, r3, #16
 8005164:	4425      	add	r5, r4
 8005166:	3504      	adds	r5, #4
 8005168:	e7d7      	b.n	800511a <USBD_StdEPReq+0x198>
                pep->status = 0x0000U;
 800516a:	2300      	movs	r3, #0
 800516c:	602b      	str	r3, [r5, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800516e:	2202      	movs	r2, #2
 8005170:	4629      	mov	r1, r5
 8005172:	4620      	mov	r0, r4
 8005174:	f000 f828 	bl	80051c8 <USBD_CtlSendData>
  return ret;
 8005178:	2000      	movs	r0, #0
              break;
 800517a:	bd38      	pop	{r3, r4, r5, pc}
                pep->status = 0x0000U;
 800517c:	2300      	movs	r3, #0
 800517e:	602b      	str	r3, [r5, #0]
 8005180:	e7f5      	b.n	800516e <USBD_StdEPReq+0x1ec>
          USBD_CtlError(pdev, req);
 8005182:	4620      	mov	r0, r4
 8005184:	f7ff fcdf 	bl	8004b46 <USBD_CtlError>
  return ret;
 8005188:	2000      	movs	r0, #0
          break;
 800518a:	bd38      	pop	{r3, r4, r5, pc}
  return ret;
 800518c:	2000      	movs	r0, #0
}
 800518e:	bd38      	pop	{r3, r4, r5, pc}

08005190 <USBD_GetString>:
  if (desc != NULL)
 8005190:	b1c8      	cbz	r0, 80051c6 <USBD_GetString+0x36>
{
 8005192:	b570      	push	{r4, r5, r6, lr}
 8005194:	460d      	mov	r5, r1
 8005196:	4616      	mov	r6, r2
 8005198:	4604      	mov	r4, r0
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 800519a:	f7ff fcac 	bl	8004af6 <USBD_GetLen>
 800519e:	3001      	adds	r0, #1
 80051a0:	0040      	lsls	r0, r0, #1
 80051a2:	8030      	strh	r0, [r6, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 80051a4:	7028      	strb	r0, [r5, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 80051a6:	2303      	movs	r3, #3
 80051a8:	706b      	strb	r3, [r5, #1]
 80051aa:	2302      	movs	r3, #2
    while (*desc != '\0')
 80051ac:	e007      	b.n	80051be <USBD_GetString+0x2e>
      unicode[idx++] = *desc++;
 80051ae:	1c5a      	adds	r2, r3, #1
 80051b0:	b2d2      	uxtb	r2, r2
 80051b2:	3401      	adds	r4, #1
 80051b4:	54e9      	strb	r1, [r5, r3]
      unicode[idx++] =  0U;
 80051b6:	3302      	adds	r3, #2
 80051b8:	b2db      	uxtb	r3, r3
 80051ba:	2100      	movs	r1, #0
 80051bc:	54a9      	strb	r1, [r5, r2]
    while (*desc != '\0')
 80051be:	7821      	ldrb	r1, [r4, #0]
 80051c0:	2900      	cmp	r1, #0
 80051c2:	d1f4      	bne.n	80051ae <USBD_GetString+0x1e>
 80051c4:	bd70      	pop	{r4, r5, r6, pc}
 80051c6:	4770      	bx	lr

080051c8 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint16_t len)
{
 80051c8:	b510      	push	{r4, lr}
 80051ca:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80051cc:	2202      	movs	r2, #2
 80051ce:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 80051d2:	61c3      	str	r3, [r0, #28]
  pdev->ep_in[0].rem_length   = len;
 80051d4:	6203      	str	r3, [r0, #32]

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80051d6:	460a      	mov	r2, r1
 80051d8:	2100      	movs	r1, #0
 80051da:	f003 fd35 	bl	8008c48 <USBD_LL_Transmit>

  return USBD_OK;
}
 80051de:	2000      	movs	r0, #0
 80051e0:	bd10      	pop	{r4, pc}

080051e2 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint16_t len)
{
 80051e2:	b508      	push	{r3, lr}
  /* Start the next transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80051e4:	4613      	mov	r3, r2
 80051e6:	460a      	mov	r2, r1
 80051e8:	2100      	movs	r1, #0
 80051ea:	f003 fd2d 	bl	8008c48 <USBD_LL_Transmit>

  return USBD_OK;
}
 80051ee:	2000      	movs	r0, #0
 80051f0:	bd08      	pop	{r3, pc}

080051f2 <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint16_t len)
{
 80051f2:	b510      	push	{r4, lr}
 80051f4:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 80051f6:	2203      	movs	r2, #3
 80051f8:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  pdev->ep_out[0].total_length = len;
 80051fc:	f8c0 315c 	str.w	r3, [r0, #348]	; 0x15c
  pdev->ep_out[0].rem_length   = len;
 8005200:	f8c0 3160 	str.w	r3, [r0, #352]	; 0x160

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005204:	460a      	mov	r2, r1
 8005206:	2100      	movs	r1, #0
 8005208:	f003 fd26 	bl	8008c58 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800520c:	2000      	movs	r0, #0
 800520e:	bd10      	pop	{r4, pc}

08005210 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint16_t len)
{
 8005210:	b508      	push	{r3, lr}
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8005212:	4613      	mov	r3, r2
 8005214:	460a      	mov	r2, r1
 8005216:	2100      	movs	r1, #0
 8005218:	f003 fd1e 	bl	8008c58 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800521c:	2000      	movs	r0, #0
 800521e:	bd08      	pop	{r3, pc}

08005220 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8005220:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005222:	2304      	movs	r3, #4
 8005224:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8005228:	2300      	movs	r3, #0
 800522a:	461a      	mov	r2, r3
 800522c:	4619      	mov	r1, r3
 800522e:	f003 fd0b 	bl	8008c48 <USBD_LL_Transmit>

  return USBD_OK;
}
 8005232:	2000      	movs	r0, #0
 8005234:	bd08      	pop	{r3, pc}

08005236 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 8005236:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8005238:	2305      	movs	r3, #5
 800523a:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800523e:	2300      	movs	r3, #0
 8005240:	461a      	mov	r2, r3
 8005242:	4619      	mov	r1, r3
 8005244:	f003 fd08 	bl	8008c58 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8005248:	2000      	movs	r0, #0
 800524a:	bd08      	pop	{r3, pc}

0800524c <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
 800524c:	b508      	push	{r3, lr}
  DSTATUS stat;
  
  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800524e:	4b04      	ldr	r3, [pc, #16]	; (8005260 <disk_status+0x14>)
 8005250:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8005254:	6852      	ldr	r2, [r2, #4]
 8005256:	6852      	ldr	r2, [r2, #4]
 8005258:	4403      	add	r3, r0
 800525a:	7a18      	ldrb	r0, [r3, #8]
 800525c:	4790      	blx	r2
  return stat;
}
 800525e:	bd08      	pop	{r3, pc}
 8005260:	2000042c 	.word	0x2000042c

08005264 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 8005264:	b508      	push	{r3, lr}
  DSTATUS stat = RES_OK;
  
  if(disk.is_initialized[pdrv] == 0)
 8005266:	4b08      	ldr	r3, [pc, #32]	; (8005288 <disk_initialize+0x24>)
 8005268:	5c1b      	ldrb	r3, [r3, r0]
 800526a:	b10b      	cbz	r3, 8005270 <disk_initialize+0xc>
  DSTATUS stat = RES_OK;
 800526c:	2000      	movs	r0, #0
  { 
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
  }
  return stat;
}
 800526e:	bd08      	pop	{r3, pc}
    disk.is_initialized[pdrv] = 1;
 8005270:	4b05      	ldr	r3, [pc, #20]	; (8005288 <disk_initialize+0x24>)
 8005272:	2201      	movs	r2, #1
 8005274:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8005276:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800527a:	6852      	ldr	r2, [r2, #4]
 800527c:	6812      	ldr	r2, [r2, #0]
 800527e:	4418      	add	r0, r3
 8005280:	7a00      	ldrb	r0, [r0, #8]
 8005282:	4790      	blx	r2
 8005284:	bd08      	pop	{r3, pc}
 8005286:	bf00      	nop
 8005288:	2000042c 	.word	0x2000042c

0800528c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800528c:	b538      	push	{r3, r4, r5, lr}
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800528e:	4c04      	ldr	r4, [pc, #16]	; (80052a0 <disk_read+0x14>)
 8005290:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8005294:	686d      	ldr	r5, [r5, #4]
 8005296:	68ad      	ldr	r5, [r5, #8]
 8005298:	4404      	add	r4, r0
 800529a:	7a20      	ldrb	r0, [r4, #8]
 800529c:	47a8      	blx	r5
  return res;
}
 800529e:	bd38      	pop	{r3, r4, r5, pc}
 80052a0:	2000042c 	.word	0x2000042c

080052a4 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 80052a4:	b538      	push	{r3, r4, r5, lr}
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80052a6:	4c04      	ldr	r4, [pc, #16]	; (80052b8 <disk_write+0x14>)
 80052a8:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 80052ac:	686d      	ldr	r5, [r5, #4]
 80052ae:	68ed      	ldr	r5, [r5, #12]
 80052b0:	4404      	add	r4, r0
 80052b2:	7a20      	ldrb	r0, [r4, #8]
 80052b4:	47a8      	blx	r5
  return res;
}
 80052b6:	bd38      	pop	{r3, r4, r5, pc}
 80052b8:	2000042c 	.word	0x2000042c

080052bc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 80052bc:	b510      	push	{r4, lr}
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 80052be:	4b04      	ldr	r3, [pc, #16]	; (80052d0 <disk_ioctl+0x14>)
 80052c0:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 80052c4:	6864      	ldr	r4, [r4, #4]
 80052c6:	6924      	ldr	r4, [r4, #16]
 80052c8:	4403      	add	r3, r0
 80052ca:	7a18      	ldrb	r0, [r3, #8]
 80052cc:	47a0      	blx	r4
  return res;
}
 80052ce:	bd10      	pop	{r4, pc}
 80052d0:	2000042c 	.word	0x2000042c

080052d4 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 80052d4:	b508      	push	{r3, lr}
  Stat = STA_NOINIT;
 80052d6:	2201      	movs	r2, #1
 80052d8:	4b06      	ldr	r3, [pc, #24]	; (80052f4 <SD_initialize+0x20>)
 80052da:	701a      	strb	r2, [r3, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 80052dc:	f002 f9b4 	bl	8007648 <BSP_SD_Init>
 80052e0:	b920      	cbnz	r0, 80052ec <SD_initialize+0x18>
  {
    Stat &= ~STA_NOINIT;
 80052e2:	4a04      	ldr	r2, [pc, #16]	; (80052f4 <SD_initialize+0x20>)
 80052e4:	7813      	ldrb	r3, [r2, #0]
 80052e6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 80052ea:	7013      	strb	r3, [r2, #0]
  }

  return Stat;
 80052ec:	4b01      	ldr	r3, [pc, #4]	; (80052f4 <SD_initialize+0x20>)
 80052ee:	7818      	ldrb	r0, [r3, #0]
}
 80052f0:	bd08      	pop	{r3, pc}
 80052f2:	bf00      	nop
 80052f4:	20000117 	.word	0x20000117

080052f8 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 80052f8:	b508      	push	{r3, lr}
  Stat = STA_NOINIT;
 80052fa:	2201      	movs	r2, #1
 80052fc:	4b06      	ldr	r3, [pc, #24]	; (8005318 <SD_status+0x20>)
 80052fe:	701a      	strb	r2, [r3, #0]

  if(BSP_SD_GetCardState() == MSD_OK)
 8005300:	f002 f988 	bl	8007614 <BSP_SD_GetCardState>
 8005304:	b920      	cbnz	r0, 8005310 <SD_status+0x18>
  {
    Stat &= ~STA_NOINIT;
 8005306:	4a04      	ldr	r2, [pc, #16]	; (8005318 <SD_status+0x20>)
 8005308:	7813      	ldrb	r3, [r2, #0]
 800530a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 800530e:	7013      	strb	r3, [r2, #0]
  }
  
  return Stat;
 8005310:	4b01      	ldr	r3, [pc, #4]	; (8005318 <SD_status+0x20>)
 8005312:	7818      	ldrb	r0, [r3, #0]
}
 8005314:	bd08      	pop	{r3, pc}
 8005316:	bf00      	nop
 8005318:	20000117 	.word	0x20000117

0800531c <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 800531c:	b510      	push	{r4, lr}
 800531e:	4608      	mov	r0, r1
 8005320:	4611      	mov	r1, r2
 8005322:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;
  uint32_t timeout = 100000;

  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 8005324:	4b08      	ldr	r3, [pc, #32]	; (8005348 <SD_read+0x2c>)
 8005326:	f002 f955 	bl	80075d4 <BSP_SD_ReadBlocks>
 800532a:	b938      	cbnz	r0, 800533c <SD_read+0x20>
 800532c:	4c07      	ldr	r4, [pc, #28]	; (800534c <SD_read+0x30>)
                       (uint32_t) (sector), 
                       count, SD_DATATIMEOUT) == MSD_OK)
  {
    while(BSP_SD_GetCardState()!= MSD_OK)
 800532e:	f002 f971 	bl	8007614 <BSP_SD_GetCardState>
 8005332:	b128      	cbz	r0, 8005340 <SD_read+0x24>
    {
      if (timeout-- == 0)
 8005334:	1e63      	subs	r3, r4, #1
 8005336:	b124      	cbz	r4, 8005342 <SD_read+0x26>
 8005338:	461c      	mov	r4, r3
 800533a:	e7f8      	b.n	800532e <SD_read+0x12>
  DRESULT res = RES_ERROR;
 800533c:	2001      	movs	r0, #1
 800533e:	bd10      	pop	{r4, pc}
 8005340:	bd10      	pop	{r4, pc}
      {
        return RES_ERROR;
 8005342:	2001      	movs	r0, #1
    }
    res = RES_OK;
  }
  
  return res;
}
 8005344:	bd10      	pop	{r4, pc}
 8005346:	bf00      	nop
 8005348:	05f5e100 	.word	0x05f5e100
 800534c:	000186a0 	.word	0x000186a0

08005350 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8005350:	b510      	push	{r4, lr}
 8005352:	4608      	mov	r0, r1
 8005354:	4611      	mov	r1, r2
 8005356:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;
  uint32_t timeout = 100000;

  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 8005358:	4b08      	ldr	r3, [pc, #32]	; (800537c <SD_write+0x2c>)
 800535a:	f002 f94b 	bl	80075f4 <BSP_SD_WriteBlocks>
 800535e:	b938      	cbnz	r0, 8005370 <SD_write+0x20>
 8005360:	4c07      	ldr	r4, [pc, #28]	; (8005380 <SD_write+0x30>)
                        (uint32_t)(sector), 
                        count, SD_DATATIMEOUT) == MSD_OK)
  {
    while(BSP_SD_GetCardState()!= MSD_OK)
 8005362:	f002 f957 	bl	8007614 <BSP_SD_GetCardState>
 8005366:	b128      	cbz	r0, 8005374 <SD_write+0x24>
    {
      if (timeout-- == 0)
 8005368:	1e63      	subs	r3, r4, #1
 800536a:	b124      	cbz	r4, 8005376 <SD_write+0x26>
 800536c:	461c      	mov	r4, r3
 800536e:	e7f8      	b.n	8005362 <SD_write+0x12>
  DRESULT res = RES_ERROR;
 8005370:	2001      	movs	r0, #1
 8005372:	bd10      	pop	{r4, pc}
 8005374:	bd10      	pop	{r4, pc}
      {
        return RES_ERROR;
 8005376:	2001      	movs	r0, #1
    }    
    res = RES_OK;
  }
  
  return res;
}
 8005378:	bd10      	pop	{r4, pc}
 800537a:	bf00      	nop
 800537c:	05f5e100 	.word	0x05f5e100
 8005380:	000186a0 	.word	0x000186a0

08005384 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005384:	4b14      	ldr	r3, [pc, #80]	; (80053d8 <SD_ioctl+0x54>)
 8005386:	781b      	ldrb	r3, [r3, #0]
 8005388:	f013 0f01 	tst.w	r3, #1
 800538c:	d001      	beq.n	8005392 <SD_ioctl+0xe>
 800538e:	2003      	movs	r0, #3
 8005390:	4770      	bx	lr
{
 8005392:	b510      	push	{r4, lr}
 8005394:	b088      	sub	sp, #32
 8005396:	4614      	mov	r4, r2
  
  switch (cmd)
 8005398:	2903      	cmp	r1, #3
 800539a:	d81b      	bhi.n	80053d4 <SD_ioctl+0x50>
 800539c:	e8df f001 	tbb	[pc, r1]
 80053a0:	130c0502 	.word	0x130c0502
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
 80053a4:	2000      	movs	r0, #0
  default:
    res = RES_PARERR;
  }
  
  return res;
}
 80053a6:	b008      	add	sp, #32
 80053a8:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80053aa:	4668      	mov	r0, sp
 80053ac:	f002 f93c 	bl	8007628 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80053b0:	9b06      	ldr	r3, [sp, #24]
 80053b2:	6023      	str	r3, [r4, #0]
    res = RES_OK;
 80053b4:	2000      	movs	r0, #0
    break;
 80053b6:	e7f6      	b.n	80053a6 <SD_ioctl+0x22>
    BSP_SD_GetCardInfo(&CardInfo);
 80053b8:	4668      	mov	r0, sp
 80053ba:	f002 f935 	bl	8007628 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 80053be:	9b07      	ldr	r3, [sp, #28]
 80053c0:	8023      	strh	r3, [r4, #0]
    res = RES_OK;
 80053c2:	2000      	movs	r0, #0
    break;
 80053c4:	e7ef      	b.n	80053a6 <SD_ioctl+0x22>
    BSP_SD_GetCardInfo(&CardInfo);
 80053c6:	4668      	mov	r0, sp
 80053c8:	f002 f92e 	bl	8007628 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize;
 80053cc:	9b07      	ldr	r3, [sp, #28]
 80053ce:	6023      	str	r3, [r4, #0]
    res = RES_OK;
 80053d0:	2000      	movs	r0, #0
    break;
 80053d2:	e7e8      	b.n	80053a6 <SD_ioctl+0x22>
    res = RES_PARERR;
 80053d4:	2004      	movs	r0, #4
 80053d6:	e7e6      	b.n	80053a6 <SD_ioctl+0x22>
 80053d8:	20000117 	.word	0x20000117

080053dc <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 80053dc:	e004      	b.n	80053e8 <mem_cpy+0xc>
		*d++ = *s++;
 80053de:	780a      	ldrb	r2, [r1, #0]
 80053e0:	7002      	strb	r2, [r0, #0]
 80053e2:	3101      	adds	r1, #1
 80053e4:	3001      	adds	r0, #1
	while (cnt--)
 80053e6:	461a      	mov	r2, r3
 80053e8:	1e53      	subs	r3, r2, #1
 80053ea:	2a00      	cmp	r2, #0
 80053ec:	d1f7      	bne.n	80053de <mem_cpy+0x2>
}
 80053ee:	4770      	bx	lr

080053f0 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80053f0:	e002      	b.n	80053f8 <mem_set+0x8>
		*d++ = (BYTE)val;
 80053f2:	7001      	strb	r1, [r0, #0]
 80053f4:	3001      	adds	r0, #1
	while (cnt--)
 80053f6:	461a      	mov	r2, r3
 80053f8:	1e53      	subs	r3, r2, #1
 80053fa:	2a00      	cmp	r2, #0
 80053fc:	d1f9      	bne.n	80053f2 <mem_set+0x2>
}
 80053fe:	4770      	bx	lr

08005400 <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
 8005400:	b470      	push	{r4, r5, r6}
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 8005402:	4603      	mov	r3, r0
	int r = 0;
 8005404:	2000      	movs	r0, #0

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8005406:	e001      	b.n	800540c <mem_cmp+0xc>
 8005408:	4629      	mov	r1, r5
 800540a:	4633      	mov	r3, r6
 800540c:	1e54      	subs	r4, r2, #1
 800540e:	b132      	cbz	r2, 800541e <mem_cmp+0x1e>
 8005410:	1c5e      	adds	r6, r3, #1
 8005412:	7818      	ldrb	r0, [r3, #0]
 8005414:	1c4d      	adds	r5, r1, #1
 8005416:	780b      	ldrb	r3, [r1, #0]
 8005418:	4622      	mov	r2, r4
 800541a:	1ac0      	subs	r0, r0, r3
 800541c:	d0f4      	beq.n	8005408 <mem_cmp+0x8>
	return r;
}
 800541e:	bc70      	pop	{r4, r5, r6}
 8005420:	4770      	bx	lr

08005422 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8005422:	e000      	b.n	8005426 <chk_chr+0x4>
 8005424:	3001      	adds	r0, #1
 8005426:	7803      	ldrb	r3, [r0, #0]
 8005428:	b10b      	cbz	r3, 800542e <chk_chr+0xc>
 800542a:	428b      	cmp	r3, r1
 800542c:	d1fa      	bne.n	8005424 <chk_chr+0x2>
	return *str;
}
 800542e:	4618      	mov	r0, r3
 8005430:	4770      	bx	lr
	...

08005434 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8005434:	b430      	push	{r4, r5}
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 8005436:	2500      	movs	r5, #0
 8005438:	462b      	mov	r3, r5
 800543a:	e001      	b.n	8005440 <chk_lock+0xc>
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
				Files[i].clu == dp->sclust &&
				Files[i].idx == dp->index) break;
		} else {			/* Blank entry */
			be = 1;
 800543c:	2501      	movs	r5, #1
	for (i = be = 0; i < _FS_LOCK; i++) {
 800543e:	3301      	adds	r3, #1
 8005440:	2b01      	cmp	r3, #1
 8005442:	d821      	bhi.n	8005488 <chk_lock+0x54>
		if (Files[i].fs) {	/* Existing entry */
 8005444:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 8005448:	00a2      	lsls	r2, r4, #2
 800544a:	4c1d      	ldr	r4, [pc, #116]	; (80054c0 <chk_lock+0x8c>)
 800544c:	58a2      	ldr	r2, [r4, r2]
 800544e:	2a00      	cmp	r2, #0
 8005450:	d0f4      	beq.n	800543c <chk_lock+0x8>
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
 8005452:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
 8005456:	6824      	ldr	r4, [r4, #0]
 8005458:	42a2      	cmp	r2, r4
 800545a:	d1f0      	bne.n	800543e <chk_lock+0xa>
				Files[i].clu == dp->sclust &&
 800545c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8005460:	0094      	lsls	r4, r2, #2
 8005462:	4a17      	ldr	r2, [pc, #92]	; (80054c0 <chk_lock+0x8c>)
 8005464:	4422      	add	r2, r4
 8005466:	6854      	ldr	r4, [r2, #4]
 8005468:	f241 0208 	movw	r2, #4104	; 0x1008
 800546c:	5882      	ldr	r2, [r0, r2]
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
 800546e:	4294      	cmp	r4, r2
 8005470:	d1e5      	bne.n	800543e <chk_lock+0xa>
				Files[i].idx == dp->index) break;
 8005472:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8005476:	0094      	lsls	r4, r2, #2
 8005478:	4a11      	ldr	r2, [pc, #68]	; (80054c0 <chk_lock+0x8c>)
 800547a:	4422      	add	r2, r4
 800547c:	8914      	ldrh	r4, [r2, #8]
 800547e:	f241 0206 	movw	r2, #4102	; 0x1006
 8005482:	5a82      	ldrh	r2, [r0, r2]
				Files[i].clu == dp->sclust &&
 8005484:	4294      	cmp	r4, r2
 8005486:	d1da      	bne.n	800543e <chk_lock+0xa>
		}
	}
	if (i == _FS_LOCK)	/* The object is not opened */
 8005488:	2b02      	cmp	r3, #2
 800548a:	d003      	beq.n	8005494 <chk_lock+0x60>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800548c:	b149      	cbz	r1, 80054a2 <chk_lock+0x6e>
 800548e:	2010      	movs	r0, #16
}
 8005490:	bc30      	pop	{r4, r5}
 8005492:	4770      	bx	lr
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8005494:	b995      	cbnz	r5, 80054bc <chk_lock+0x88>
 8005496:	2902      	cmp	r1, #2
 8005498:	d001      	beq.n	800549e <chk_lock+0x6a>
 800549a:	2012      	movs	r0, #18
 800549c:	e7f8      	b.n	8005490 <chk_lock+0x5c>
 800549e:	2000      	movs	r0, #0
 80054a0:	e7f6      	b.n	8005490 <chk_lock+0x5c>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80054a2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80054a6:	009a      	lsls	r2, r3, #2
 80054a8:	4b05      	ldr	r3, [pc, #20]	; (80054c0 <chk_lock+0x8c>)
 80054aa:	4413      	add	r3, r2
 80054ac:	895b      	ldrh	r3, [r3, #10]
 80054ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80054b2:	d001      	beq.n	80054b8 <chk_lock+0x84>
 80054b4:	2000      	movs	r0, #0
 80054b6:	e7eb      	b.n	8005490 <chk_lock+0x5c>
 80054b8:	2010      	movs	r0, #16
 80054ba:	e7e9      	b.n	8005490 <chk_lock+0x5c>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 80054bc:	2000      	movs	r0, #0
 80054be:	e7e7      	b.n	8005490 <chk_lock+0x5c>
 80054c0:	20000210 	.word	0x20000210

080054c4 <enq_lock>:
static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80054c4:	2000      	movs	r0, #0
 80054c6:	e000      	b.n	80054ca <enq_lock+0x6>
 80054c8:	3001      	adds	r0, #1
 80054ca:	2801      	cmp	r0, #1
 80054cc:	d806      	bhi.n	80054dc <enq_lock+0x18>
 80054ce:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80054d2:	0093      	lsls	r3, r2, #2
 80054d4:	4a03      	ldr	r2, [pc, #12]	; (80054e4 <enq_lock+0x20>)
 80054d6:	58d3      	ldr	r3, [r2, r3]
 80054d8:	2b00      	cmp	r3, #0
 80054da:	d1f5      	bne.n	80054c8 <enq_lock+0x4>
	return (i == _FS_LOCK) ? 0 : 1;
}
 80054dc:	3802      	subs	r0, #2
 80054de:	bf18      	it	ne
 80054e0:	2001      	movne	r0, #1
 80054e2:	4770      	bx	lr
 80054e4:	20000210 	.word	0x20000210

080054e8 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 80054e8:	b470      	push	{r4, r5, r6}
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80054ea:	2300      	movs	r3, #0
 80054ec:	e000      	b.n	80054f0 <inc_lock+0x8>
 80054ee:	3301      	adds	r3, #1
 80054f0:	2b01      	cmp	r3, #1
 80054f2:	d81f      	bhi.n	8005534 <inc_lock+0x4c>
		if (Files[i].fs == dp->fs &&
 80054f4:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 80054f8:	00a2      	lsls	r2, r4, #2
 80054fa:	4c32      	ldr	r4, [pc, #200]	; (80055c4 <inc_lock+0xdc>)
 80054fc:	58a4      	ldr	r4, [r4, r2]
 80054fe:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
 8005502:	6812      	ldr	r2, [r2, #0]
 8005504:	4294      	cmp	r4, r2
 8005506:	d1f2      	bne.n	80054ee <inc_lock+0x6>
			Files[i].clu == dp->sclust &&
 8005508:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800550c:	0094      	lsls	r4, r2, #2
 800550e:	4a2d      	ldr	r2, [pc, #180]	; (80055c4 <inc_lock+0xdc>)
 8005510:	4422      	add	r2, r4
 8005512:	6854      	ldr	r4, [r2, #4]
 8005514:	f241 0208 	movw	r2, #4104	; 0x1008
 8005518:	5882      	ldr	r2, [r0, r2]
		if (Files[i].fs == dp->fs &&
 800551a:	4294      	cmp	r4, r2
 800551c:	d1e7      	bne.n	80054ee <inc_lock+0x6>
			Files[i].idx == dp->index) break;
 800551e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8005522:	0094      	lsls	r4, r2, #2
 8005524:	4a27      	ldr	r2, [pc, #156]	; (80055c4 <inc_lock+0xdc>)
 8005526:	4422      	add	r2, r4
 8005528:	8914      	ldrh	r4, [r2, #8]
 800552a:	f241 0206 	movw	r2, #4102	; 0x1006
 800552e:	5a82      	ldrh	r2, [r0, r2]
			Files[i].clu == dp->sclust &&
 8005530:	4294      	cmp	r4, r2
 8005532:	d1dc      	bne.n	80054ee <inc_lock+0x6>
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 8005534:	2b02      	cmp	r3, #2
 8005536:	d03b      	beq.n	80055b0 <inc_lock+0xc8>
		Files[i].clu = dp->sclust;
		Files[i].idx = dp->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8005538:	b139      	cbz	r1, 800554a <inc_lock+0x62>
 800553a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800553e:	0090      	lsls	r0, r2, #2
 8005540:	4a20      	ldr	r2, [pc, #128]	; (80055c4 <inc_lock+0xdc>)
 8005542:	4402      	add	r2, r0
 8005544:	8952      	ldrh	r2, [r2, #10]
 8005546:	2a00      	cmp	r2, #0
 8005548:	d139      	bne.n	80055be <inc_lock+0xd6>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800554a:	2900      	cmp	r1, #0
 800554c:	d132      	bne.n	80055b4 <inc_lock+0xcc>
 800554e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8005552:	0091      	lsls	r1, r2, #2
 8005554:	4a1b      	ldr	r2, [pc, #108]	; (80055c4 <inc_lock+0xdc>)
 8005556:	440a      	add	r2, r1
 8005558:	8951      	ldrh	r1, [r2, #10]
 800555a:	3101      	adds	r1, #1
 800555c:	b289      	uxth	r1, r1
 800555e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8005562:	0090      	lsls	r0, r2, #2
 8005564:	4a17      	ldr	r2, [pc, #92]	; (80055c4 <inc_lock+0xdc>)
 8005566:	4402      	add	r2, r0
 8005568:	8151      	strh	r1, [r2, #10]

	return i + 1;
 800556a:	1c58      	adds	r0, r3, #1
}
 800556c:	bc70      	pop	{r4, r5, r6}
 800556e:	4770      	bx	lr
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8005570:	3301      	adds	r3, #1
 8005572:	2b01      	cmp	r3, #1
 8005574:	d806      	bhi.n	8005584 <inc_lock+0x9c>
 8005576:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 800557a:	00a2      	lsls	r2, r4, #2
 800557c:	4c11      	ldr	r4, [pc, #68]	; (80055c4 <inc_lock+0xdc>)
 800557e:	58a2      	ldr	r2, [r4, r2]
 8005580:	2a00      	cmp	r2, #0
 8005582:	d1f5      	bne.n	8005570 <inc_lock+0x88>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8005584:	2b02      	cmp	r3, #2
 8005586:	d018      	beq.n	80055ba <inc_lock+0xd2>
		Files[i].fs = dp->fs;
 8005588:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
 800558c:	6816      	ldr	r6, [r2, #0]
 800558e:	4d0d      	ldr	r5, [pc, #52]	; (80055c4 <inc_lock+0xdc>)
 8005590:	005a      	lsls	r2, r3, #1
 8005592:	441a      	add	r2, r3
 8005594:	0094      	lsls	r4, r2, #2
 8005596:	192a      	adds	r2, r5, r4
 8005598:	512e      	str	r6, [r5, r4]
		Files[i].clu = dp->sclust;
 800559a:	f241 0408 	movw	r4, #4104	; 0x1008
 800559e:	5904      	ldr	r4, [r0, r4]
 80055a0:	6054      	str	r4, [r2, #4]
		Files[i].idx = dp->index;
 80055a2:	f241 0406 	movw	r4, #4102	; 0x1006
 80055a6:	5b00      	ldrh	r0, [r0, r4]
 80055a8:	8110      	strh	r0, [r2, #8]
		Files[i].ctr = 0;
 80055aa:	2000      	movs	r0, #0
 80055ac:	8150      	strh	r0, [r2, #10]
 80055ae:	e7c3      	b.n	8005538 <inc_lock+0x50>
 80055b0:	2300      	movs	r3, #0
 80055b2:	e7de      	b.n	8005572 <inc_lock+0x8a>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80055b4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80055b8:	e7d1      	b.n	800555e <inc_lock+0x76>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 80055ba:	2000      	movs	r0, #0
 80055bc:	e7d6      	b.n	800556c <inc_lock+0x84>
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80055be:	2000      	movs	r0, #0
 80055c0:	e7d4      	b.n	800556c <inc_lock+0x84>
 80055c2:	bf00      	nop
 80055c4:	20000210 	.word	0x20000210

080055c8 <dec_lock>:
{
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 80055c8:	3801      	subs	r0, #1
 80055ca:	2801      	cmp	r0, #1
 80055cc:	d901      	bls.n	80055d2 <dec_lock+0xa>
		if (n) n--;					/* Decrement read mode open count */
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
		res = FR_OK;
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 80055ce:	2002      	movs	r0, #2
 80055d0:	4770      	bx	lr
		n = Files[i].ctr;
 80055d2:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 80055d6:	009a      	lsls	r2, r3, #2
 80055d8:	4b0b      	ldr	r3, [pc, #44]	; (8005608 <dec_lock+0x40>)
 80055da:	4413      	add	r3, r2
 80055dc:	895b      	ldrh	r3, [r3, #10]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 80055de:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80055e2:	d00d      	beq.n	8005600 <dec_lock+0x38>
		if (n) n--;					/* Decrement read mode open count */
 80055e4:	b10b      	cbz	r3, 80055ea <dec_lock+0x22>
 80055e6:	3b01      	subs	r3, #1
 80055e8:	b29b      	uxth	r3, r3
		Files[i].ctr = n;
 80055ea:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80055ee:	0091      	lsls	r1, r2, #2
 80055f0:	4a05      	ldr	r2, [pc, #20]	; (8005608 <dec_lock+0x40>)
 80055f2:	440a      	add	r2, r1
 80055f4:	8153      	strh	r3, [r2, #10]
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 80055f6:	b92b      	cbnz	r3, 8005604 <dec_lock+0x3c>
 80055f8:	2000      	movs	r0, #0
 80055fa:	4a03      	ldr	r2, [pc, #12]	; (8005608 <dec_lock+0x40>)
 80055fc:	5050      	str	r0, [r2, r1]
 80055fe:	4770      	bx	lr
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8005600:	2300      	movs	r3, #0
 8005602:	e7ef      	b.n	80055e4 <dec_lock+0x1c>
		res = FR_OK;
 8005604:	2000      	movs	r0, #0
	}
	return res;
}
 8005606:	4770      	bx	lr
 8005608:	20000210 	.word	0x20000210

0800560c <clear_lock>:
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 800560c:	2300      	movs	r3, #0
 800560e:	2b01      	cmp	r3, #1
 8005610:	d813      	bhi.n	800563a <clear_lock+0x2e>
{
 8005612:	b410      	push	{r4}
		if (Files[i].fs == fs) Files[i].fs = 0;
 8005614:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8005618:	008a      	lsls	r2, r1, #2
 800561a:	4908      	ldr	r1, [pc, #32]	; (800563c <clear_lock+0x30>)
 800561c:	588a      	ldr	r2, [r1, r2]
 800561e:	4282      	cmp	r2, r0
 8005620:	d004      	beq.n	800562c <clear_lock+0x20>
	for (i = 0; i < _FS_LOCK; i++) {
 8005622:	3301      	adds	r3, #1
 8005624:	2b01      	cmp	r3, #1
 8005626:	d9f5      	bls.n	8005614 <clear_lock+0x8>
	}
}
 8005628:	bc10      	pop	{r4}
 800562a:	4770      	bx	lr
		if (Files[i].fs == fs) Files[i].fs = 0;
 800562c:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8005630:	008a      	lsls	r2, r1, #2
 8005632:	2400      	movs	r4, #0
 8005634:	4901      	ldr	r1, [pc, #4]	; (800563c <clear_lock+0x30>)
 8005636:	508c      	str	r4, [r1, r2]
 8005638:	e7f3      	b.n	8005622 <clear_lock+0x16>
 800563a:	4770      	bx	lr
 800563c:	20000210 	.word	0x20000210

08005640 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8005640:	f241 0324 	movw	r3, #4132	; 0x1024
 8005644:	58c2      	ldr	r2, [r0, r3]
 8005646:	3204      	adds	r2, #4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 8005648:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800564c:	6800      	ldr	r0, [r0, #0]
 800564e:	f241 030a 	movw	r3, #4106	; 0x100a
 8005652:	5ac3      	ldrh	r3, [r0, r3]
 8005654:	fbb1 f1f3 	udiv	r1, r1, r3
 8005658:	f241 0302 	movw	r3, #4098	; 0x1002
 800565c:	5cc3      	ldrb	r3, [r0, r3]
 800565e:	fbb1 f1f3 	udiv	r1, r1, r3
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8005662:	6810      	ldr	r0, [r2, #0]
		if (!ncl) return 0;		/* End of table? (error) */
 8005664:	b130      	cbz	r0, 8005674 <clmt_clust+0x34>
		if (cl < ncl) break;	/* In this fragment? */
 8005666:	4281      	cmp	r1, r0
 8005668:	d302      	bcc.n	8005670 <clmt_clust+0x30>
		cl -= ncl; tbl++;		/* Next fragment */
 800566a:	1a09      	subs	r1, r1, r0
 800566c:	3208      	adds	r2, #8
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800566e:	e7f8      	b.n	8005662 <clmt_clust+0x22>
	}
	return cl + *tbl;	/* Return the cluster number */
 8005670:	6850      	ldr	r0, [r2, #4]
 8005672:	4408      	add	r0, r1
}
 8005674:	4770      	bx	lr

08005676 <ld_clust>:
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8005676:	7eca      	ldrb	r2, [r1, #27]
 8005678:	7e8b      	ldrb	r3, [r1, #26]
 800567a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fs->fs_type == FS_FAT32)
 800567e:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8005682:	7802      	ldrb	r2, [r0, #0]
 8005684:	2a03      	cmp	r2, #3
 8005686:	d001      	beq.n	800568c <ld_clust+0x16>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
 8005688:	4618      	mov	r0, r3
 800568a:	4770      	bx	lr
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
 800568c:	7d48      	ldrb	r0, [r1, #21]
 800568e:	7d0a      	ldrb	r2, [r1, #20]
 8005690:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8005694:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	return cl;
 8005698:	e7f6      	b.n	8005688 <ld_clust+0x12>

0800569a <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 800569a:	7681      	strb	r1, [r0, #26]
 800569c:	f3c1 2307 	ubfx	r3, r1, #8, #8
 80056a0:	76c3      	strb	r3, [r0, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80056a2:	0c09      	lsrs	r1, r1, #16
 80056a4:	7501      	strb	r1, [r0, #20]
 80056a6:	0a09      	lsrs	r1, r1, #8
 80056a8:	7541      	strb	r1, [r0, #21]
 80056aa:	4770      	bx	lr

080056ac <pick_lfn>:
static
int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
	WCHAR* lfnbuf,		/* Pointer to the Unicode-LFN buffer */
	BYTE* dir			/* Pointer to the directory entry */
)
{
 80056ac:	b4f0      	push	{r4, r5, r6, r7}
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80056ae:	780d      	ldrb	r5, [r1, #0]
 80056b0:	f005 053f 	and.w	r5, r5, #63	; 0x3f
 80056b4:	3d01      	subs	r5, #1
 80056b6:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 80056ba:	eb05 0583 	add.w	r5, r5, r3, lsl #2

	s = 0; wc = 1;
 80056be:	2701      	movs	r7, #1
 80056c0:	2200      	movs	r2, #0
 80056c2:	e006      	b.n	80056d2 <pick_lfn+0x26>
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last character has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80056c4:	f64f 74ff 	movw	r4, #65535	; 0xffff
 80056c8:	42a3      	cmp	r3, r4
 80056ca:	d11f      	bne.n	800570c <pick_lfn+0x60>
		}
	} while (++s < 13);						/* Read all character in the entry */
 80056cc:	3201      	adds	r2, #1
 80056ce:	2a0c      	cmp	r2, #12
 80056d0:	d80f      	bhi.n	80056f2 <pick_lfn+0x46>
		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character from the entry */
 80056d2:	4b12      	ldr	r3, [pc, #72]	; (800571c <pick_lfn+0x70>)
 80056d4:	5c9c      	ldrb	r4, [r3, r2]
 80056d6:	1c63      	adds	r3, r4, #1
 80056d8:	5cce      	ldrb	r6, [r1, r3]
 80056da:	5d0b      	ldrb	r3, [r1, r4]
 80056dc:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
		if (wc) {	/* Last character has not been processed */
 80056e0:	2f00      	cmp	r7, #0
 80056e2:	d0ef      	beq.n	80056c4 <pick_lfn+0x18>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 80056e4:	2dfe      	cmp	r5, #254	; 0xfe
 80056e6:	d80f      	bhi.n	8005708 <pick_lfn+0x5c>
			lfnbuf[i++] = wc = uc;			/* Store it */
 80056e8:	f820 3015 	strh.w	r3, [r0, r5, lsl #1]
 80056ec:	461f      	mov	r7, r3
 80056ee:	3501      	adds	r5, #1
 80056f0:	e7ec      	b.n	80056cc <pick_lfn+0x20>

	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 80056f2:	780b      	ldrb	r3, [r1, #0]
 80056f4:	f013 0f40 	tst.w	r3, #64	; 0x40
 80056f8:	d00a      	beq.n	8005710 <pick_lfn+0x64>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 80056fa:	2dfe      	cmp	r5, #254	; 0xfe
 80056fc:	d80b      	bhi.n	8005716 <pick_lfn+0x6a>
		lfnbuf[i] = 0;
 80056fe:	2300      	movs	r3, #0
 8005700:	f820 3015 	strh.w	r3, [r0, r5, lsl #1]
	}

	return 1;
 8005704:	2001      	movs	r0, #1
 8005706:	e004      	b.n	8005712 <pick_lfn+0x66>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 8005708:	2000      	movs	r0, #0
 800570a:	e002      	b.n	8005712 <pick_lfn+0x66>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800570c:	2000      	movs	r0, #0
 800570e:	e000      	b.n	8005712 <pick_lfn+0x66>
	return 1;
 8005710:	2001      	movs	r0, #1
}
 8005712:	bcf0      	pop	{r4, r5, r6, r7}
 8005714:	4770      	bx	lr
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 8005716:	2000      	movs	r0, #0
 8005718:	e7fb      	b.n	8005712 <pick_lfn+0x66>
 800571a:	bf00      	nop
 800571c:	08009f68 	.word	0x08009f68

08005720 <fit_lfn>:
	const WCHAR* lfnbuf,	/* Pointer to the LFN buffer */
	BYTE* dir,				/* Pointer to the directory entry */
	BYTE ord,				/* LFN order (1-20) */
	BYTE sum				/* SFN sum */
)
{
 8005720:	b4f0      	push	{r4, r5, r6, r7}
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 8005722:	734b      	strb	r3, [r1, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8005724:	230f      	movs	r3, #15
 8005726:	72cb      	strb	r3, [r1, #11]
	dir[LDIR_Type] = 0;
 8005728:	2500      	movs	r5, #0
 800572a:	730d      	strb	r5, [r1, #12]
	ST_WORD(dir + LDIR_FstClusLO, 0);
 800572c:	768d      	strb	r5, [r1, #26]
 800572e:	76cd      	strb	r5, [r1, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 8005730:	1e56      	subs	r6, r2, #1
 8005732:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 8005736:	eb06 0683 	add.w	r6, r6, r3, lsl #2
	s = wc = 0;
 800573a:	462b      	mov	r3, r5
 800573c:	e002      	b.n	8005744 <fit_lfn+0x24>
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
 800573e:	3501      	adds	r5, #1
 8005740:	2d0c      	cmp	r5, #12
 8005742:	d811      	bhi.n	8005768 <fit_lfn+0x48>
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8005744:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8005748:	42a3      	cmp	r3, r4
 800574a:	d002      	beq.n	8005752 <fit_lfn+0x32>
 800574c:	f830 3016 	ldrh.w	r3, [r0, r6, lsl #1]
 8005750:	3601      	adds	r6, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8005752:	4c0b      	ldr	r4, [pc, #44]	; (8005780 <fit_lfn+0x60>)
 8005754:	5d64      	ldrb	r4, [r4, r5]
 8005756:	550b      	strb	r3, [r1, r4]
 8005758:	3401      	adds	r4, #1
 800575a:	0a1f      	lsrs	r7, r3, #8
 800575c:	550f      	strb	r7, [r1, r4]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 800575e:	2b00      	cmp	r3, #0
 8005760:	d1ed      	bne.n	800573e <fit_lfn+0x1e>
 8005762:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005766:	e7ea      	b.n	800573e <fit_lfn+0x1e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
 8005768:	f64f 74ff 	movw	r4, #65535	; 0xffff
 800576c:	42a3      	cmp	r3, r4
 800576e:	d002      	beq.n	8005776 <fit_lfn+0x56>
 8005770:	f830 3016 	ldrh.w	r3, [r0, r6, lsl #1]
 8005774:	b90b      	cbnz	r3, 800577a <fit_lfn+0x5a>
 8005776:	f042 0240 	orr.w	r2, r2, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 800577a:	700a      	strb	r2, [r1, #0]
}
 800577c:	bcf0      	pop	{r4, r5, r6, r7}
 800577e:	4770      	bx	lr
 8005780:	08009f68 	.word	0x08009f68

08005784 <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 8005784:	b570      	push	{r4, r5, r6, lr}
 8005786:	b082      	sub	sp, #8
 8005788:	4605      	mov	r5, r0
 800578a:	4616      	mov	r6, r2
 800578c:	461c      	mov	r4, r3
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 800578e:	220b      	movs	r2, #11
 8005790:	f7ff fe24 	bl	80053dc <mem_cpy>

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 8005794:	2c05      	cmp	r4, #5
 8005796:	d811      	bhi.n	80057bc <gen_numname+0x38>
				sr = (sr << 1) + (wc & 1);
				wc >>= 1;
				if (sr & 0x10000) sr ^= 0x11021;
			}
		}
		seq = (UINT)sr;
 8005798:	2307      	movs	r3, #7
 800579a:	e01f      	b.n	80057dc <gen_numname+0x58>
			for (i = 0; i < 16; i++) {
 800579c:	3101      	adds	r1, #1
 800579e:	290f      	cmp	r1, #15
 80057a0:	d80d      	bhi.n	80057be <gen_numname+0x3a>
				sr = (sr << 1) + (wc & 1);
 80057a2:	f002 0001 	and.w	r0, r2, #1
 80057a6:	eb00 0343 	add.w	r3, r0, r3, lsl #1
				wc >>= 1;
 80057aa:	0852      	lsrs	r2, r2, #1
				if (sr & 0x10000) sr ^= 0x11021;
 80057ac:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80057b0:	d0f4      	beq.n	800579c <gen_numname+0x18>
 80057b2:	f483 3388 	eor.w	r3, r3, #69632	; 0x11000
 80057b6:	f083 0321 	eor.w	r3, r3, #33	; 0x21
 80057ba:	e7ef      	b.n	800579c <gen_numname+0x18>
 80057bc:	4623      	mov	r3, r4
		while (*lfn) {	/* Create a CRC */
 80057be:	8832      	ldrh	r2, [r6, #0]
 80057c0:	b112      	cbz	r2, 80057c8 <gen_numname+0x44>
			wc = *lfn++;
 80057c2:	3602      	adds	r6, #2
			for (i = 0; i < 16; i++) {
 80057c4:	2100      	movs	r1, #0
 80057c6:	e7ea      	b.n	800579e <gen_numname+0x1a>
		seq = (UINT)sr;
 80057c8:	461c      	mov	r4, r3
 80057ca:	e7e5      	b.n	8005798 <gen_numname+0x14>
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
 80057cc:	1e5a      	subs	r2, r3, #1
 80057ce:	a802      	add	r0, sp, #8
 80057d0:	4403      	add	r3, r0
 80057d2:	f803 1c08 	strb.w	r1, [r3, #-8]
		seq /= 16;
	} while (seq);
 80057d6:	0924      	lsrs	r4, r4, #4
 80057d8:	d009      	beq.n	80057ee <gen_numname+0x6a>
		ns[i--] = c;
 80057da:	4613      	mov	r3, r2
		c = (seq % 16) + '0';
 80057dc:	f004 020f 	and.w	r2, r4, #15
 80057e0:	f102 0130 	add.w	r1, r2, #48	; 0x30
		if (c > '9') c += 7;
 80057e4:	2939      	cmp	r1, #57	; 0x39
 80057e6:	d9f1      	bls.n	80057cc <gen_numname+0x48>
 80057e8:	f102 0137 	add.w	r1, r2, #55	; 0x37
 80057ec:	e7ee      	b.n	80057cc <gen_numname+0x48>
	ns[i] = '~';
 80057ee:	217e      	movs	r1, #126	; 0x7e
 80057f0:	4603      	mov	r3, r0
 80057f2:	4413      	add	r3, r2
 80057f4:	f803 1c08 	strb.w	r1, [r3, #-8]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 80057f8:	e000      	b.n	80057fc <gen_numname+0x78>
 80057fa:	3401      	adds	r4, #1
 80057fc:	4294      	cmp	r4, r2
 80057fe:	d208      	bcs.n	8005812 <gen_numname+0x8e>
 8005800:	5d2b      	ldrb	r3, [r5, r4]
 8005802:	2b20      	cmp	r3, #32
 8005804:	d1f9      	bne.n	80057fa <gen_numname+0x76>
 8005806:	e004      	b.n	8005812 <gen_numname+0x8e>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8005808:	2020      	movs	r0, #32
 800580a:	7018      	strb	r0, [r3, #0]
 800580c:	460c      	mov	r4, r1
	} while (j < 8);
 800580e:	2907      	cmp	r1, #7
 8005810:	d809      	bhi.n	8005826 <gen_numname+0xa2>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8005812:	1c61      	adds	r1, r4, #1
 8005814:	192b      	adds	r3, r5, r4
 8005816:	2a07      	cmp	r2, #7
 8005818:	d8f6      	bhi.n	8005808 <gen_numname+0x84>
 800581a:	a802      	add	r0, sp, #8
 800581c:	4410      	add	r0, r2
 800581e:	f810 0c08 	ldrb.w	r0, [r0, #-8]
 8005822:	3201      	adds	r2, #1
 8005824:	e7f1      	b.n	800580a <gen_numname+0x86>
}
 8005826:	b002      	add	sp, #8
 8005828:	bd70      	pop	{r4, r5, r6, pc}

0800582a <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 800582a:	4601      	mov	r1, r0
	BYTE sum = 0;
	UINT n = 11;
 800582c:	220b      	movs	r2, #11
	BYTE sum = 0;
 800582e:	2000      	movs	r0, #0

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8005830:	01c3      	lsls	r3, r0, #7
 8005832:	ea43 0350 	orr.w	r3, r3, r0, lsr #1
 8005836:	b2db      	uxtb	r3, r3
 8005838:	7808      	ldrb	r0, [r1, #0]
 800583a:	4403      	add	r3, r0
 800583c:	b2d8      	uxtb	r0, r3
 800583e:	3101      	adds	r1, #1
 8005840:	3a01      	subs	r2, #1
 8005842:	d1f5      	bne.n	8005830 <sum_sfn+0x6>
	return sum;
}
 8005844:	4770      	bx	lr

08005846 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8005846:	6801      	ldr	r1, [r0, #0]
 8005848:	b109      	cbz	r1, 800584e <get_ldnumber+0x8>
 800584a:	460a      	mov	r2, r1
 800584c:	e003      	b.n	8005856 <get_ldnumber+0x10>
	int vol = -1;
 800584e:	f04f 33ff 	mov.w	r3, #4294967295
 8005852:	e008      	b.n	8005866 <get_ldnumber+0x20>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8005854:	3201      	adds	r2, #1
 8005856:	7813      	ldrb	r3, [r2, #0]
 8005858:	2b1f      	cmp	r3, #31
 800585a:	d901      	bls.n	8005860 <get_ldnumber+0x1a>
 800585c:	2b3a      	cmp	r3, #58	; 0x3a
 800585e:	d1f9      	bne.n	8005854 <get_ldnumber+0xe>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 8005860:	2b3a      	cmp	r3, #58	; 0x3a
 8005862:	d002      	beq.n	800586a <get_ldnumber+0x24>
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8005864:	2300      	movs	r3, #0
#endif
	}
	return vol;
}
 8005866:	4618      	mov	r0, r3
 8005868:	4770      	bx	lr
{
 800586a:	b410      	push	{r4}
			i = *tp++ - '0'; 
 800586c:	1c4c      	adds	r4, r1, #1
 800586e:	780b      	ldrb	r3, [r1, #0]
 8005870:	3b30      	subs	r3, #48	; 0x30
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8005872:	2b09      	cmp	r3, #9
 8005874:	d807      	bhi.n	8005886 <get_ldnumber+0x40>
 8005876:	42a2      	cmp	r2, r4
 8005878:	d108      	bne.n	800588c <get_ldnumber+0x46>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800587a:	b953      	cbnz	r3, 8005892 <get_ldnumber+0x4c>
					*path = ++tt;
 800587c:	3201      	adds	r2, #1
 800587e:	6002      	str	r2, [r0, #0]
}
 8005880:	4618      	mov	r0, r3
 8005882:	bc10      	pop	{r4}
 8005884:	4770      	bx	lr
	int vol = -1;
 8005886:	f04f 33ff 	mov.w	r3, #4294967295
 800588a:	e7f9      	b.n	8005880 <get_ldnumber+0x3a>
 800588c:	f04f 33ff 	mov.w	r3, #4294967295
 8005890:	e7f6      	b.n	8005880 <get_ldnumber+0x3a>
 8005892:	f04f 33ff 	mov.w	r3, #4294967295
 8005896:	e7f3      	b.n	8005880 <get_ldnumber+0x3a>

08005898 <sync_window>:
{
 8005898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800589a:	f241 0304 	movw	r3, #4100	; 0x1004
 800589e:	5cc3      	ldrb	r3, [r0, r3]
 80058a0:	b90b      	cbnz	r3, 80058a6 <sync_window+0xe>
	FRESULT res = FR_OK;
 80058a2:	2000      	movs	r0, #0
 80058a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80058a6:	4604      	mov	r4, r0
		wsect = fs->winsect;	/* Current sector number */
 80058a8:	f241 032c 	movw	r3, #4140	; 0x102c
 80058ac:	58c6      	ldr	r6, [r0, r3]
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
 80058ae:	4607      	mov	r7, r0
 80058b0:	2301      	movs	r3, #1
 80058b2:	4632      	mov	r2, r6
 80058b4:	4601      	mov	r1, r0
 80058b6:	f241 0001 	movw	r0, #4097	; 0x1001
 80058ba:	5c20      	ldrb	r0, [r4, r0]
 80058bc:	f7ff fcf2 	bl	80052a4 <disk_write>
 80058c0:	bb08      	cbnz	r0, 8005906 <sync_window+0x6e>
			fs->wflag = 0;
 80058c2:	2200      	movs	r2, #0
 80058c4:	f241 0304 	movw	r3, #4100	; 0x1004
 80058c8:	54e2      	strb	r2, [r4, r3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80058ca:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 80058ce:	681b      	ldr	r3, [r3, #0]
 80058d0:	1af3      	subs	r3, r6, r3
 80058d2:	f241 0218 	movw	r2, #4120	; 0x1018
 80058d6:	58a2      	ldr	r2, [r4, r2]
 80058d8:	4293      	cmp	r3, r2
 80058da:	d216      	bcs.n	800590a <sync_window+0x72>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80058dc:	f241 0303 	movw	r3, #4099	; 0x1003
 80058e0:	5ce5      	ldrb	r5, [r4, r3]
 80058e2:	e00c      	b.n	80058fe <sync_window+0x66>
					wsect += fs->fsize;
 80058e4:	f241 0318 	movw	r3, #4120	; 0x1018
 80058e8:	58e3      	ldr	r3, [r4, r3]
 80058ea:	441e      	add	r6, r3
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 80058ec:	2301      	movs	r3, #1
 80058ee:	4632      	mov	r2, r6
 80058f0:	4639      	mov	r1, r7
 80058f2:	f241 0001 	movw	r0, #4097	; 0x1001
 80058f6:	5c20      	ldrb	r0, [r4, r0]
 80058f8:	f7ff fcd4 	bl	80052a4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80058fc:	3d01      	subs	r5, #1
 80058fe:	2d01      	cmp	r5, #1
 8005900:	d8f0      	bhi.n	80058e4 <sync_window+0x4c>
	FRESULT res = FR_OK;
 8005902:	2000      	movs	r0, #0
 8005904:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			res = FR_DISK_ERR;
 8005906:	2001      	movs	r0, #1
 8005908:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	FRESULT res = FR_OK;
 800590a:	2000      	movs	r0, #0
}
 800590c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800590e <move_window>:
{
 800590e:	b570      	push	{r4, r5, r6, lr}
	if (sector != fs->winsect) {	/* Window offset changed? */
 8005910:	f241 032c 	movw	r3, #4140	; 0x102c
 8005914:	58c3      	ldr	r3, [r0, r3]
 8005916:	428b      	cmp	r3, r1
 8005918:	d017      	beq.n	800594a <move_window+0x3c>
 800591a:	4604      	mov	r4, r0
 800591c:	460d      	mov	r5, r1
		res = sync_window(fs);		/* Write-back changes */
 800591e:	f7ff ffbb 	bl	8005898 <sync_window>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8005922:	4606      	mov	r6, r0
 8005924:	b108      	cbz	r0, 800592a <move_window+0x1c>
}
 8005926:	4630      	mov	r0, r6
 8005928:	bd70      	pop	{r4, r5, r6, pc}
			if (disk_read(fs->drv, fs->win.d8, sector, 1) != RES_OK) {
 800592a:	2301      	movs	r3, #1
 800592c:	462a      	mov	r2, r5
 800592e:	4621      	mov	r1, r4
 8005930:	f241 0001 	movw	r0, #4097	; 0x1001
 8005934:	5c20      	ldrb	r0, [r4, r0]
 8005936:	f7ff fca9 	bl	800528c <disk_read>
 800593a:	b110      	cbz	r0, 8005942 <move_window+0x34>
				res = FR_DISK_ERR;
 800593c:	2601      	movs	r6, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 800593e:	f04f 35ff 	mov.w	r5, #4294967295
			fs->winsect = sector;
 8005942:	f241 032c 	movw	r3, #4140	; 0x102c
 8005946:	50e5      	str	r5, [r4, r3]
 8005948:	e7ed      	b.n	8005926 <move_window+0x18>
	FRESULT res = FR_OK;
 800594a:	2600      	movs	r6, #0
 800594c:	e7eb      	b.n	8005926 <move_window+0x18>
	...

08005950 <check_fs>:
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8005950:	b510      	push	{r4, lr}
 8005952:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8005954:	2200      	movs	r2, #0
 8005956:	f241 0304 	movw	r3, #4100	; 0x1004
 800595a:	54c2      	strb	r2, [r0, r3]
 800595c:	f04f 32ff 	mov.w	r2, #4294967295
 8005960:	f241 032c 	movw	r3, #4140	; 0x102c
 8005964:	50c2      	str	r2, [r0, r3]
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 8005966:	f7ff ffd2 	bl	800590e <move_window>
 800596a:	b108      	cbz	r0, 8005970 <check_fs+0x20>
		return 3;
 800596c:	2003      	movs	r0, #3
 800596e:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 8005970:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8005974:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 8005978:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800597c:	b21b      	sxth	r3, r3
 800597e:	4a18      	ldr	r2, [pc, #96]	; (80059e0 <check_fs+0x90>)
 8005980:	4293      	cmp	r3, r2
 8005982:	d001      	beq.n	8005988 <check_fs+0x38>
		return 2;
 8005984:	2002      	movs	r0, #2
 8005986:	bd10      	pop	{r4, pc}

	if ((LD_DWORD(&fs->win.d8[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 8005988:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 800598c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8005990:	041b      	lsls	r3, r3, #16
 8005992:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005996:	f894 2037 	ldrb.w	r2, [r4, #55]	; 0x37
 800599a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800599e:	f894 2036 	ldrb.w	r2, [r4, #54]	; 0x36
 80059a2:	4313      	orrs	r3, r2
 80059a4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80059a8:	4a0e      	ldr	r2, [pc, #56]	; (80059e4 <check_fs+0x94>)
 80059aa:	4293      	cmp	r3, r2
 80059ac:	d015      	beq.n	80059da <check_fs+0x8a>
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80059ae:	f894 2055 	ldrb.w	r2, [r4, #85]	; 0x55
 80059b2:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 80059b6:	041b      	lsls	r3, r3, #16
 80059b8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80059bc:	f894 2053 	ldrb.w	r2, [r4, #83]	; 0x53
 80059c0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80059c4:	f894 2052 	ldrb.w	r2, [r4, #82]	; 0x52
 80059c8:	4313      	orrs	r3, r2
 80059ca:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80059ce:	4a05      	ldr	r2, [pc, #20]	; (80059e4 <check_fs+0x94>)
 80059d0:	4293      	cmp	r3, r2
 80059d2:	d001      	beq.n	80059d8 <check_fs+0x88>
		return 0;

	return 1;
 80059d4:	2001      	movs	r0, #1
}
 80059d6:	bd10      	pop	{r4, pc}
 80059d8:	bd10      	pop	{r4, pc}
		return 0;
 80059da:	2000      	movs	r0, #0
 80059dc:	bd10      	pop	{r4, pc}
 80059de:	bf00      	nop
 80059e0:	ffffaa55 	.word	0xffffaa55
 80059e4:	00544146 	.word	0x00544146

080059e8 <validate>:
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 80059e8:	b308      	cbz	r0, 8005a2e <validate+0x46>
{
 80059ea:	b508      	push	{r3, lr}
 80059ec:	4602      	mov	r2, r0
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 80059ee:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
 80059f2:	681b      	ldr	r3, [r3, #0]
 80059f4:	b1eb      	cbz	r3, 8005a32 <validate+0x4a>
 80059f6:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 80059fa:	7809      	ldrb	r1, [r1, #0]
 80059fc:	b909      	cbnz	r1, 8005a02 <validate+0x1a>
		return FR_INVALID_OBJECT;
 80059fe:	2009      	movs	r0, #9
 8005a00:	bd08      	pop	{r3, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 8005a02:	f241 0106 	movw	r1, #4102	; 0x1006
 8005a06:	5a59      	ldrh	r1, [r3, r1]
 8005a08:	f241 0004 	movw	r0, #4100	; 0x1004
 8005a0c:	5a12      	ldrh	r2, [r2, r0]
 8005a0e:	4291      	cmp	r1, r2
 8005a10:	d001      	beq.n	8005a16 <validate+0x2e>
		return FR_INVALID_OBJECT;
 8005a12:	2009      	movs	r0, #9
 8005a14:	bd08      	pop	{r3, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 8005a16:	f241 0201 	movw	r2, #4097	; 0x1001
 8005a1a:	5c98      	ldrb	r0, [r3, r2]
 8005a1c:	f7ff fc16 	bl	800524c <disk_status>
 8005a20:	f010 0f01 	tst.w	r0, #1
 8005a24:	d001      	beq.n	8005a2a <validate+0x42>
		return FR_INVALID_OBJECT;
 8005a26:	2009      	movs	r0, #9

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
 8005a28:	bd08      	pop	{r3, pc}
	return FR_OK;
 8005a2a:	2000      	movs	r0, #0
 8005a2c:	bd08      	pop	{r3, pc}
		return FR_INVALID_OBJECT;
 8005a2e:	2009      	movs	r0, #9
 8005a30:	4770      	bx	lr
 8005a32:	2009      	movs	r0, #9
 8005a34:	bd08      	pop	{r3, pc}
	...

08005a38 <find_volume>:
{
 8005a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a3c:	b084      	sub	sp, #16
 8005a3e:	4606      	mov	r6, r0
 8005a40:	4617      	mov	r7, r2
	*rfs = 0;
 8005a42:	2300      	movs	r3, #0
 8005a44:	6003      	str	r3, [r0, #0]
	vol = get_ldnumber(path);
 8005a46:	4608      	mov	r0, r1
 8005a48:	f7ff fefd 	bl	8005846 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8005a4c:	1e05      	subs	r5, r0, #0
 8005a4e:	f2c0 81ca 	blt.w	8005de6 <find_volume+0x3ae>
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8005a52:	4b5e      	ldr	r3, [pc, #376]	; (8005bcc <find_volume+0x194>)
 8005a54:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005a58:	2c00      	cmp	r4, #0
 8005a5a:	f000 81c8 	beq.w	8005dee <find_volume+0x3b6>
	*rfs = fs;							/* Return pointer to the file system object */
 8005a5e:	6034      	str	r4, [r6, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8005a60:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8005a64:	781b      	ldrb	r3, [r3, #0]
 8005a66:	b18b      	cbz	r3, 8005a8c <find_volume+0x54>
		stat = disk_status(fs->drv);
 8005a68:	f241 0301 	movw	r3, #4097	; 0x1001
 8005a6c:	5ce0      	ldrb	r0, [r4, r3]
 8005a6e:	f7ff fbed 	bl	800524c <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8005a72:	f010 0f01 	tst.w	r0, #1
 8005a76:	d109      	bne.n	8005a8c <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8005a78:	2f00      	cmp	r7, #0
 8005a7a:	f000 81ba 	beq.w	8005df2 <find_volume+0x3ba>
 8005a7e:	f010 0f04 	tst.w	r0, #4
 8005a82:	d001      	beq.n	8005a88 <find_volume+0x50>
				return FR_WRITE_PROTECTED;
 8005a84:	200a      	movs	r0, #10
 8005a86:	e1af      	b.n	8005de8 <find_volume+0x3b0>
			return FR_OK;				/* The file system object is valid */
 8005a88:	2000      	movs	r0, #0
 8005a8a:	e1ad      	b.n	8005de8 <find_volume+0x3b0>
	fs->fs_type = 0;					/* Clear the file system object */
 8005a8c:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8005a90:	2200      	movs	r2, #0
 8005a92:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8005a94:	b2e8      	uxtb	r0, r5
 8005a96:	f241 0301 	movw	r3, #4097	; 0x1001
 8005a9a:	54e0      	strb	r0, [r4, r3]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8005a9c:	f7ff fbe2 	bl	8005264 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8005aa0:	f010 0f01 	tst.w	r0, #1
 8005aa4:	d001      	beq.n	8005aaa <find_volume+0x72>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8005aa6:	2003      	movs	r0, #3
 8005aa8:	e19e      	b.n	8005de8 <find_volume+0x3b0>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8005aaa:	b127      	cbz	r7, 8005ab6 <find_volume+0x7e>
 8005aac:	f010 0f04 	tst.w	r0, #4
 8005ab0:	d001      	beq.n	8005ab6 <find_volume+0x7e>
		return FR_WRITE_PROTECTED;
 8005ab2:	200a      	movs	r0, #10
 8005ab4:	e198      	b.n	8005de8 <find_volume+0x3b0>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
 8005ab6:	f504 5280 	add.w	r2, r4, #4096	; 0x1000
 8005aba:	320a      	adds	r2, #10
 8005abc:	2102      	movs	r1, #2
 8005abe:	f241 0301 	movw	r3, #4097	; 0x1001
 8005ac2:	5ce0      	ldrb	r0, [r4, r3]
 8005ac4:	f7ff fbfa 	bl	80052bc <disk_ioctl>
 8005ac8:	2800      	cmp	r0, #0
 8005aca:	f040 8194 	bne.w	8005df6 <find_volume+0x3be>
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
 8005ace:	f241 030a 	movw	r3, #4106	; 0x100a
 8005ad2:	5ae3      	ldrh	r3, [r4, r3]
 8005ad4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005ad8:	f0c0 818f 	bcc.w	8005dfa <find_volume+0x3c2>
 8005adc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005ae0:	d901      	bls.n	8005ae6 <find_volume+0xae>
 8005ae2:	2001      	movs	r0, #1
 8005ae4:	e180      	b.n	8005de8 <find_volume+0x3b0>
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 8005ae6:	2100      	movs	r1, #0
 8005ae8:	4620      	mov	r0, r4
 8005aea:	f7ff ff31 	bl	8005950 <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8005aee:	2801      	cmp	r0, #1
 8005af0:	d021      	beq.n	8005b36 <find_volume+0xfe>
	bsect = 0;
 8005af2:	2600      	movs	r6, #0
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8005af4:	2803      	cmp	r0, #3
 8005af6:	f000 8182 	beq.w	8005dfe <find_volume+0x3c6>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8005afa:	b390      	cbz	r0, 8005b62 <find_volume+0x12a>
 8005afc:	200d      	movs	r0, #13
 8005afe:	e173      	b.n	8005de8 <find_volume+0x3b0>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8005b00:	2300      	movs	r3, #0
 8005b02:	aa04      	add	r2, sp, #16
 8005b04:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8005b08:	f842 3c10 	str.w	r3, [r2, #-16]
		for (i = 0; i < 4; i++) {			/* Get partition offset */
 8005b0c:	3101      	adds	r1, #1
 8005b0e:	2903      	cmp	r1, #3
 8005b10:	d813      	bhi.n	8005b3a <find_volume+0x102>
			pt = fs->win.d8 + MBR_Table + i * SZ_PTE;
 8005b12:	010b      	lsls	r3, r1, #4
 8005b14:	f503 73df 	add.w	r3, r3, #446	; 0x1be
 8005b18:	4423      	add	r3, r4
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8005b1a:	791a      	ldrb	r2, [r3, #4]
 8005b1c:	2a00      	cmp	r2, #0
 8005b1e:	d0ef      	beq.n	8005b00 <find_volume+0xc8>
 8005b20:	7ad8      	ldrb	r0, [r3, #11]
 8005b22:	7a9a      	ldrb	r2, [r3, #10]
 8005b24:	0412      	lsls	r2, r2, #16
 8005b26:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8005b2a:	7a58      	ldrb	r0, [r3, #9]
 8005b2c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8005b30:	7a1b      	ldrb	r3, [r3, #8]
 8005b32:	4313      	orrs	r3, r2
 8005b34:	e7e5      	b.n	8005b02 <find_volume+0xca>
 8005b36:	2100      	movs	r1, #0
 8005b38:	e7e9      	b.n	8005b0e <find_volume+0xd6>
 8005b3a:	2500      	movs	r5, #0
 8005b3c:	e008      	b.n	8005b50 <find_volume+0x118>
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8005b3e:	4631      	mov	r1, r6
 8005b40:	4620      	mov	r0, r4
 8005b42:	f7ff ff05 	bl	8005950 <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8005b46:	2800      	cmp	r0, #0
 8005b48:	d0d4      	beq.n	8005af4 <find_volume+0xbc>
 8005b4a:	3501      	adds	r5, #1
 8005b4c:	2d03      	cmp	r5, #3
 8005b4e:	d8d1      	bhi.n	8005af4 <find_volume+0xbc>
			bsect = br[i];
 8005b50:	ab04      	add	r3, sp, #16
 8005b52:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8005b56:	f853 6c10 	ldr.w	r6, [r3, #-16]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8005b5a:	2e00      	cmp	r6, #0
 8005b5c:	d1ef      	bne.n	8005b3e <find_volume+0x106>
 8005b5e:	2002      	movs	r0, #2
 8005b60:	e7f1      	b.n	8005b46 <find_volume+0x10e>
	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8005b62:	7b22      	ldrb	r2, [r4, #12]
 8005b64:	7ae3      	ldrb	r3, [r4, #11]
 8005b66:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005b6a:	f241 020a 	movw	r2, #4106	; 0x100a
 8005b6e:	5aa0      	ldrh	r0, [r4, r2]
 8005b70:	4283      	cmp	r3, r0
 8005b72:	d001      	beq.n	8005b78 <find_volume+0x140>
		return FR_NO_FILESYSTEM;
 8005b74:	200d      	movs	r0, #13
 8005b76:	e137      	b.n	8005de8 <find_volume+0x3b0>
	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8005b78:	7de3      	ldrb	r3, [r4, #23]
 8005b7a:	7da2      	ldrb	r2, [r4, #22]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 8005b7c:	ea52 2203 	orrs.w	r2, r2, r3, lsl #8
 8005b80:	d10d      	bne.n	8005b9e <find_volume+0x166>
 8005b82:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005b86:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 8005b8a:	0412      	lsls	r2, r2, #16
 8005b8c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8005b90:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8005b94:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8005b98:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8005b9c:	431a      	orrs	r2, r3
	fs->fsize = fasize;
 8005b9e:	f241 0318 	movw	r3, #4120	; 0x1018
 8005ba2:	50e2      	str	r2, [r4, r3]
	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8005ba4:	7c21      	ldrb	r1, [r4, #16]
 8005ba6:	f241 0303 	movw	r3, #4099	; 0x1003
 8005baa:	54e1      	strb	r1, [r4, r3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8005bac:	1e4b      	subs	r3, r1, #1
 8005bae:	b2db      	uxtb	r3, r3
 8005bb0:	2b01      	cmp	r3, #1
 8005bb2:	d901      	bls.n	8005bb8 <find_volume+0x180>
		return FR_NO_FILESYSTEM;
 8005bb4:	200d      	movs	r0, #13
 8005bb6:	e117      	b.n	8005de8 <find_volume+0x3b0>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 8005bb8:	fb01 f102 	mul.w	r1, r1, r2
	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
 8005bbc:	7b65      	ldrb	r5, [r4, #13]
 8005bbe:	f241 0302 	movw	r3, #4098	; 0x1002
 8005bc2:	54e5      	strb	r5, [r4, r3]
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8005bc4:	b925      	cbnz	r5, 8005bd0 <find_volume+0x198>
		return FR_NO_FILESYSTEM;
 8005bc6:	200d      	movs	r0, #13
 8005bc8:	e10e      	b.n	8005de8 <find_volume+0x3b0>
 8005bca:	bf00      	nop
 8005bcc:	2000020c 	.word	0x2000020c
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8005bd0:	1e6b      	subs	r3, r5, #1
 8005bd2:	421d      	tst	r5, r3
 8005bd4:	f040 8115 	bne.w	8005e02 <find_volume+0x3ca>
	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8005bd8:	7ca3      	ldrb	r3, [r4, #18]
 8005bda:	7c67      	ldrb	r7, [r4, #17]
 8005bdc:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
 8005be0:	f241 0308 	movw	r3, #4104	; 0x1008
 8005be4:	52e7      	strh	r7, [r4, r3]
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8005be6:	ea4f 1e50 	mov.w	lr, r0, lsr #5
 8005bea:	fbb7 f3fe 	udiv	r3, r7, lr
 8005bee:	fb0e 7313 	mls	r3, lr, r3, r7
 8005bf2:	b29b      	uxth	r3, r3
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	f040 8106 	bne.w	8005e06 <find_volume+0x3ce>
	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
 8005bfa:	f894 c014 	ldrb.w	ip, [r4, #20]
 8005bfe:	7ce3      	ldrb	r3, [r4, #19]
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8005c00:	ea53 230c 	orrs.w	r3, r3, ip, lsl #8
 8005c04:	d10e      	bne.n	8005c24 <find_volume+0x1ec>
 8005c06:	f894 c023 	ldrb.w	ip, [r4, #35]	; 0x23
 8005c0a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8005c0e:	041b      	lsls	r3, r3, #16
 8005c10:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 8005c14:	f894 c021 	ldrb.w	ip, [r4, #33]	; 0x21
 8005c18:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
 8005c1c:	f894 c020 	ldrb.w	ip, [r4, #32]
 8005c20:	ea43 030c 	orr.w	r3, r3, ip
	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8005c24:	f894 800f 	ldrb.w	r8, [r4, #15]
 8005c28:	f894 c00e 	ldrb.w	ip, [r4, #14]
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8005c2c:	ea5c 2c08 	orrs.w	ip, ip, r8, lsl #8
 8005c30:	f000 80eb 	beq.w	8005e0a <find_volume+0x3d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
 8005c34:	eb01 080c 	add.w	r8, r1, ip
 8005c38:	fbb7 fefe 	udiv	lr, r7, lr
 8005c3c:	44c6      	add	lr, r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8005c3e:	4573      	cmp	r3, lr
 8005c40:	f0c0 80e5 	bcc.w	8005e0e <find_volume+0x3d6>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8005c44:	eba3 030e 	sub.w	r3, r3, lr
 8005c48:	fbb3 f3f5 	udiv	r3, r3, r5
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8005c4c:	2b00      	cmp	r3, #0
 8005c4e:	f000 80e0 	beq.w	8005e12 <find_volume+0x3da>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8005c52:	f640 75f5 	movw	r5, #4085	; 0xff5
 8005c56:	42ab      	cmp	r3, r5
 8005c58:	f200 80b3 	bhi.w	8005dc2 <find_volume+0x38a>
	fmt = FS_FAT12;
 8005c5c:	2501      	movs	r5, #1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8005c5e:	f64f 78f5 	movw	r8, #65525	; 0xfff5
 8005c62:	4543      	cmp	r3, r8
 8005c64:	d900      	bls.n	8005c68 <find_volume+0x230>
 8005c66:	2503      	movs	r5, #3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005c68:	3302      	adds	r3, #2
 8005c6a:	f241 0814 	movw	r8, #4116	; 0x1014
 8005c6e:	f844 3008 	str.w	r3, [r4, r8]
	fs->volbase = bsect;								/* Volume start sector */
 8005c72:	f241 081c 	movw	r8, #4124	; 0x101c
 8005c76:	f844 6008 	str.w	r6, [r4, r8]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005c7a:	44b4      	add	ip, r6
 8005c7c:	f504 5881 	add.w	r8, r4, #4128	; 0x1020
 8005c80:	f8c8 c000 	str.w	ip, [r8]
	fs->database = bsect + sysect;						/* Data start sector */
 8005c84:	44b6      	add	lr, r6
 8005c86:	f241 0828 	movw	r8, #4136	; 0x1028
 8005c8a:	f844 e008 	str.w	lr, [r4, r8]
	if (fmt == FS_FAT32) {
 8005c8e:	2d03      	cmp	r5, #3
 8005c90:	f040 8099 	bne.w	8005dc6 <find_volume+0x38e>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8005c94:	2f00      	cmp	r7, #0
 8005c96:	f040 80be 	bne.w	8005e16 <find_volume+0x3de>
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
 8005c9a:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
 8005c9e:	f894 102e 	ldrb.w	r1, [r4, #46]	; 0x2e
 8005ca2:	0409      	lsls	r1, r1, #16
 8005ca4:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
 8005ca8:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
 8005cac:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8005cb0:	f894 702c 	ldrb.w	r7, [r4, #44]	; 0x2c
 8005cb4:	4339      	orrs	r1, r7
 8005cb6:	f241 0724 	movw	r7, #4132	; 0x1024
 8005cba:	51e1      	str	r1, [r4, r7]
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 8005cbc:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
 8005cbe:	4403      	add	r3, r0
 8005cc0:	3b01      	subs	r3, #1
 8005cc2:	fbb3 f3f0 	udiv	r3, r3, r0
 8005cc6:	429a      	cmp	r2, r3
 8005cc8:	f0c0 80a9 	bcc.w	8005e1e <find_volume+0x3e6>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8005ccc:	f04f 33ff 	mov.w	r3, #4294967295
 8005cd0:	f241 0210 	movw	r2, #4112	; 0x1010
 8005cd4:	50a3      	str	r3, [r4, r2]
 8005cd6:	f241 020c 	movw	r2, #4108	; 0x100c
 8005cda:	50a3      	str	r3, [r4, r2]
	fs->fsi_flag = 0x80;
 8005cdc:	2280      	movs	r2, #128	; 0x80
 8005cde:	f241 0305 	movw	r3, #4101	; 0x1005
 8005ce2:	54e2      	strb	r2, [r4, r3]
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8005ce4:	2d03      	cmp	r5, #3
 8005ce6:	d15c      	bne.n	8005da2 <find_volume+0x36a>
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
 8005ce8:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
 8005cec:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8005cf0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005cf4:	b21b      	sxth	r3, r3
 8005cf6:	2b01      	cmp	r3, #1
 8005cf8:	d153      	bne.n	8005da2 <find_volume+0x36a>
		&& move_window(fs, bsect + 1) == FR_OK)
 8005cfa:	1c71      	adds	r1, r6, #1
 8005cfc:	4620      	mov	r0, r4
 8005cfe:	f7ff fe06 	bl	800590e <move_window>
 8005d02:	2800      	cmp	r0, #0
 8005d04:	d14d      	bne.n	8005da2 <find_volume+0x36a>
		fs->fsi_flag = 0;
 8005d06:	2200      	movs	r2, #0
 8005d08:	f241 0305 	movw	r3, #4101	; 0x1005
 8005d0c:	54e2      	strb	r2, [r4, r3]
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8005d0e:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8005d12:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 8005d16:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005d1a:	b21b      	sxth	r3, r3
 8005d1c:	4a41      	ldr	r2, [pc, #260]	; (8005e24 <find_volume+0x3ec>)
 8005d1e:	4293      	cmp	r3, r2
 8005d20:	d13f      	bne.n	8005da2 <find_volume+0x36a>
			&& LD_DWORD(fs->win.d8 + FSI_LeadSig) == 0x41615252
 8005d22:	78e2      	ldrb	r2, [r4, #3]
 8005d24:	78a3      	ldrb	r3, [r4, #2]
 8005d26:	041b      	lsls	r3, r3, #16
 8005d28:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005d2c:	7862      	ldrb	r2, [r4, #1]
 8005d2e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005d32:	7822      	ldrb	r2, [r4, #0]
 8005d34:	4313      	orrs	r3, r2
 8005d36:	4a3c      	ldr	r2, [pc, #240]	; (8005e28 <find_volume+0x3f0>)
 8005d38:	4293      	cmp	r3, r2
 8005d3a:	d132      	bne.n	8005da2 <find_volume+0x36a>
			&& LD_DWORD(fs->win.d8 + FSI_StrucSig) == 0x61417272)
 8005d3c:	f894 21e7 	ldrb.w	r2, [r4, #487]	; 0x1e7
 8005d40:	f894 31e6 	ldrb.w	r3, [r4, #486]	; 0x1e6
 8005d44:	041b      	lsls	r3, r3, #16
 8005d46:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005d4a:	f894 21e5 	ldrb.w	r2, [r4, #485]	; 0x1e5
 8005d4e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005d52:	f894 21e4 	ldrb.w	r2, [r4, #484]	; 0x1e4
 8005d56:	4313      	orrs	r3, r2
 8005d58:	4a34      	ldr	r2, [pc, #208]	; (8005e2c <find_volume+0x3f4>)
 8005d5a:	4293      	cmp	r3, r2
 8005d5c:	d121      	bne.n	8005da2 <find_volume+0x36a>
			fs->free_clust = LD_DWORD(fs->win.d8 + FSI_Free_Count);
 8005d5e:	f894 21eb 	ldrb.w	r2, [r4, #491]	; 0x1eb
 8005d62:	f894 31ea 	ldrb.w	r3, [r4, #490]	; 0x1ea
 8005d66:	041b      	lsls	r3, r3, #16
 8005d68:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005d6c:	f894 21e9 	ldrb.w	r2, [r4, #489]	; 0x1e9
 8005d70:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005d74:	f894 21e8 	ldrb.w	r2, [r4, #488]	; 0x1e8
 8005d78:	4313      	orrs	r3, r2
 8005d7a:	f241 0210 	movw	r2, #4112	; 0x1010
 8005d7e:	50a3      	str	r3, [r4, r2]
			fs->last_clust = LD_DWORD(fs->win.d8 + FSI_Nxt_Free);
 8005d80:	f894 21ef 	ldrb.w	r2, [r4, #495]	; 0x1ef
 8005d84:	f894 31ee 	ldrb.w	r3, [r4, #494]	; 0x1ee
 8005d88:	041b      	lsls	r3, r3, #16
 8005d8a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005d8e:	f894 21ed 	ldrb.w	r2, [r4, #493]	; 0x1ed
 8005d92:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005d96:	f894 21ec 	ldrb.w	r2, [r4, #492]	; 0x1ec
 8005d9a:	4313      	orrs	r3, r2
 8005d9c:	f241 020c 	movw	r2, #4108	; 0x100c
 8005da0:	50a3      	str	r3, [r4, r2]
	fs->fs_type = fmt;	/* FAT sub-type */
 8005da2:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8005da6:	701d      	strb	r5, [r3, #0]
	fs->id = ++Fsid;	/* File system mount ID */
 8005da8:	4a21      	ldr	r2, [pc, #132]	; (8005e30 <find_volume+0x3f8>)
 8005daa:	8813      	ldrh	r3, [r2, #0]
 8005dac:	3301      	adds	r3, #1
 8005dae:	b29b      	uxth	r3, r3
 8005db0:	8013      	strh	r3, [r2, #0]
 8005db2:	f241 0206 	movw	r2, #4102	; 0x1006
 8005db6:	52a3      	strh	r3, [r4, r2]
	clear_lock(fs);
 8005db8:	4620      	mov	r0, r4
 8005dba:	f7ff fc27 	bl	800560c <clear_lock>
	return FR_OK;
 8005dbe:	2000      	movs	r0, #0
 8005dc0:	e012      	b.n	8005de8 <find_volume+0x3b0>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8005dc2:	2502      	movs	r5, #2
 8005dc4:	e74b      	b.n	8005c5e <find_volume+0x226>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005dc6:	b347      	cbz	r7, 8005e1a <find_volume+0x3e2>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005dc8:	4461      	add	r1, ip
 8005dca:	f241 0724 	movw	r7, #4132	; 0x1024
 8005dce:	51e1      	str	r1, [r4, r7]
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005dd0:	2d02      	cmp	r5, #2
 8005dd2:	d101      	bne.n	8005dd8 <find_volume+0x3a0>
 8005dd4:	005b      	lsls	r3, r3, #1
 8005dd6:	e772      	b.n	8005cbe <find_volume+0x286>
 8005dd8:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8005ddc:	f003 0301 	and.w	r3, r3, #1
 8005de0:	eb03 0351 	add.w	r3, r3, r1, lsr #1
 8005de4:	e76b      	b.n	8005cbe <find_volume+0x286>
	if (vol < 0) return FR_INVALID_DRIVE;
 8005de6:	200b      	movs	r0, #11
}
 8005de8:	b004      	add	sp, #16
 8005dea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005dee:	200c      	movs	r0, #12
 8005df0:	e7fa      	b.n	8005de8 <find_volume+0x3b0>
			return FR_OK;				/* The file system object is valid */
 8005df2:	2000      	movs	r0, #0
 8005df4:	e7f8      	b.n	8005de8 <find_volume+0x3b0>
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
 8005df6:	2001      	movs	r0, #1
 8005df8:	e7f6      	b.n	8005de8 <find_volume+0x3b0>
 8005dfa:	2001      	movs	r0, #1
 8005dfc:	e7f4      	b.n	8005de8 <find_volume+0x3b0>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8005dfe:	2001      	movs	r0, #1
 8005e00:	e7f2      	b.n	8005de8 <find_volume+0x3b0>
		return FR_NO_FILESYSTEM;
 8005e02:	200d      	movs	r0, #13
 8005e04:	e7f0      	b.n	8005de8 <find_volume+0x3b0>
		return FR_NO_FILESYSTEM;
 8005e06:	200d      	movs	r0, #13
 8005e08:	e7ee      	b.n	8005de8 <find_volume+0x3b0>
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8005e0a:	200d      	movs	r0, #13
 8005e0c:	e7ec      	b.n	8005de8 <find_volume+0x3b0>
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8005e0e:	200d      	movs	r0, #13
 8005e10:	e7ea      	b.n	8005de8 <find_volume+0x3b0>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8005e12:	200d      	movs	r0, #13
 8005e14:	e7e8      	b.n	8005de8 <find_volume+0x3b0>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8005e16:	200d      	movs	r0, #13
 8005e18:	e7e6      	b.n	8005de8 <find_volume+0x3b0>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005e1a:	200d      	movs	r0, #13
 8005e1c:	e7e4      	b.n	8005de8 <find_volume+0x3b0>
		return FR_NO_FILESYSTEM;
 8005e1e:	200d      	movs	r0, #13
 8005e20:	e7e2      	b.n	8005de8 <find_volume+0x3b0>
 8005e22:	bf00      	nop
 8005e24:	ffffaa55 	.word	0xffffaa55
 8005e28:	41615252 	.word	0x41615252
 8005e2c:	61417272 	.word	0x61417272
 8005e30:	20000228 	.word	0x20000228

08005e34 <sync_fs>:
{
 8005e34:	b538      	push	{r3, r4, r5, lr}
 8005e36:	4604      	mov	r4, r0
	res = sync_window(fs);
 8005e38:	f7ff fd2e 	bl	8005898 <sync_window>
	if (res == FR_OK) {
 8005e3c:	4605      	mov	r5, r0
 8005e3e:	b968      	cbnz	r0, 8005e5c <sync_fs+0x28>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8005e40:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8005e44:	781b      	ldrb	r3, [r3, #0]
 8005e46:	2b03      	cmp	r3, #3
 8005e48:	d00a      	beq.n	8005e60 <sync_fs+0x2c>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 8005e4a:	2200      	movs	r2, #0
 8005e4c:	4611      	mov	r1, r2
 8005e4e:	f241 0301 	movw	r3, #4097	; 0x1001
 8005e52:	5ce0      	ldrb	r0, [r4, r3]
 8005e54:	f7ff fa32 	bl	80052bc <disk_ioctl>
 8005e58:	b100      	cbz	r0, 8005e5c <sync_fs+0x28>
			res = FR_DISK_ERR;
 8005e5a:	2501      	movs	r5, #1
}
 8005e5c:	4628      	mov	r0, r5
 8005e5e:	bd38      	pop	{r3, r4, r5, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8005e60:	f241 0305 	movw	r3, #4101	; 0x1005
 8005e64:	5ce3      	ldrb	r3, [r4, r3]
 8005e66:	2b01      	cmp	r3, #1
 8005e68:	d1ef      	bne.n	8005e4a <sync_fs+0x16>
			mem_set(fs->win.d8, 0, SS(fs));
 8005e6a:	f241 030a 	movw	r3, #4106	; 0x100a
 8005e6e:	5ae2      	ldrh	r2, [r4, r3]
 8005e70:	2100      	movs	r1, #0
 8005e72:	4620      	mov	r0, r4
 8005e74:	f7ff fabc 	bl	80053f0 <mem_set>
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
 8005e78:	2355      	movs	r3, #85	; 0x55
 8005e7a:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
 8005e7e:	23aa      	movs	r3, #170	; 0xaa
 8005e80:	f884 31ff 	strb.w	r3, [r4, #511]	; 0x1ff
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
 8005e84:	2352      	movs	r3, #82	; 0x52
 8005e86:	7023      	strb	r3, [r4, #0]
 8005e88:	7063      	strb	r3, [r4, #1]
 8005e8a:	2361      	movs	r3, #97	; 0x61
 8005e8c:	70a3      	strb	r3, [r4, #2]
 8005e8e:	2241      	movs	r2, #65	; 0x41
 8005e90:	70e2      	strb	r2, [r4, #3]
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8005e92:	2172      	movs	r1, #114	; 0x72
 8005e94:	f884 11e4 	strb.w	r1, [r4, #484]	; 0x1e4
 8005e98:	f884 11e5 	strb.w	r1, [r4, #485]	; 0x1e5
 8005e9c:	f884 21e6 	strb.w	r2, [r4, #486]	; 0x1e6
 8005ea0:	f884 31e7 	strb.w	r3, [r4, #487]	; 0x1e7
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8005ea4:	f241 0310 	movw	r3, #4112	; 0x1010
 8005ea8:	58e3      	ldr	r3, [r4, r3]
 8005eaa:	f884 31e8 	strb.w	r3, [r4, #488]	; 0x1e8
 8005eae:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8005eb2:	f884 21e9 	strb.w	r2, [r4, #489]	; 0x1e9
 8005eb6:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8005eba:	f884 21ea 	strb.w	r2, [r4, #490]	; 0x1ea
 8005ebe:	0e1b      	lsrs	r3, r3, #24
 8005ec0:	f884 31eb 	strb.w	r3, [r4, #491]	; 0x1eb
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8005ec4:	f241 030c 	movw	r3, #4108	; 0x100c
 8005ec8:	58e3      	ldr	r3, [r4, r3]
 8005eca:	f884 31ec 	strb.w	r3, [r4, #492]	; 0x1ec
 8005ece:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8005ed2:	f884 21ed 	strb.w	r2, [r4, #493]	; 0x1ed
 8005ed6:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8005eda:	f884 21ee 	strb.w	r2, [r4, #494]	; 0x1ee
 8005ede:	0e1b      	lsrs	r3, r3, #24
 8005ee0:	f884 31ef 	strb.w	r3, [r4, #495]	; 0x1ef
			fs->winsect = fs->volbase + 1;
 8005ee4:	f241 031c 	movw	r3, #4124	; 0x101c
 8005ee8:	58e2      	ldr	r2, [r4, r3]
 8005eea:	3201      	adds	r2, #1
 8005eec:	f241 032c 	movw	r3, #4140	; 0x102c
 8005ef0:	50e2      	str	r2, [r4, r3]
			disk_write(fs->drv, fs->win.d8, fs->winsect, 1);
 8005ef2:	2301      	movs	r3, #1
 8005ef4:	4621      	mov	r1, r4
 8005ef6:	f241 0001 	movw	r0, #4097	; 0x1001
 8005efa:	5c20      	ldrb	r0, [r4, r0]
 8005efc:	f7ff f9d2 	bl	80052a4 <disk_write>
			fs->fsi_flag = 0;
 8005f00:	2200      	movs	r2, #0
 8005f02:	f241 0305 	movw	r3, #4101	; 0x1005
 8005f06:	54e2      	strb	r2, [r4, r3]
 8005f08:	e79f      	b.n	8005e4a <sync_fs+0x16>
	...

08005f0c <create_name>:
{
 8005f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f10:	b083      	sub	sp, #12
 8005f12:	4607      	mov	r7, r0
 8005f14:	4688      	mov	r8, r1
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8005f16:	680e      	ldr	r6, [r1, #0]
 8005f18:	e000      	b.n	8005f1c <create_name+0x10>
 8005f1a:	3601      	adds	r6, #1
 8005f1c:	7833      	ldrb	r3, [r6, #0]
 8005f1e:	2b2f      	cmp	r3, #47	; 0x2f
 8005f20:	d0fb      	beq.n	8005f1a <create_name+0xe>
 8005f22:	2b5c      	cmp	r3, #92	; 0x5c
 8005f24:	d0f9      	beq.n	8005f1a <create_name+0xe>
	lfn = dp->lfn;
 8005f26:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 8005f2a:	681d      	ldr	r5, [r3, #0]
	si = di = 0;
 8005f2c:	2400      	movs	r4, #0
 8005f2e:	e002      	b.n	8005f36 <create_name+0x2a>
		lfn[di++] = w;					/* Store the Unicode character */
 8005f30:	f825 9014 	strh.w	r9, [r5, r4, lsl #1]
		w = p[si++];					/* Get a character */
 8005f34:	4654      	mov	r4, sl
 8005f36:	f104 0a01 	add.w	sl, r4, #1
 8005f3a:	5d30      	ldrb	r0, [r6, r4]
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8005f3c:	281f      	cmp	r0, #31
 8005f3e:	d917      	bls.n	8005f70 <create_name+0x64>
 8005f40:	282f      	cmp	r0, #47	; 0x2f
 8005f42:	d015      	beq.n	8005f70 <create_name+0x64>
 8005f44:	285c      	cmp	r0, #92	; 0x5c
 8005f46:	d013      	beq.n	8005f70 <create_name+0x64>
		if (di >= _MAX_LFN)				/* Reject too long name */
 8005f48:	2cfe      	cmp	r4, #254	; 0xfe
 8005f4a:	f200 80ec 	bhi.w	8006126 <create_name+0x21a>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8005f4e:	2101      	movs	r1, #1
 8005f50:	f001 fb12 	bl	8007578 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8005f54:	4681      	mov	r9, r0
 8005f56:	2800      	cmp	r0, #0
 8005f58:	f000 80e7 	beq.w	800612a <create_name+0x21e>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
 8005f5c:	287f      	cmp	r0, #127	; 0x7f
 8005f5e:	d8e7      	bhi.n	8005f30 <create_name+0x24>
 8005f60:	4601      	mov	r1, r0
 8005f62:	4873      	ldr	r0, [pc, #460]	; (8006130 <create_name+0x224>)
 8005f64:	f7ff fa5d 	bl	8005422 <chk_chr>
 8005f68:	2800      	cmp	r0, #0
 8005f6a:	d0e1      	beq.n	8005f30 <create_name+0x24>
			return FR_INVALID_NAME;
 8005f6c:	2006      	movs	r0, #6
 8005f6e:	e017      	b.n	8005fa0 <create_name+0x94>
	*path = &p[si];						/* Return pointer to the next segment */
 8005f70:	4456      	add	r6, sl
 8005f72:	f8c8 6000 	str.w	r6, [r8]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8005f76:	281f      	cmp	r0, #31
 8005f78:	d802      	bhi.n	8005f80 <create_name+0x74>
 8005f7a:	f04f 0804 	mov.w	r8, #4
 8005f7e:	e003      	b.n	8005f88 <create_name+0x7c>
 8005f80:	f04f 0800 	mov.w	r8, #0
	while (di) {						/* Strip trailing spaces and dots */
 8005f84:	e000      	b.n	8005f88 <create_name+0x7c>
		di--;
 8005f86:	3c01      	subs	r4, #1
	while (di) {						/* Strip trailing spaces and dots */
 8005f88:	b144      	cbz	r4, 8005f9c <create_name+0x90>
		w = lfn[di - 1];
 8005f8a:	f104 4300 	add.w	r3, r4, #2147483648	; 0x80000000
 8005f8e:	3b01      	subs	r3, #1
 8005f90:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
		if (w != ' ' && w != '.') break;
 8005f94:	2b20      	cmp	r3, #32
 8005f96:	d0f6      	beq.n	8005f86 <create_name+0x7a>
 8005f98:	2b2e      	cmp	r3, #46	; 0x2e
 8005f9a:	d0f4      	beq.n	8005f86 <create_name+0x7a>
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
 8005f9c:	b91c      	cbnz	r4, 8005fa6 <create_name+0x9a>
 8005f9e:	2006      	movs	r0, #6
}
 8005fa0:	b003      	add	sp, #12
 8005fa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	lfn[di] = 0;						/* LFN is created */
 8005fa6:	2600      	movs	r6, #0
 8005fa8:	f825 6014 	strh.w	r6, [r5, r4, lsl #1]
	mem_set(dp->fn, ' ', 11);
 8005fac:	220b      	movs	r2, #11
 8005fae:	2120      	movs	r1, #32
 8005fb0:	f241 0318 	movw	r3, #4120	; 0x1018
 8005fb4:	58f8      	ldr	r0, [r7, r3]
 8005fb6:	f7ff fa1b 	bl	80053f0 <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8005fba:	e000      	b.n	8005fbe <create_name+0xb2>
 8005fbc:	3601      	adds	r6, #1
 8005fbe:	f835 2016 	ldrh.w	r2, [r5, r6, lsl #1]
 8005fc2:	2a20      	cmp	r2, #32
 8005fc4:	d0fa      	beq.n	8005fbc <create_name+0xb0>
 8005fc6:	2a2e      	cmp	r2, #46	; 0x2e
 8005fc8:	d0f8      	beq.n	8005fbc <create_name+0xb0>
	if (si) cf |= NS_LOSS | NS_LFN;
 8005fca:	b11e      	cbz	r6, 8005fd4 <create_name+0xc8>
 8005fcc:	f048 0803 	orr.w	r8, r8, #3
 8005fd0:	e000      	b.n	8005fd4 <create_name+0xc8>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8005fd2:	3c01      	subs	r4, #1
 8005fd4:	b16c      	cbz	r4, 8005ff2 <create_name+0xe6>
 8005fd6:	f104 4200 	add.w	r2, r4, #2147483648	; 0x80000000
 8005fda:	3a01      	subs	r2, #1
 8005fdc:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8005fe0:	2a2e      	cmp	r2, #46	; 0x2e
 8005fe2:	d1f6      	bne.n	8005fd2 <create_name+0xc6>
 8005fe4:	f04f 0b08 	mov.w	fp, #8
 8005fe8:	f04f 0a00 	mov.w	sl, #0
 8005fec:	f8cd a004 	str.w	sl, [sp, #4]
 8005ff0:	e00a      	b.n	8006008 <create_name+0xfc>
 8005ff2:	46a2      	mov	sl, r4
 8005ff4:	f04f 0b08 	mov.w	fp, #8
 8005ff8:	2300      	movs	r3, #0
 8005ffa:	9301      	str	r3, [sp, #4]
 8005ffc:	e004      	b.n	8006008 <create_name+0xfc>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8005ffe:	454c      	cmp	r4, r9
 8006000:	d00b      	beq.n	800601a <create_name+0x10e>
			cf |= NS_LOSS | NS_LFN; continue;
 8006002:	f048 0803 	orr.w	r8, r8, #3
		w = lfn[si++];					/* Get an LFN character */
 8006006:	464e      	mov	r6, r9
 8006008:	f106 0901 	add.w	r9, r6, #1
 800600c:	f835 6016 	ldrh.w	r6, [r5, r6, lsl #1]
		if (!w) break;					/* Break on end of the LFN */
 8006010:	b366      	cbz	r6, 800606c <create_name+0x160>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8006012:	2e20      	cmp	r6, #32
 8006014:	d0f5      	beq.n	8006002 <create_name+0xf6>
 8006016:	2e2e      	cmp	r6, #46	; 0x2e
 8006018:	d0f1      	beq.n	8005ffe <create_name+0xf2>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 800601a:	45da      	cmp	sl, fp
 800601c:	d211      	bcs.n	8006042 <create_name+0x136>
 800601e:	454c      	cmp	r4, r9
 8006020:	d00f      	beq.n	8006042 <create_name+0x136>
		if (w >= 0x80) {				/* Non ASCII character */
 8006022:	2e7f      	cmp	r6, #127	; 0x7f
 8006024:	d845      	bhi.n	80060b2 <create_name+0x1a6>
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8006026:	2e00      	cmp	r6, #0
 8006028:	d150      	bne.n	80060cc <create_name+0x1c0>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800602a:	f048 0803 	orr.w	r8, r8, #3
 800602e:	265f      	movs	r6, #95	; 0x5f
		dp->fn[i++] = (BYTE)w;
 8006030:	f241 0318 	movw	r3, #4120	; 0x1018
 8006034:	58fb      	ldr	r3, [r7, r3]
 8006036:	f803 600a 	strb.w	r6, [r3, sl]
		w = lfn[si++];					/* Get an LFN character */
 800603a:	464e      	mov	r6, r9
		dp->fn[i++] = (BYTE)w;
 800603c:	f10a 0a01 	add.w	sl, sl, #1
 8006040:	e7e2      	b.n	8006008 <create_name+0xfc>
			if (ni == 11) {				/* Long extension */
 8006042:	f1bb 0f0b 	cmp.w	fp, #11
 8006046:	d00f      	beq.n	8006068 <create_name+0x15c>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8006048:	454c      	cmp	r4, r9
 800604a:	d001      	beq.n	8006050 <create_name+0x144>
 800604c:	f048 0803 	orr.w	r8, r8, #3
			if (si > di) break;			/* No extension */
 8006050:	454c      	cmp	r4, r9
 8006052:	d30b      	bcc.n	800606c <create_name+0x160>
			b <<= 2; continue;
 8006054:	9b01      	ldr	r3, [sp, #4]
 8006056:	009b      	lsls	r3, r3, #2
 8006058:	b2db      	uxtb	r3, r3
 800605a:	9301      	str	r3, [sp, #4]
			si = di; i = 8; ni = 11;	/* Enter extension section */
 800605c:	4626      	mov	r6, r4
 800605e:	f04f 0b0b 	mov.w	fp, #11
 8006062:	f04f 0a08 	mov.w	sl, #8
			b <<= 2; continue;
 8006066:	e7cf      	b.n	8006008 <create_name+0xfc>
				cf |= NS_LOSS | NS_LFN; break;
 8006068:	f048 0803 	orr.w	r8, r8, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
 800606c:	f241 0318 	movw	r3, #4120	; 0x1018
 8006070:	58fb      	ldr	r3, [r7, r3]
 8006072:	781a      	ldrb	r2, [r3, #0]
 8006074:	2ae5      	cmp	r2, #229	; 0xe5
 8006076:	d045      	beq.n	8006104 <create_name+0x1f8>
	if (ni == 8) b <<= 2;
 8006078:	f1bb 0f08 	cmp.w	fp, #8
 800607c:	d045      	beq.n	800610a <create_name+0x1fe>
 800607e:	9901      	ldr	r1, [sp, #4]
 8006080:	f001 020c 	and.w	r2, r1, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 8006084:	2a0c      	cmp	r2, #12
 8006086:	d045      	beq.n	8006114 <create_name+0x208>
 8006088:	f001 0303 	and.w	r3, r1, #3
 800608c:	2b03      	cmp	r3, #3
 800608e:	d041      	beq.n	8006114 <create_name+0x208>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8006090:	f018 0f02 	tst.w	r8, #2
 8006094:	d106      	bne.n	80060a4 <create_name+0x198>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8006096:	9b01      	ldr	r3, [sp, #4]
 8006098:	f003 0303 	and.w	r3, r3, #3
 800609c:	2b01      	cmp	r3, #1
 800609e:	d03c      	beq.n	800611a <create_name+0x20e>
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 80060a0:	2a04      	cmp	r2, #4
 80060a2:	d03d      	beq.n	8006120 <create_name+0x214>
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 80060a4:	f241 0318 	movw	r3, #4120	; 0x1018
 80060a8:	58fb      	ldr	r3, [r7, r3]
 80060aa:	f883 800b 	strb.w	r8, [r3, #11]
	return FR_OK;
 80060ae:	2000      	movs	r0, #0
 80060b0:	e776      	b.n	8005fa0 <create_name+0x94>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 80060b2:	2100      	movs	r1, #0
 80060b4:	4630      	mov	r0, r6
 80060b6:	f001 fa5f 	bl	8007578 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 80060ba:	4606      	mov	r6, r0
 80060bc:	b118      	cbz	r0, 80060c6 <create_name+0x1ba>
 80060be:	f1a0 0680 	sub.w	r6, r0, #128	; 0x80
 80060c2:	4b1c      	ldr	r3, [pc, #112]	; (8006134 <create_name+0x228>)
 80060c4:	5d9e      	ldrb	r6, [r3, r6]
			cf |= NS_LFN;				/* Force create LFN entry */
 80060c6:	f048 0802 	orr.w	r8, r8, #2
 80060ca:	e7ac      	b.n	8006026 <create_name+0x11a>
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 80060cc:	4631      	mov	r1, r6
 80060ce:	481a      	ldr	r0, [pc, #104]	; (8006138 <create_name+0x22c>)
 80060d0:	f7ff f9a7 	bl	8005422 <chk_chr>
 80060d4:	2800      	cmp	r0, #0
 80060d6:	d1a8      	bne.n	800602a <create_name+0x11e>
				if (IsUpper(w)) {		/* ASCII large capital */
 80060d8:	f1a6 0341 	sub.w	r3, r6, #65	; 0x41
 80060dc:	b29b      	uxth	r3, r3
 80060de:	2b19      	cmp	r3, #25
 80060e0:	d804      	bhi.n	80060ec <create_name+0x1e0>
					b |= 2;
 80060e2:	9b01      	ldr	r3, [sp, #4]
 80060e4:	f043 0302 	orr.w	r3, r3, #2
 80060e8:	9301      	str	r3, [sp, #4]
 80060ea:	e7a1      	b.n	8006030 <create_name+0x124>
					if (IsLower(w)) {	/* ASCII small capital */
 80060ec:	f1a6 0361 	sub.w	r3, r6, #97	; 0x61
 80060f0:	b29b      	uxth	r3, r3
 80060f2:	2b19      	cmp	r3, #25
 80060f4:	d89c      	bhi.n	8006030 <create_name+0x124>
						b |= 1; w -= 0x20;
 80060f6:	9b01      	ldr	r3, [sp, #4]
 80060f8:	f043 0301 	orr.w	r3, r3, #1
 80060fc:	9301      	str	r3, [sp, #4]
 80060fe:	3e20      	subs	r6, #32
 8006100:	b2b6      	uxth	r6, r6
 8006102:	e795      	b.n	8006030 <create_name+0x124>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
 8006104:	2205      	movs	r2, #5
 8006106:	701a      	strb	r2, [r3, #0]
 8006108:	e7b6      	b.n	8006078 <create_name+0x16c>
	if (ni == 8) b <<= 2;
 800610a:	9b01      	ldr	r3, [sp, #4]
 800610c:	009b      	lsls	r3, r3, #2
 800610e:	b2db      	uxtb	r3, r3
 8006110:	9301      	str	r3, [sp, #4]
 8006112:	e7b4      	b.n	800607e <create_name+0x172>
		cf |= NS_LFN;
 8006114:	f048 0802 	orr.w	r8, r8, #2
 8006118:	e7ba      	b.n	8006090 <create_name+0x184>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800611a:	f048 0810 	orr.w	r8, r8, #16
 800611e:	e7bf      	b.n	80060a0 <create_name+0x194>
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8006120:	f048 0808 	orr.w	r8, r8, #8
 8006124:	e7be      	b.n	80060a4 <create_name+0x198>
			return FR_INVALID_NAME;
 8006126:	2006      	movs	r0, #6
 8006128:	e73a      	b.n	8005fa0 <create_name+0x94>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 800612a:	2006      	movs	r0, #6
 800612c:	e738      	b.n	8005fa0 <create_name+0x94>
 800612e:	bf00      	nop
 8006130:	08009f78 	.word	0x08009f78
 8006134:	08009ee8 	.word	0x08009ee8
 8006138:	08009f84 	.word	0x08009f84

0800613c <get_fileinfo>:
{
 800613c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	p = fno->fname;
 800613e:	f101 0509 	add.w	r5, r1, #9
	if (dp->sect) {		/* Get SFN */
 8006142:	f241 0310 	movw	r3, #4112	; 0x1010
 8006146:	58c3      	ldr	r3, [r0, r3]
 8006148:	2b00      	cmp	r3, #0
 800614a:	d03e      	beq.n	80061ca <get_fileinfo+0x8e>
		dir = dp->dir;
 800614c:	f241 0314 	movw	r3, #4116	; 0x1014
 8006150:	58c6      	ldr	r6, [r0, r3]
		i = 0;
 8006152:	2300      	movs	r3, #0
		while (i < 11) {		/* Copy name body and extension */
 8006154:	e00a      	b.n	800616c <get_fileinfo+0x30>
			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8006156:	23e5      	movs	r3, #229	; 0xe5
 8006158:	e010      	b.n	800617c <get_fileinfo+0x40>
			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
 800615a:	242e      	movs	r4, #46	; 0x2e
 800615c:	702c      	strb	r4, [r5, #0]
 800615e:	3501      	adds	r5, #1
 8006160:	e00e      	b.n	8006180 <get_fileinfo+0x44>
			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
 8006162:	2710      	movs	r7, #16
 8006164:	e015      	b.n	8006192 <get_fileinfo+0x56>
			*p++ = c;
 8006166:	702b      	strb	r3, [r5, #0]
 8006168:	3501      	adds	r5, #1
 800616a:	4613      	mov	r3, r2
		while (i < 11) {		/* Copy name body and extension */
 800616c:	2b0a      	cmp	r3, #10
 800616e:	d815      	bhi.n	800619c <get_fileinfo+0x60>
			c = (TCHAR)dir[i++];
 8006170:	1c5a      	adds	r2, r3, #1
 8006172:	5cf3      	ldrb	r3, [r6, r3]
			if (c == ' ') continue;				/* Skip padding spaces */
 8006174:	2b20      	cmp	r3, #32
 8006176:	d0f8      	beq.n	800616a <get_fileinfo+0x2e>
			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8006178:	2b05      	cmp	r3, #5
 800617a:	d0ec      	beq.n	8006156 <get_fileinfo+0x1a>
			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
 800617c:	2a09      	cmp	r2, #9
 800617e:	d0ec      	beq.n	800615a <get_fileinfo+0x1e>
			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
 8006180:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 8006184:	b2e4      	uxtb	r4, r4
 8006186:	2c19      	cmp	r4, #25
 8006188:	d8ed      	bhi.n	8006166 <get_fileinfo+0x2a>
 800618a:	7b34      	ldrb	r4, [r6, #12]
 800618c:	2a08      	cmp	r2, #8
 800618e:	d8e8      	bhi.n	8006162 <get_fileinfo+0x26>
 8006190:	2708      	movs	r7, #8
 8006192:	4227      	tst	r7, r4
 8006194:	d0e7      	beq.n	8006166 <get_fileinfo+0x2a>
				c += 0x20;			/* To lower */
 8006196:	3320      	adds	r3, #32
 8006198:	b2db      	uxtb	r3, r3
 800619a:	e7e4      	b.n	8006166 <get_fileinfo+0x2a>
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 800619c:	7af3      	ldrb	r3, [r6, #11]
 800619e:	720b      	strb	r3, [r1, #8]
		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
 80061a0:	7ff2      	ldrb	r2, [r6, #31]
 80061a2:	7fb3      	ldrb	r3, [r6, #30]
 80061a4:	041b      	lsls	r3, r3, #16
 80061a6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80061aa:	7f72      	ldrb	r2, [r6, #29]
 80061ac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80061b0:	7f32      	ldrb	r2, [r6, #28]
 80061b2:	4313      	orrs	r3, r2
 80061b4:	600b      	str	r3, [r1, #0]
		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
 80061b6:	7e72      	ldrb	r2, [r6, #25]
 80061b8:	7e33      	ldrb	r3, [r6, #24]
 80061ba:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80061be:	808b      	strh	r3, [r1, #4]
		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
 80061c0:	7df2      	ldrb	r2, [r6, #23]
 80061c2:	7db3      	ldrb	r3, [r6, #22]
 80061c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80061c8:	80cb      	strh	r3, [r1, #6]
	*p = 0;		/* Terminate SFN string by a \0 */
 80061ca:	2300      	movs	r3, #0
 80061cc:	702b      	strb	r3, [r5, #0]
	if (fno->lfname) {
 80061ce:	698d      	ldr	r5, [r1, #24]
 80061d0:	b31d      	cbz	r5, 800621a <get_fileinfo+0xde>
		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
 80061d2:	f241 0310 	movw	r3, #4112	; 0x1010
 80061d6:	58c3      	ldr	r3, [r0, r3]
 80061d8:	b1e3      	cbz	r3, 8006214 <get_fileinfo+0xd8>
 80061da:	69cc      	ldr	r4, [r1, #28]
 80061dc:	b1dc      	cbz	r4, 8006216 <get_fileinfo+0xda>
 80061de:	f241 0324 	movw	r3, #4132	; 0x1024
 80061e2:	5ac2      	ldrh	r2, [r0, r3]
 80061e4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80061e8:	429a      	cmp	r2, r3
 80061ea:	d017      	beq.n	800621c <get_fileinfo+0xe0>
 80061ec:	460e      	mov	r6, r1
			lfn = dp->lfn;
 80061ee:	f500 5081 	add.w	r0, r0, #4128	; 0x1020
 80061f2:	6803      	ldr	r3, [r0, #0]
		i = 0; p = fno->lfname;
 80061f4:	2400      	movs	r4, #0
			while ((w = *lfn++) != 0) {		/* Get an LFN character */
 80061f6:	1c9f      	adds	r7, r3, #2
 80061f8:	8818      	ldrh	r0, [r3, #0]
 80061fa:	b160      	cbz	r0, 8006216 <get_fileinfo+0xda>
				w = ff_convert(w, 0);		/* Unicode -> OEM */
 80061fc:	2100      	movs	r1, #0
 80061fe:	f001 f9bb 	bl	8007578 <ff_convert>
				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
 8006202:	b168      	cbz	r0, 8006220 <get_fileinfo+0xe4>
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
 8006204:	69f3      	ldr	r3, [r6, #28]
 8006206:	3b01      	subs	r3, #1
 8006208:	429c      	cmp	r4, r3
 800620a:	d20b      	bcs.n	8006224 <get_fileinfo+0xe8>
				p[i++] = (TCHAR)w;
 800620c:	5528      	strb	r0, [r5, r4]
			while ((w = *lfn++) != 0) {		/* Get an LFN character */
 800620e:	463b      	mov	r3, r7
				p[i++] = (TCHAR)w;
 8006210:	3401      	adds	r4, #1
 8006212:	e7f0      	b.n	80061f6 <get_fileinfo+0xba>
		i = 0; p = fno->lfname;
 8006214:	2400      	movs	r4, #0
		p[i] = 0;	/* Terminate LFN string by a \0 */
 8006216:	2300      	movs	r3, #0
 8006218:	552b      	strb	r3, [r5, r4]
 800621a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		i = 0; p = fno->lfname;
 800621c:	2400      	movs	r4, #0
 800621e:	e7fa      	b.n	8006216 <get_fileinfo+0xda>
				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
 8006220:	2400      	movs	r4, #0
 8006222:	e7f8      	b.n	8006216 <get_fileinfo+0xda>
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
 8006224:	2400      	movs	r4, #0
 8006226:	e7f6      	b.n	8006216 <get_fileinfo+0xda>

08006228 <cmp_lfn>:
{
 8006228:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800622c:	4680      	mov	r8, r0
 800622e:	460d      	mov	r5, r1
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
 8006230:	780e      	ldrb	r6, [r1, #0]
 8006232:	f026 0640 	bic.w	r6, r6, #64	; 0x40
 8006236:	3e01      	subs	r6, #1
 8006238:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 800623c:	eb06 0683 	add.w	r6, r6, r3, lsl #2
	s = 0; wc = 1;
 8006240:	2701      	movs	r7, #1
 8006242:	2400      	movs	r4, #0
 8006244:	e010      	b.n	8006268 <cmp_lfn+0x40>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 8006246:	f001 f9b3 	bl	80075b0 <ff_wtoupper>
 800624a:	4607      	mov	r7, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 800624c:	2efe      	cmp	r6, #254	; 0xfe
 800624e:	d826      	bhi.n	800629e <cmp_lfn+0x76>
 8006250:	f106 0901 	add.w	r9, r6, #1
 8006254:	f838 0016 	ldrh.w	r0, [r8, r6, lsl #1]
 8006258:	f001 f9aa 	bl	80075b0 <ff_wtoupper>
 800625c:	4287      	cmp	r7, r0
 800625e:	d121      	bne.n	80062a4 <cmp_lfn+0x7c>
 8006260:	464e      	mov	r6, r9
	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
 8006262:	3401      	adds	r4, #1
 8006264:	2c0c      	cmp	r4, #12
 8006266:	d80f      	bhi.n	8006288 <cmp_lfn+0x60>
		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
 8006268:	4b14      	ldr	r3, [pc, #80]	; (80062bc <cmp_lfn+0x94>)
 800626a:	5d1b      	ldrb	r3, [r3, r4]
 800626c:	1c5a      	adds	r2, r3, #1
 800626e:	5caa      	ldrb	r2, [r5, r2]
 8006270:	5ce8      	ldrb	r0, [r5, r3]
 8006272:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
		if (wc) {	/* Last character has not been processed */
 8006276:	2f00      	cmp	r7, #0
 8006278:	d1e5      	bne.n	8006246 <cmp_lfn+0x1e>
			if (uc != 0xFFFF) return 0;	/* Check filler */
 800627a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800627e:	4298      	cmp	r0, r3
 8006280:	d0ef      	beq.n	8006262 <cmp_lfn+0x3a>
 8006282:	2000      	movs	r0, #0
 8006284:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
 8006288:	782b      	ldrb	r3, [r5, #0]
 800628a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800628e:	d00c      	beq.n	80062aa <cmp_lfn+0x82>
 8006290:	b177      	cbz	r7, 80062b0 <cmp_lfn+0x88>
 8006292:	f838 3016 	ldrh.w	r3, [r8, r6, lsl #1]
 8006296:	b973      	cbnz	r3, 80062b6 <cmp_lfn+0x8e>
	return 1;						/* The part of LFN matched */
 8006298:	2001      	movs	r0, #1
 800629a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				return 0;				/* Not matched */
 800629e:	2000      	movs	r0, #0
 80062a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80062a4:	2000      	movs	r0, #0
 80062a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return 1;						/* The part of LFN matched */
 80062aa:	2001      	movs	r0, #1
 80062ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80062b0:	2001      	movs	r0, #1
 80062b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return 0;
 80062b6:	2000      	movs	r0, #0
}
 80062b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80062bc:	08009f68 	.word	0x08009f68

080062c0 <clust2sect>:
	clst -= 2;
 80062c0:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80062c2:	f241 0314 	movw	r3, #4116	; 0x1014
 80062c6:	58c3      	ldr	r3, [r0, r3]
 80062c8:	3b02      	subs	r3, #2
 80062ca:	4299      	cmp	r1, r3
 80062cc:	d208      	bcs.n	80062e0 <clust2sect+0x20>
	return clst * fs->csize + fs->database;
 80062ce:	f241 0302 	movw	r3, #4098	; 0x1002
 80062d2:	5cc3      	ldrb	r3, [r0, r3]
 80062d4:	f241 0228 	movw	r2, #4136	; 0x1028
 80062d8:	5880      	ldr	r0, [r0, r2]
 80062da:	fb03 0001 	mla	r0, r3, r1, r0
 80062de:	4770      	bx	lr
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80062e0:	2000      	movs	r0, #0
}
 80062e2:	4770      	bx	lr

080062e4 <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80062e4:	2901      	cmp	r1, #1
 80062e6:	f240 8091 	bls.w	800640c <get_fat+0x128>
{
 80062ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80062ec:	f241 0314 	movw	r3, #4116	; 0x1014
 80062f0:	58c3      	ldr	r3, [r0, r3]
 80062f2:	4299      	cmp	r1, r3
 80062f4:	f080 808c 	bcs.w	8006410 <get_fat+0x12c>
 80062f8:	460d      	mov	r5, r1
 80062fa:	4604      	mov	r4, r0
		switch (fs->fs_type) {
 80062fc:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
 8006300:	781b      	ldrb	r3, [r3, #0]
 8006302:	2b02      	cmp	r3, #2
 8006304:	d03e      	beq.n	8006384 <get_fat+0xa0>
 8006306:	2b03      	cmp	r3, #3
 8006308:	d05a      	beq.n	80063c0 <get_fat+0xdc>
 800630a:	2b01      	cmp	r3, #1
 800630c:	d001      	beq.n	8006312 <get_fat+0x2e>
			val = 1;	/* Internal error */
 800630e:	2001      	movs	r0, #1
 8006310:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bc = (UINT)clst; bc += bc / 2;
 8006312:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8006316:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 800631a:	6819      	ldr	r1, [r3, #0]
 800631c:	f241 030a 	movw	r3, #4106	; 0x100a
 8006320:	5ac3      	ldrh	r3, [r0, r3]
 8006322:	fbb6 f3f3 	udiv	r3, r6, r3
 8006326:	4419      	add	r1, r3
 8006328:	f7ff faf1 	bl	800590e <move_window>
 800632c:	b110      	cbz	r0, 8006334 <get_fat+0x50>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800632e:	f04f 30ff 	mov.w	r0, #4294967295
 8006332:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win.d8[bc++ % SS(fs)];
 8006334:	1c77      	adds	r7, r6, #1
 8006336:	f241 030a 	movw	r3, #4106	; 0x100a
 800633a:	5ae3      	ldrh	r3, [r4, r3]
 800633c:	fbb6 f2f3 	udiv	r2, r6, r3
 8006340:	fb03 6612 	mls	r6, r3, r2, r6
 8006344:	5da6      	ldrb	r6, [r4, r6]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8006346:	f504 5281 	add.w	r2, r4, #4128	; 0x1020
 800634a:	6811      	ldr	r1, [r2, #0]
 800634c:	fbb7 f3f3 	udiv	r3, r7, r3
 8006350:	4419      	add	r1, r3
 8006352:	4620      	mov	r0, r4
 8006354:	f7ff fadb 	bl	800590e <move_window>
 8006358:	b110      	cbz	r0, 8006360 <get_fat+0x7c>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800635a:	f04f 30ff 	mov.w	r0, #4294967295
 800635e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc |= fs->win.d8[bc % SS(fs)] << 8;
 8006360:	f241 030a 	movw	r3, #4106	; 0x100a
 8006364:	5ae2      	ldrh	r2, [r4, r3]
 8006366:	fbb7 f3f2 	udiv	r3, r7, r2
 800636a:	fb02 7713 	mls	r7, r2, r3, r7
 800636e:	5de0      	ldrb	r0, [r4, r7]
 8006370:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8006374:	f015 0f01 	tst.w	r5, #1
 8006378:	d001      	beq.n	800637e <get_fat+0x9a>
 800637a:	0900      	lsrs	r0, r0, #4
 800637c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800637e:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8006382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8006384:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 8006388:	6819      	ldr	r1, [r3, #0]
 800638a:	f241 030a 	movw	r3, #4106	; 0x100a
 800638e:	5ac3      	ldrh	r3, [r0, r3]
 8006390:	085b      	lsrs	r3, r3, #1
 8006392:	fbb5 f3f3 	udiv	r3, r5, r3
 8006396:	4419      	add	r1, r3
 8006398:	f7ff fab9 	bl	800590e <move_window>
 800639c:	b110      	cbz	r0, 80063a4 <get_fat+0xc0>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800639e:	f04f 30ff 	mov.w	r0, #4294967295
 80063a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p = &fs->win.d8[clst * 2 % SS(fs)];
 80063a4:	0069      	lsls	r1, r5, #1
 80063a6:	f241 030a 	movw	r3, #4106	; 0x100a
 80063aa:	5ae2      	ldrh	r2, [r4, r3]
 80063ac:	fbb1 f3f2 	udiv	r3, r1, r2
 80063b0:	fb02 1113 	mls	r1, r2, r3, r1
 80063b4:	1863      	adds	r3, r4, r1
			val = LD_WORD(p);
 80063b6:	785b      	ldrb	r3, [r3, #1]
 80063b8:	5c60      	ldrb	r0, [r4, r1]
 80063ba:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			break;
 80063be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80063c0:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 80063c4:	6819      	ldr	r1, [r3, #0]
 80063c6:	f241 030a 	movw	r3, #4106	; 0x100a
 80063ca:	5ac3      	ldrh	r3, [r0, r3]
 80063cc:	089b      	lsrs	r3, r3, #2
 80063ce:	fbb5 f3f3 	udiv	r3, r5, r3
 80063d2:	4419      	add	r1, r3
 80063d4:	f7ff fa9b 	bl	800590e <move_window>
 80063d8:	b110      	cbz	r0, 80063e0 <get_fat+0xfc>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80063da:	f04f 30ff 	mov.w	r0, #4294967295
}
 80063de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p = &fs->win.d8[clst * 4 % SS(fs)];
 80063e0:	00a9      	lsls	r1, r5, #2
 80063e2:	f241 030a 	movw	r3, #4106	; 0x100a
 80063e6:	5ae3      	ldrh	r3, [r4, r3]
 80063e8:	fbb1 f5f3 	udiv	r5, r1, r3
 80063ec:	fb03 1115 	mls	r1, r3, r5, r1
 80063f0:	1863      	adds	r3, r4, r1
			val = LD_DWORD(p) & 0x0FFFFFFF;
 80063f2:	78da      	ldrb	r2, [r3, #3]
 80063f4:	7898      	ldrb	r0, [r3, #2]
 80063f6:	0400      	lsls	r0, r0, #16
 80063f8:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 80063fc:	785b      	ldrb	r3, [r3, #1]
 80063fe:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8006402:	5c63      	ldrb	r3, [r4, r1]
 8006404:	4318      	orrs	r0, r3
 8006406:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
 800640a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 800640c:	2001      	movs	r0, #1
 800640e:	4770      	bx	lr
 8006410:	2001      	movs	r0, #1
 8006412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006414 <dir_sdi>:
{
 8006414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006416:	4605      	mov	r5, r0
	dp->index = (WORD)idx;	/* Current index */
 8006418:	f241 0306 	movw	r3, #4102	; 0x1006
 800641c:	52c1      	strh	r1, [r0, r3]
	clst = dp->sclust;		/* Table start cluster (0:root) */
 800641e:	f241 0308 	movw	r3, #4104	; 0x1008
 8006422:	58c4      	ldr	r4, [r0, r3]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8006424:	2c01      	cmp	r4, #1
 8006426:	d067      	beq.n	80064f8 <dir_sdi+0xe4>
 8006428:	460e      	mov	r6, r1
 800642a:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
 800642e:	681b      	ldr	r3, [r3, #0]
 8006430:	f241 0214 	movw	r2, #4116	; 0x1014
 8006434:	589a      	ldr	r2, [r3, r2]
 8006436:	4294      	cmp	r4, r2
 8006438:	d301      	bcc.n	800643e <dir_sdi+0x2a>
		return FR_INT_ERR;
 800643a:	2002      	movs	r0, #2
 800643c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 800643e:	b924      	cbnz	r4, 800644a <dir_sdi+0x36>
 8006440:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8006444:	7812      	ldrb	r2, [r2, #0]
 8006446:	2a03      	cmp	r2, #3
 8006448:	d007      	beq.n	800645a <dir_sdi+0x46>
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800644a:	b99c      	cbnz	r4, 8006474 <dir_sdi+0x60>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 800644c:	f241 0208 	movw	r2, #4104	; 0x1008
 8006450:	5a9a      	ldrh	r2, [r3, r2]
 8006452:	4296      	cmp	r6, r2
 8006454:	d305      	bcc.n	8006462 <dir_sdi+0x4e>
			return FR_INT_ERR;
 8006456:	2002      	movs	r0, #2
 8006458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = dp->fs->dirbase;
 800645a:	f241 0224 	movw	r2, #4132	; 0x1024
 800645e:	589c      	ldr	r4, [r3, r2]
 8006460:	e7f3      	b.n	800644a <dir_sdi+0x36>
		sect = dp->fs->dirbase;
 8006462:	f241 0224 	movw	r2, #4132	; 0x1024
 8006466:	5898      	ldr	r0, [r3, r2]
	dp->clust = clst;	/* Current cluster# */
 8006468:	f241 030c 	movw	r3, #4108	; 0x100c
 800646c:	50ec      	str	r4, [r5, r3]
	if (!sect) return FR_INT_ERR;
 800646e:	bb48      	cbnz	r0, 80064c4 <dir_sdi+0xb0>
 8006470:	2002      	movs	r0, #2
}
 8006472:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
 8006474:	f241 020a 	movw	r2, #4106	; 0x100a
 8006478:	5a9f      	ldrh	r7, [r3, r2]
 800647a:	097a      	lsrs	r2, r7, #5
 800647c:	f241 0102 	movw	r1, #4098	; 0x1002
 8006480:	5c5f      	ldrb	r7, [r3, r1]
 8006482:	fb07 f702 	mul.w	r7, r7, r2
		while (idx >= ic) {	/* Follow cluster chain */
 8006486:	42be      	cmp	r6, r7
 8006488:	d315      	bcc.n	80064b6 <dir_sdi+0xa2>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 800648a:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 800648e:	4621      	mov	r1, r4
 8006490:	6818      	ldr	r0, [r3, #0]
 8006492:	f7ff ff27 	bl	80062e4 <get_fat>
 8006496:	4604      	mov	r4, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8006498:	f1b0 3fff 	cmp.w	r0, #4294967295
 800649c:	d02e      	beq.n	80064fc <dir_sdi+0xe8>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 800649e:	2801      	cmp	r0, #1
 80064a0:	d92e      	bls.n	8006500 <dir_sdi+0xec>
 80064a2:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80064a6:	681a      	ldr	r2, [r3, #0]
 80064a8:	f241 0314 	movw	r3, #4116	; 0x1014
 80064ac:	58d3      	ldr	r3, [r2, r3]
 80064ae:	4298      	cmp	r0, r3
 80064b0:	d228      	bcs.n	8006504 <dir_sdi+0xf0>
			idx -= ic;
 80064b2:	1bf6      	subs	r6, r6, r7
 80064b4:	e7e7      	b.n	8006486 <dir_sdi+0x72>
		sect = clust2sect(dp->fs, clst);
 80064b6:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80064ba:	4621      	mov	r1, r4
 80064bc:	6818      	ldr	r0, [r3, #0]
 80064be:	f7ff feff 	bl	80062c0 <clust2sect>
 80064c2:	e7d1      	b.n	8006468 <dir_sdi+0x54>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 80064c4:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80064c8:	681b      	ldr	r3, [r3, #0]
 80064ca:	f241 010a 	movw	r1, #4106	; 0x100a
 80064ce:	5a5a      	ldrh	r2, [r3, r1]
 80064d0:	0952      	lsrs	r2, r2, #5
 80064d2:	fbb6 f2f2 	udiv	r2, r6, r2
 80064d6:	4410      	add	r0, r2
 80064d8:	f241 0210 	movw	r2, #4112	; 0x1010
 80064dc:	50a8      	str	r0, [r5, r2]
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 80064de:	5a5a      	ldrh	r2, [r3, r1]
 80064e0:	0952      	lsrs	r2, r2, #5
 80064e2:	fbb6 f1f2 	udiv	r1, r6, r2
 80064e6:	fb02 6611 	mls	r6, r2, r1, r6
 80064ea:	eb03 1346 	add.w	r3, r3, r6, lsl #5
 80064ee:	f241 0214 	movw	r2, #4116	; 0x1014
 80064f2:	50ab      	str	r3, [r5, r2]
	return FR_OK;
 80064f4:	2000      	movs	r0, #0
 80064f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_INT_ERR;
 80064f8:	2002      	movs	r0, #2
 80064fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80064fc:	2001      	movs	r0, #1
 80064fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return FR_INT_ERR;
 8006500:	2002      	movs	r0, #2
 8006502:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006504:	2002      	movs	r0, #2
 8006506:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006508 <put_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8006508:	2901      	cmp	r1, #1
 800650a:	f240 80ba 	bls.w	8006682 <put_fat+0x17a>
 800650e:	f241 0314 	movw	r3, #4116	; 0x1014
 8006512:	58c3      	ldr	r3, [r0, r3]
 8006514:	4299      	cmp	r1, r3
 8006516:	d301      	bcc.n	800651c <put_fat+0x14>
		res = FR_INT_ERR;
 8006518:	2302      	movs	r3, #2
 800651a:	e0b3      	b.n	8006684 <put_fat+0x17c>
{
 800651c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006520:	4616      	mov	r6, r2
 8006522:	460c      	mov	r4, r1
 8006524:	4605      	mov	r5, r0
		switch (fs->fs_type) {
 8006526:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
 800652a:	781b      	ldrb	r3, [r3, #0]
 800652c:	2b02      	cmp	r3, #2
 800652e:	d058      	beq.n	80065e2 <put_fat+0xda>
 8006530:	2b03      	cmp	r3, #3
 8006532:	d077      	beq.n	8006624 <put_fat+0x11c>
 8006534:	2b01      	cmp	r3, #1
 8006536:	d003      	beq.n	8006540 <put_fat+0x38>
			res = FR_INT_ERR;
 8006538:	2302      	movs	r3, #2
}
 800653a:	4618      	mov	r0, r3
 800653c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc = (UINT)clst; bc += bc / 2;
 8006540:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8006544:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 8006548:	6819      	ldr	r1, [r3, #0]
 800654a:	f241 030a 	movw	r3, #4106	; 0x100a
 800654e:	5ac3      	ldrh	r3, [r0, r3]
 8006550:	fbb7 f3f3 	udiv	r3, r7, r3
 8006554:	4419      	add	r1, r3
 8006556:	f7ff f9da 	bl	800590e <move_window>
			if (res != FR_OK) break;
 800655a:	4603      	mov	r3, r0
 800655c:	2800      	cmp	r0, #0
 800655e:	d1ec      	bne.n	800653a <put_fat+0x32>
			p = &fs->win.d8[bc++ % SS(fs)];
 8006560:	f107 0801 	add.w	r8, r7, #1
 8006564:	f241 030a 	movw	r3, #4106	; 0x100a
 8006568:	5aeb      	ldrh	r3, [r5, r3]
 800656a:	fbb7 f2f3 	udiv	r2, r7, r3
 800656e:	fb03 7712 	mls	r7, r3, r2, r7
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8006572:	f014 0401 	ands.w	r4, r4, #1
 8006576:	d029      	beq.n	80065cc <put_fat+0xc4>
 8006578:	57ea      	ldrsb	r2, [r5, r7]
 800657a:	f002 020f 	and.w	r2, r2, #15
 800657e:	0131      	lsls	r1, r6, #4
 8006580:	f401 617f 	and.w	r1, r1, #4080	; 0xff0
 8006584:	430a      	orrs	r2, r1
 8006586:	b2d2      	uxtb	r2, r2
 8006588:	55ea      	strb	r2, [r5, r7]
			fs->wflag = 1;
 800658a:	2101      	movs	r1, #1
 800658c:	f241 0204 	movw	r2, #4100	; 0x1004
 8006590:	54a9      	strb	r1, [r5, r2]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8006592:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
 8006596:	6811      	ldr	r1, [r2, #0]
 8006598:	fbb8 f3f3 	udiv	r3, r8, r3
 800659c:	4419      	add	r1, r3
 800659e:	4628      	mov	r0, r5
 80065a0:	f7ff f9b5 	bl	800590e <move_window>
			if (res != FR_OK) break;
 80065a4:	4603      	mov	r3, r0
 80065a6:	2800      	cmp	r0, #0
 80065a8:	d1c7      	bne.n	800653a <put_fat+0x32>
			p = &fs->win.d8[bc % SS(fs)];
 80065aa:	f241 020a 	movw	r2, #4106	; 0x100a
 80065ae:	5aa9      	ldrh	r1, [r5, r2]
 80065b0:	fbb8 f2f1 	udiv	r2, r8, r1
 80065b4:	fb01 8812 	mls	r8, r1, r2, r8
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 80065b8:	b154      	cbz	r4, 80065d0 <put_fat+0xc8>
 80065ba:	f3c6 1207 	ubfx	r2, r6, #4, #8
 80065be:	f805 2008 	strb.w	r2, [r5, r8]
			fs->wflag = 1;
 80065c2:	2101      	movs	r1, #1
 80065c4:	f241 0204 	movw	r2, #4100	; 0x1004
 80065c8:	54a9      	strb	r1, [r5, r2]
			break;
 80065ca:	e7b6      	b.n	800653a <put_fat+0x32>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80065cc:	b2f2      	uxtb	r2, r6
 80065ce:	e7db      	b.n	8006588 <put_fat+0x80>
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 80065d0:	f915 2008 	ldrsb.w	r2, [r5, r8]
 80065d4:	f022 020f 	bic.w	r2, r2, #15
 80065d8:	f3c6 2603 	ubfx	r6, r6, #8, #4
 80065dc:	4332      	orrs	r2, r6
 80065de:	b2d2      	uxtb	r2, r2
 80065e0:	e7ed      	b.n	80065be <put_fat+0xb6>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80065e2:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 80065e6:	6819      	ldr	r1, [r3, #0]
 80065e8:	f241 030a 	movw	r3, #4106	; 0x100a
 80065ec:	5ac3      	ldrh	r3, [r0, r3]
 80065ee:	085b      	lsrs	r3, r3, #1
 80065f0:	fbb4 f3f3 	udiv	r3, r4, r3
 80065f4:	4419      	add	r1, r3
 80065f6:	f7ff f98a 	bl	800590e <move_window>
			if (res != FR_OK) break;
 80065fa:	4603      	mov	r3, r0
 80065fc:	2800      	cmp	r0, #0
 80065fe:	d19c      	bne.n	800653a <put_fat+0x32>
			p = &fs->win.d8[clst * 2 % SS(fs)];
 8006600:	0061      	lsls	r1, r4, #1
 8006602:	f241 020a 	movw	r2, #4106	; 0x100a
 8006606:	5aa8      	ldrh	r0, [r5, r2]
 8006608:	fbb1 f2f0 	udiv	r2, r1, r0
 800660c:	fb00 1112 	mls	r1, r0, r2, r1
 8006610:	1868      	adds	r0, r5, r1
			ST_WORD(p, (WORD)val);
 8006612:	546e      	strb	r6, [r5, r1]
 8006614:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8006618:	7042      	strb	r2, [r0, #1]
			fs->wflag = 1;
 800661a:	2101      	movs	r1, #1
 800661c:	f241 0204 	movw	r2, #4100	; 0x1004
 8006620:	54a9      	strb	r1, [r5, r2]
			break;
 8006622:	e78a      	b.n	800653a <put_fat+0x32>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8006624:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 8006628:	6819      	ldr	r1, [r3, #0]
 800662a:	f241 030a 	movw	r3, #4106	; 0x100a
 800662e:	5ac3      	ldrh	r3, [r0, r3]
 8006630:	089b      	lsrs	r3, r3, #2
 8006632:	fbb4 f3f3 	udiv	r3, r4, r3
 8006636:	4419      	add	r1, r3
 8006638:	f7ff f969 	bl	800590e <move_window>
			if (res != FR_OK) break;
 800663c:	4603      	mov	r3, r0
 800663e:	2800      	cmp	r0, #0
 8006640:	f47f af7b 	bne.w	800653a <put_fat+0x32>
			p = &fs->win.d8[clst * 4 % SS(fs)];
 8006644:	00a1      	lsls	r1, r4, #2
 8006646:	f241 020a 	movw	r2, #4106	; 0x100a
 800664a:	5aaa      	ldrh	r2, [r5, r2]
 800664c:	fbb1 f4f2 	udiv	r4, r1, r2
 8006650:	fb02 1114 	mls	r1, r2, r4, r1
 8006654:	1868      	adds	r0, r5, r1
			val |= LD_DWORD(p) & 0xF0000000;
 8006656:	78c4      	ldrb	r4, [r0, #3]
 8006658:	7882      	ldrb	r2, [r0, #2]
 800665a:	0412      	lsls	r2, r2, #16
 800665c:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
 8006660:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8006664:	4332      	orrs	r2, r6
			ST_DWORD(p, val);
 8006666:	546a      	strb	r2, [r5, r1]
 8006668:	f3c2 2107 	ubfx	r1, r2, #8, #8
 800666c:	7041      	strb	r1, [r0, #1]
 800666e:	f3c2 4107 	ubfx	r1, r2, #16, #8
 8006672:	7081      	strb	r1, [r0, #2]
 8006674:	0e12      	lsrs	r2, r2, #24
 8006676:	70c2      	strb	r2, [r0, #3]
			fs->wflag = 1;
 8006678:	2101      	movs	r1, #1
 800667a:	f241 0204 	movw	r2, #4100	; 0x1004
 800667e:	54a9      	strb	r1, [r5, r2]
			break;
 8006680:	e75b      	b.n	800653a <put_fat+0x32>
		res = FR_INT_ERR;
 8006682:	2302      	movs	r3, #2
}
 8006684:	4618      	mov	r0, r3
 8006686:	4770      	bx	lr

08006688 <create_chain>:
{
 8006688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800668a:	4605      	mov	r5, r0
	if (clst == 0) {		/* Create a new chain */
 800668c:	460f      	mov	r7, r1
 800668e:	b951      	cbnz	r1, 80066a6 <create_chain+0x1e>
		scl = fs->last_clust;			/* Get suggested start point */
 8006690:	f241 030c 	movw	r3, #4108	; 0x100c
 8006694:	58c6      	ldr	r6, [r0, r3]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8006696:	b1ae      	cbz	r6, 80066c4 <create_chain+0x3c>
 8006698:	f241 0314 	movw	r3, #4116	; 0x1014
 800669c:	58c3      	ldr	r3, [r0, r3]
 800669e:	429e      	cmp	r6, r3
 80066a0:	d311      	bcc.n	80066c6 <create_chain+0x3e>
 80066a2:	2601      	movs	r6, #1
 80066a4:	e00f      	b.n	80066c6 <create_chain+0x3e>
		cs = get_fat(fs, clst);			/* Check the cluster status */
 80066a6:	f7ff fe1d 	bl	80062e4 <get_fat>
 80066aa:	4603      	mov	r3, r0
		if (cs < 2) return 1;			/* Invalid value */
 80066ac:	2801      	cmp	r0, #1
 80066ae:	d950      	bls.n	8006752 <create_chain+0xca>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 80066b0:	f1b0 3fff 	cmp.w	r0, #4294967295
 80066b4:	d052      	beq.n	800675c <create_chain+0xd4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 80066b6:	f241 0214 	movw	r2, #4116	; 0x1014
 80066ba:	58aa      	ldr	r2, [r5, r2]
 80066bc:	4290      	cmp	r0, r2
 80066be:	d34d      	bcc.n	800675c <create_chain+0xd4>
		scl = clst;
 80066c0:	463e      	mov	r6, r7
 80066c2:	e000      	b.n	80066c6 <create_chain+0x3e>
		if (!scl || scl >= fs->n_fatent) scl = 1;
 80066c4:	2601      	movs	r6, #1
	ncl = scl;				/* Start cluster */
 80066c6:	4634      	mov	r4, r6
 80066c8:	e00c      	b.n	80066e4 <create_chain+0x5c>
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 80066ca:	4621      	mov	r1, r4
 80066cc:	4628      	mov	r0, r5
 80066ce:	f7ff fe09 	bl	80062e4 <get_fat>
		if (cs == 0) break;				/* Found a free cluster */
 80066d2:	4603      	mov	r3, r0
 80066d4:	b180      	cbz	r0, 80066f8 <create_chain+0x70>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 80066d6:	f1b0 3fff 	cmp.w	r0, #4294967295
 80066da:	d03f      	beq.n	800675c <create_chain+0xd4>
 80066dc:	2801      	cmp	r0, #1
 80066de:	d03d      	beq.n	800675c <create_chain+0xd4>
		if (ncl == scl) return 0;		/* No free cluster */
 80066e0:	42b4      	cmp	r4, r6
 80066e2:	d03a      	beq.n	800675a <create_chain+0xd2>
		ncl++;							/* Next cluster */
 80066e4:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 80066e6:	f241 0314 	movw	r3, #4116	; 0x1014
 80066ea:	58eb      	ldr	r3, [r5, r3]
 80066ec:	429c      	cmp	r4, r3
 80066ee:	d3ec      	bcc.n	80066ca <create_chain+0x42>
			if (ncl > scl) return 0;	/* No free cluster */
 80066f0:	2e01      	cmp	r6, #1
 80066f2:	d930      	bls.n	8006756 <create_chain+0xce>
			ncl = 2;
 80066f4:	2402      	movs	r4, #2
 80066f6:	e7e8      	b.n	80066ca <create_chain+0x42>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 80066f8:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80066fc:	4621      	mov	r1, r4
 80066fe:	4628      	mov	r0, r5
 8006700:	f7ff ff02 	bl	8006508 <put_fat>
	if (res == FR_OK && clst != 0) {
 8006704:	4603      	mov	r3, r0
 8006706:	b900      	cbnz	r0, 800670a <create_chain+0x82>
 8006708:	b9af      	cbnz	r7, 8006736 <create_chain+0xae>
	if (res == FR_OK) {
 800670a:	b9db      	cbnz	r3, 8006744 <create_chain+0xbc>
		fs->last_clust = ncl;			/* Update FSINFO */
 800670c:	f241 030c 	movw	r3, #4108	; 0x100c
 8006710:	50ec      	str	r4, [r5, r3]
		if (fs->free_clust != 0xFFFFFFFF) {
 8006712:	f241 0310 	movw	r3, #4112	; 0x1010
 8006716:	58eb      	ldr	r3, [r5, r3]
 8006718:	f1b3 3fff 	cmp.w	r3, #4294967295
 800671c:	d020      	beq.n	8006760 <create_chain+0xd8>
			fs->free_clust--;
 800671e:	3b01      	subs	r3, #1
 8006720:	f241 0210 	movw	r2, #4112	; 0x1010
 8006724:	50ab      	str	r3, [r5, r2]
			fs->fsi_flag |= 1;
 8006726:	f241 0205 	movw	r2, #4101	; 0x1005
 800672a:	5cab      	ldrb	r3, [r5, r2]
 800672c:	f043 0301 	orr.w	r3, r3, #1
 8006730:	54ab      	strb	r3, [r5, r2]
 8006732:	4623      	mov	r3, r4
 8006734:	e012      	b.n	800675c <create_chain+0xd4>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 8006736:	4622      	mov	r2, r4
 8006738:	4639      	mov	r1, r7
 800673a:	4628      	mov	r0, r5
 800673c:	f7ff fee4 	bl	8006508 <put_fat>
 8006740:	4603      	mov	r3, r0
 8006742:	e7e2      	b.n	800670a <create_chain+0x82>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8006744:	2b01      	cmp	r3, #1
 8006746:	d001      	beq.n	800674c <create_chain+0xc4>
 8006748:	2301      	movs	r3, #1
 800674a:	e007      	b.n	800675c <create_chain+0xd4>
 800674c:	f04f 33ff 	mov.w	r3, #4294967295
 8006750:	e004      	b.n	800675c <create_chain+0xd4>
		if (cs < 2) return 1;			/* Invalid value */
 8006752:	2301      	movs	r3, #1
 8006754:	e002      	b.n	800675c <create_chain+0xd4>
			if (ncl > scl) return 0;	/* No free cluster */
 8006756:	2300      	movs	r3, #0
 8006758:	e000      	b.n	800675c <create_chain+0xd4>
		if (ncl == scl) return 0;		/* No free cluster */
 800675a:	2300      	movs	r3, #0
}
 800675c:	4618      	mov	r0, r3
 800675e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006760:	4623      	mov	r3, r4
 8006762:	e7fb      	b.n	800675c <create_chain+0xd4>

08006764 <dir_next>:
{
 8006764:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	i = dp->index + 1;
 8006768:	f241 0306 	movw	r3, #4102	; 0x1006
 800676c:	5ac4      	ldrh	r4, [r0, r3]
 800676e:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8006770:	b2a3      	uxth	r3, r4
 8006772:	b913      	cbnz	r3, 800677a <dir_next+0x16>
		return FR_NO_FILE;
 8006774:	2004      	movs	r0, #4
 8006776:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 800677a:	f241 0310 	movw	r3, #4112	; 0x1010
 800677e:	58c3      	ldr	r3, [r0, r3]
 8006780:	b913      	cbnz	r3, 8006788 <dir_next+0x24>
		return FR_NO_FILE;
 8006782:	2004      	movs	r0, #4
 8006784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006788:	460e      	mov	r6, r1
 800678a:	4605      	mov	r5, r0
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
 800678c:	f500 5280 	add.w	r2, r0, #4096	; 0x1000
 8006790:	6810      	ldr	r0, [r2, #0]
 8006792:	f241 020a 	movw	r2, #4106	; 0x100a
 8006796:	5a82      	ldrh	r2, [r0, r2]
 8006798:	0952      	lsrs	r2, r2, #5
 800679a:	fbb4 f1f2 	udiv	r1, r4, r2
 800679e:	fb02 4211 	mls	r2, r2, r1, r4
 80067a2:	b9da      	cbnz	r2, 80067dc <dir_next+0x78>
		dp->sect++;					/* Next sector */
 80067a4:	3301      	adds	r3, #1
 80067a6:	f241 0210 	movw	r2, #4112	; 0x1010
 80067aa:	50ab      	str	r3, [r5, r2]
		if (!dp->clust) {		/* Static table */
 80067ac:	f241 030c 	movw	r3, #4108	; 0x100c
 80067b0:	58e9      	ldr	r1, [r5, r3]
 80067b2:	b939      	cbnz	r1, 80067c4 <dir_next+0x60>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 80067b4:	f241 0308 	movw	r3, #4104	; 0x1008
 80067b8:	5ac3      	ldrh	r3, [r0, r3]
 80067ba:	429c      	cmp	r4, r3
 80067bc:	d30e      	bcc.n	80067dc <dir_next+0x78>
				return FR_NO_FILE;
 80067be:	2004      	movs	r0, #4
 80067c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 80067c4:	f241 030a 	movw	r3, #4106	; 0x100a
 80067c8:	5ac3      	ldrh	r3, [r0, r3]
 80067ca:	095b      	lsrs	r3, r3, #5
 80067cc:	fbb4 f3f3 	udiv	r3, r4, r3
 80067d0:	f241 0202 	movw	r2, #4098	; 0x1002
 80067d4:	5c87      	ldrb	r7, [r0, r2]
 80067d6:	3f01      	subs	r7, #1
 80067d8:	401f      	ands	r7, r3
 80067da:	d015      	beq.n	8006808 <dir_next+0xa4>
	dp->index = (WORD)i;	/* Current index */
 80067dc:	f241 0306 	movw	r3, #4102	; 0x1006
 80067e0:	52ec      	strh	r4, [r5, r3]
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 80067e2:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80067e6:	681b      	ldr	r3, [r3, #0]
 80067e8:	f241 020a 	movw	r2, #4106	; 0x100a
 80067ec:	5a9a      	ldrh	r2, [r3, r2]
 80067ee:	0952      	lsrs	r2, r2, #5
 80067f0:	fbb4 f1f2 	udiv	r1, r4, r2
 80067f4:	fb02 4411 	mls	r4, r2, r1, r4
 80067f8:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 80067fc:	f241 0214 	movw	r2, #4116	; 0x1014
 8006800:	50ab      	str	r3, [r5, r2]
	return FR_OK;
 8006802:	2000      	movs	r0, #0
 8006804:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8006808:	f7ff fd6c 	bl	80062e4 <get_fat>
 800680c:	4680      	mov	r8, r0
				if (clst <= 1) return FR_INT_ERR;
 800680e:	2801      	cmp	r0, #1
 8006810:	d964      	bls.n	80068dc <dir_next+0x178>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8006812:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006816:	d064      	beq.n	80068e2 <dir_next+0x17e>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8006818:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 800681c:	6818      	ldr	r0, [r3, #0]
 800681e:	f241 0314 	movw	r3, #4116	; 0x1014
 8006822:	58c3      	ldr	r3, [r0, r3]
 8006824:	4598      	cmp	r8, r3
 8006826:	d34b      	bcc.n	80068c0 <dir_next+0x15c>
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8006828:	b916      	cbnz	r6, 8006830 <dir_next+0xcc>
 800682a:	2004      	movs	r0, #4
 800682c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 8006830:	f241 030c 	movw	r3, #4108	; 0x100c
 8006834:	58e9      	ldr	r1, [r5, r3]
 8006836:	f7ff ff27 	bl	8006688 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800683a:	4680      	mov	r8, r0
 800683c:	b910      	cbnz	r0, 8006844 <dir_next+0xe0>
 800683e:	2007      	movs	r0, #7
 8006840:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if (clst == 1) return FR_INT_ERR;
 8006844:	2801      	cmp	r0, #1
 8006846:	d04f      	beq.n	80068e8 <dir_next+0x184>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8006848:	f1b0 3fff 	cmp.w	r0, #4294967295
 800684c:	d04f      	beq.n	80068ee <dir_next+0x18a>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 800684e:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 8006852:	6818      	ldr	r0, [r3, #0]
 8006854:	f7ff f820 	bl	8005898 <sync_window>
 8006858:	2800      	cmp	r0, #0
 800685a:	d14b      	bne.n	80068f4 <dir_next+0x190>
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
 800685c:	f505 5680 	add.w	r6, r5, #4096	; 0x1000
 8006860:	6830      	ldr	r0, [r6, #0]
 8006862:	f241 030a 	movw	r3, #4106	; 0x100a
 8006866:	5ac2      	ldrh	r2, [r0, r3]
 8006868:	2100      	movs	r1, #0
 800686a:	f7fe fdc1 	bl	80053f0 <mem_set>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 800686e:	6836      	ldr	r6, [r6, #0]
 8006870:	4641      	mov	r1, r8
 8006872:	4630      	mov	r0, r6
 8006874:	f7ff fd24 	bl	80062c0 <clust2sect>
 8006878:	f241 032c 	movw	r3, #4140	; 0x102c
 800687c:	50f0      	str	r0, [r6, r3]
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 800687e:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 8006882:	681b      	ldr	r3, [r3, #0]
 8006884:	f241 0202 	movw	r2, #4098	; 0x1002
 8006888:	5c9a      	ldrb	r2, [r3, r2]
 800688a:	4297      	cmp	r7, r2
 800688c:	d213      	bcs.n	80068b6 <dir_next+0x152>
						dp->fs->wflag = 1;
 800688e:	2101      	movs	r1, #1
 8006890:	f241 0204 	movw	r2, #4100	; 0x1004
 8006894:	5499      	strb	r1, [r3, r2]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 8006896:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 800689a:	6818      	ldr	r0, [r3, #0]
 800689c:	f7fe fffc 	bl	8005898 <sync_window>
 80068a0:	bb58      	cbnz	r0, 80068fa <dir_next+0x196>
						dp->fs->winsect++;
 80068a2:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80068a6:	6819      	ldr	r1, [r3, #0]
 80068a8:	f241 022c 	movw	r2, #4140	; 0x102c
 80068ac:	588b      	ldr	r3, [r1, r2]
 80068ae:	3301      	adds	r3, #1
 80068b0:	508b      	str	r3, [r1, r2]
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80068b2:	3701      	adds	r7, #1
 80068b4:	e7e3      	b.n	800687e <dir_next+0x11a>
					dp->fs->winsect -= c;						/* Rewind window offset */
 80068b6:	f241 012c 	movw	r1, #4140	; 0x102c
 80068ba:	585a      	ldr	r2, [r3, r1]
 80068bc:	1bd2      	subs	r2, r2, r7
 80068be:	505a      	str	r2, [r3, r1]
				dp->clust = clst;				/* Initialize data for new cluster */
 80068c0:	f241 030c 	movw	r3, #4108	; 0x100c
 80068c4:	f845 8003 	str.w	r8, [r5, r3]
				dp->sect = clust2sect(dp->fs, clst);
 80068c8:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 80068cc:	4641      	mov	r1, r8
 80068ce:	6818      	ldr	r0, [r3, #0]
 80068d0:	f7ff fcf6 	bl	80062c0 <clust2sect>
 80068d4:	f241 0310 	movw	r3, #4112	; 0x1010
 80068d8:	50e8      	str	r0, [r5, r3]
 80068da:	e77f      	b.n	80067dc <dir_next+0x78>
				if (clst <= 1) return FR_INT_ERR;
 80068dc:	2002      	movs	r0, #2
 80068de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 80068e2:	2001      	movs	r0, #1
 80068e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if (clst == 1) return FR_INT_ERR;
 80068e8:	2002      	movs	r0, #2
 80068ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 80068ee:	2001      	movs	r0, #1
 80068f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 80068f4:	2001      	movs	r0, #1
 80068f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80068fa:	2001      	movs	r0, #1
}
 80068fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006900 <dir_find>:
{
 8006900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006904:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8006906:	2100      	movs	r1, #0
 8006908:	f7ff fd84 	bl	8006414 <dir_sdi>
	if (res != FR_OK) return res;
 800690c:	4680      	mov	r8, r0
 800690e:	2800      	cmp	r0, #0
 8006910:	d170      	bne.n	80069f4 <dir_find+0xf4>
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8006912:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006916:	f241 0324 	movw	r3, #4132	; 0x1024
 800691a:	52e2      	strh	r2, [r4, r3]
 800691c:	27ff      	movs	r7, #255	; 0xff
 800691e:	463e      	mov	r6, r7
 8006920:	e00c      	b.n	800693c <dir_find+0x3c>
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8006922:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006926:	f241 0324 	movw	r3, #4132	; 0x1024
 800692a:	52e2      	strh	r2, [r4, r3]
 800692c:	26ff      	movs	r6, #255	; 0xff
		res = dir_next(dp, 0);		/* Next entry */
 800692e:	2100      	movs	r1, #0
 8006930:	4620      	mov	r0, r4
 8006932:	f7ff ff17 	bl	8006764 <dir_next>
	} while (res == FR_OK);
 8006936:	4680      	mov	r8, r0
 8006938:	2800      	cmp	r0, #0
 800693a:	d15b      	bne.n	80069f4 <dir_find+0xf4>
		res = move_window(dp->fs, dp->sect);
 800693c:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8006940:	f241 0210 	movw	r2, #4112	; 0x1010
 8006944:	58a1      	ldr	r1, [r4, r2]
 8006946:	6818      	ldr	r0, [r3, #0]
 8006948:	f7fe ffe1 	bl	800590e <move_window>
		if (res != FR_OK) break;
 800694c:	4680      	mov	r8, r0
 800694e:	2800      	cmp	r0, #0
 8006950:	d150      	bne.n	80069f4 <dir_find+0xf4>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8006952:	f241 0314 	movw	r3, #4116	; 0x1014
 8006956:	58e5      	ldr	r5, [r4, r3]
		c = dir[DIR_Name];
 8006958:	782b      	ldrb	r3, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800695a:	2b00      	cmp	r3, #0
 800695c:	d048      	beq.n	80069f0 <dir_find+0xf0>
		a = dir[DIR_Attr] & AM_MASK;
 800695e:	7aea      	ldrb	r2, [r5, #11]
 8006960:	f002 013f 	and.w	r1, r2, #63	; 0x3f
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8006964:	2be5      	cmp	r3, #229	; 0xe5
 8006966:	d0dc      	beq.n	8006922 <dir_find+0x22>
 8006968:	f012 0f08 	tst.w	r2, #8
 800696c:	d001      	beq.n	8006972 <dir_find+0x72>
 800696e:	290f      	cmp	r1, #15
 8006970:	d1d7      	bne.n	8006922 <dir_find+0x22>
			if (a == AM_LFN) {			/* An LFN entry is found */
 8006972:	290f      	cmp	r1, #15
 8006974:	d018      	beq.n	80069a8 <dir_find+0xa8>
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8006976:	b926      	cbnz	r6, 8006982 <dir_find+0x82>
 8006978:	4628      	mov	r0, r5
 800697a:	f7fe ff56 	bl	800582a <sum_sfn>
 800697e:	4287      	cmp	r7, r0
 8006980:	d038      	beq.n	80069f4 <dir_find+0xf4>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
 8006982:	f241 0318 	movw	r3, #4120	; 0x1018
 8006986:	58e1      	ldr	r1, [r4, r3]
 8006988:	7acb      	ldrb	r3, [r1, #11]
 800698a:	f013 0f01 	tst.w	r3, #1
 800698e:	d104      	bne.n	800699a <dir_find+0x9a>
 8006990:	220b      	movs	r2, #11
 8006992:	4628      	mov	r0, r5
 8006994:	f7fe fd34 	bl	8005400 <mem_cmp>
 8006998:	b360      	cbz	r0, 80069f4 <dir_find+0xf4>
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 800699a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800699e:	f241 0324 	movw	r3, #4132	; 0x1024
 80069a2:	52e2      	strh	r2, [r4, r3]
 80069a4:	26ff      	movs	r6, #255	; 0xff
 80069a6:	e7c2      	b.n	800692e <dir_find+0x2e>
				if (dp->lfn) {
 80069a8:	f504 5281 	add.w	r2, r4, #4128	; 0x1020
 80069ac:	6810      	ldr	r0, [r2, #0]
 80069ae:	2800      	cmp	r0, #0
 80069b0:	d0bd      	beq.n	800692e <dir_find+0x2e>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 80069b2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80069b6:	d009      	beq.n	80069cc <dir_find+0xcc>
						sum = dir[LDIR_Chksum];
 80069b8:	7b6f      	ldrb	r7, [r5, #13]
						c &= ~LLEF; ord = c;	/* LFN start order */
 80069ba:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 80069be:	f241 0206 	movw	r2, #4102	; 0x1006
 80069c2:	5aa1      	ldrh	r1, [r4, r2]
 80069c4:	f241 0224 	movw	r2, #4132	; 0x1024
 80069c8:	52a1      	strh	r1, [r4, r2]
						c &= ~LLEF; ord = c;	/* LFN start order */
 80069ca:	461e      	mov	r6, r3
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 80069cc:	42b3      	cmp	r3, r6
 80069ce:	d001      	beq.n	80069d4 <dir_find+0xd4>
 80069d0:	26ff      	movs	r6, #255	; 0xff
 80069d2:	e7ac      	b.n	800692e <dir_find+0x2e>
 80069d4:	7b6b      	ldrb	r3, [r5, #13]
 80069d6:	429f      	cmp	r7, r3
 80069d8:	d001      	beq.n	80069de <dir_find+0xde>
 80069da:	26ff      	movs	r6, #255	; 0xff
 80069dc:	e7a7      	b.n	800692e <dir_find+0x2e>
 80069de:	4629      	mov	r1, r5
 80069e0:	f7ff fc22 	bl	8006228 <cmp_lfn>
 80069e4:	b110      	cbz	r0, 80069ec <dir_find+0xec>
 80069e6:	3e01      	subs	r6, #1
 80069e8:	b2f6      	uxtb	r6, r6
 80069ea:	e7a0      	b.n	800692e <dir_find+0x2e>
 80069ec:	26ff      	movs	r6, #255	; 0xff
 80069ee:	e79e      	b.n	800692e <dir_find+0x2e>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80069f0:	f04f 0804 	mov.w	r8, #4
}
 80069f4:	4640      	mov	r0, r8
 80069f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080069fa <follow_path>:
{
 80069fa:	b510      	push	{r4, lr}
 80069fc:	b082      	sub	sp, #8
 80069fe:	4604      	mov	r4, r0
 8006a00:	9101      	str	r1, [sp, #4]
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8006a02:	780b      	ldrb	r3, [r1, #0]
 8006a04:	2b2f      	cmp	r3, #47	; 0x2f
 8006a06:	d02b      	beq.n	8006a60 <follow_path+0x66>
 8006a08:	2b5c      	cmp	r3, #92	; 0x5c
 8006a0a:	d029      	beq.n	8006a60 <follow_path+0x66>
	dp->sclust = 0;							/* Always start from the root directory */
 8006a0c:	2200      	movs	r2, #0
 8006a0e:	f241 0308 	movw	r3, #4104	; 0x1008
 8006a12:	50e2      	str	r2, [r4, r3]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8006a14:	9b01      	ldr	r3, [sp, #4]
 8006a16:	781b      	ldrb	r3, [r3, #0]
 8006a18:	2b1f      	cmp	r3, #31
 8006a1a:	d924      	bls.n	8006a66 <follow_path+0x6c>
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8006a1c:	a901      	add	r1, sp, #4
 8006a1e:	4620      	mov	r0, r4
 8006a20:	f7ff fa74 	bl	8005f0c <create_name>
			if (res != FR_OK) break;
 8006a24:	4603      	mov	r3, r0
 8006a26:	bb38      	cbnz	r0, 8006a78 <follow_path+0x7e>
			res = dir_find(dp);				/* Find an object with the sagment name */
 8006a28:	4620      	mov	r0, r4
 8006a2a:	f7ff ff69 	bl	8006900 <dir_find>
			ns = dp->fn[NSFLAG];
 8006a2e:	f241 0318 	movw	r3, #4120	; 0x1018
 8006a32:	58e3      	ldr	r3, [r4, r3]
 8006a34:	7ada      	ldrb	r2, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8006a36:	4603      	mov	r3, r0
 8006a38:	bb08      	cbnz	r0, 8006a7e <follow_path+0x84>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8006a3a:	f012 0f04 	tst.w	r2, #4
 8006a3e:	d11b      	bne.n	8006a78 <follow_path+0x7e>
			dir = dp->dir;						/* Follow the sub-directory */
 8006a40:	f241 0314 	movw	r3, #4116	; 0x1014
 8006a44:	58e1      	ldr	r1, [r4, r3]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8006a46:	7acb      	ldrb	r3, [r1, #11]
 8006a48:	f013 0f10 	tst.w	r3, #16
 8006a4c:	d01e      	beq.n	8006a8c <follow_path+0x92>
			dp->sclust = ld_clust(dp->fs, dir);
 8006a4e:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8006a52:	6818      	ldr	r0, [r3, #0]
 8006a54:	f7fe fe0f 	bl	8005676 <ld_clust>
 8006a58:	f241 0308 	movw	r3, #4104	; 0x1008
 8006a5c:	50e0      	str	r0, [r4, r3]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8006a5e:	e7dd      	b.n	8006a1c <follow_path+0x22>
		path++;
 8006a60:	3101      	adds	r1, #1
 8006a62:	9101      	str	r1, [sp, #4]
 8006a64:	e7d2      	b.n	8006a0c <follow_path+0x12>
		res = dir_sdi(dp, 0);
 8006a66:	4611      	mov	r1, r2
 8006a68:	4620      	mov	r0, r4
 8006a6a:	f7ff fcd3 	bl	8006414 <dir_sdi>
 8006a6e:	4603      	mov	r3, r0
		dp->dir = 0;
 8006a70:	2100      	movs	r1, #0
 8006a72:	f241 0214 	movw	r2, #4116	; 0x1014
 8006a76:	50a1      	str	r1, [r4, r2]
}
 8006a78:	4618      	mov	r0, r3
 8006a7a:	b002      	add	sp, #8
 8006a7c:	bd10      	pop	{r4, pc}
				if (res == FR_NO_FILE) {	/* Object is not found */
 8006a7e:	2804      	cmp	r0, #4
 8006a80:	d1fa      	bne.n	8006a78 <follow_path+0x7e>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8006a82:	f012 0f04 	tst.w	r2, #4
 8006a86:	d1f7      	bne.n	8006a78 <follow_path+0x7e>
 8006a88:	2305      	movs	r3, #5
 8006a8a:	e7f5      	b.n	8006a78 <follow_path+0x7e>
				res = FR_NO_PATH; break;
 8006a8c:	2305      	movs	r3, #5
 8006a8e:	e7f3      	b.n	8006a78 <follow_path+0x7e>

08006a90 <dir_alloc>:
{
 8006a90:	b570      	push	{r4, r5, r6, lr}
 8006a92:	4604      	mov	r4, r0
 8006a94:	460e      	mov	r6, r1
	res = dir_sdi(dp, 0);
 8006a96:	2100      	movs	r1, #0
 8006a98:	f7ff fcbc 	bl	8006414 <dir_sdi>
	if (res == FR_OK) {
 8006a9c:	4602      	mov	r2, r0
 8006a9e:	b9f0      	cbnz	r0, 8006ade <dir_alloc+0x4e>
 8006aa0:	2500      	movs	r5, #0
 8006aa2:	e008      	b.n	8006ab6 <dir_alloc+0x26>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8006aa4:	3501      	adds	r5, #1
 8006aa6:	42b5      	cmp	r5, r6
 8006aa8:	d019      	beq.n	8006ade <dir_alloc+0x4e>
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 8006aaa:	2101      	movs	r1, #1
 8006aac:	4620      	mov	r0, r4
 8006aae:	f7ff fe59 	bl	8006764 <dir_next>
		} while (res == FR_OK);
 8006ab2:	4602      	mov	r2, r0
 8006ab4:	b998      	cbnz	r0, 8006ade <dir_alloc+0x4e>
			res = move_window(dp->fs, dp->sect);
 8006ab6:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8006aba:	f241 0210 	movw	r2, #4112	; 0x1010
 8006abe:	58a1      	ldr	r1, [r4, r2]
 8006ac0:	6818      	ldr	r0, [r3, #0]
 8006ac2:	f7fe ff24 	bl	800590e <move_window>
			if (res != FR_OK) break;
 8006ac6:	4602      	mov	r2, r0
 8006ac8:	b948      	cbnz	r0, 8006ade <dir_alloc+0x4e>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
 8006aca:	f241 0314 	movw	r3, #4116	; 0x1014
 8006ace:	58e3      	ldr	r3, [r4, r3]
 8006ad0:	781b      	ldrb	r3, [r3, #0]
 8006ad2:	2be5      	cmp	r3, #229	; 0xe5
 8006ad4:	d0e6      	beq.n	8006aa4 <dir_alloc+0x14>
 8006ad6:	2b00      	cmp	r3, #0
 8006ad8:	d0e4      	beq.n	8006aa4 <dir_alloc+0x14>
				n = 0;					/* Not a blank entry. Restart to search */
 8006ada:	2500      	movs	r5, #0
 8006adc:	e7e5      	b.n	8006aaa <dir_alloc+0x1a>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8006ade:	2a04      	cmp	r2, #4
 8006ae0:	d001      	beq.n	8006ae6 <dir_alloc+0x56>
}
 8006ae2:	4610      	mov	r0, r2
 8006ae4:	bd70      	pop	{r4, r5, r6, pc}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8006ae6:	2207      	movs	r2, #7
 8006ae8:	e7fb      	b.n	8006ae2 <dir_alloc+0x52>
	...

08006aec <dir_register>:
{
 8006aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006af0:	b084      	sub	sp, #16
 8006af2:	4605      	mov	r5, r0
	fn = dp->fn; lfn = dp->lfn;
 8006af4:	f241 0318 	movw	r3, #4120	; 0x1018
 8006af8:	f850 8003 	ldr.w	r8, [r0, r3]
 8006afc:	f500 5381 	add.w	r3, r0, #4128	; 0x1020
 8006b00:	681e      	ldr	r6, [r3, #0]
	mem_cpy(sn, fn, 12);
 8006b02:	220c      	movs	r2, #12
 8006b04:	4641      	mov	r1, r8
 8006b06:	a801      	add	r0, sp, #4
 8006b08:	f7fe fc68 	bl	80053dc <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8006b0c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006b10:	f013 0f01 	tst.w	r3, #1
 8006b14:	d021      	beq.n	8006b5a <dir_register+0x6e>
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 8006b16:	2300      	movs	r3, #0
 8006b18:	f888 300b 	strb.w	r3, [r8, #11]
 8006b1c:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
 8006b20:	6013      	str	r3, [r2, #0]
		for (n = 1; n < 100; n++) {
 8006b22:	2401      	movs	r4, #1
 8006b24:	2c63      	cmp	r4, #99	; 0x63
 8006b26:	d80c      	bhi.n	8006b42 <dir_register+0x56>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 8006b28:	4623      	mov	r3, r4
 8006b2a:	4632      	mov	r2, r6
 8006b2c:	a901      	add	r1, sp, #4
 8006b2e:	4640      	mov	r0, r8
 8006b30:	f7fe fe28 	bl	8005784 <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 8006b34:	4628      	mov	r0, r5
 8006b36:	f7ff fee3 	bl	8006900 <dir_find>
			if (res != FR_OK) break;
 8006b3a:	4607      	mov	r7, r0
 8006b3c:	b908      	cbnz	r0, 8006b42 <dir_register+0x56>
		for (n = 1; n < 100; n++) {
 8006b3e:	3401      	adds	r4, #1
 8006b40:	e7f0      	b.n	8006b24 <dir_register+0x38>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8006b42:	2c64      	cmp	r4, #100	; 0x64
 8006b44:	f000 8088 	beq.w	8006c58 <dir_register+0x16c>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8006b48:	2f04      	cmp	r7, #4
 8006b4a:	d116      	bne.n	8006b7a <dir_register+0x8e>
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
 8006b4c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006b50:	f888 300b 	strb.w	r3, [r8, #11]
 8006b54:	f505 5381 	add.w	r3, r5, #4128	; 0x1020
 8006b58:	601e      	str	r6, [r3, #0]
	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 8006b5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006b5e:	f013 0f02 	tst.w	r3, #2
 8006b62:	d11a      	bne.n	8006b9a <dir_register+0xae>
		nent = 1;
 8006b64:	2401      	movs	r4, #1
	res = dir_alloc(dp, nent);		/* Allocate entries */
 8006b66:	4621      	mov	r1, r4
 8006b68:	4628      	mov	r0, r5
 8006b6a:	f7ff ff91 	bl	8006a90 <dir_alloc>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 8006b6e:	4607      	mov	r7, r0
 8006b70:	b908      	cbnz	r0, 8006b76 <dir_register+0x8a>
 8006b72:	3c01      	subs	r4, #1
 8006b74:	d113      	bne.n	8006b9e <dir_register+0xb2>
	if (res == FR_OK) {				/* Set SFN entry */
 8006b76:	2f00      	cmp	r7, #0
 8006b78:	d047      	beq.n	8006c0a <dir_register+0x11e>
}
 8006b7a:	4638      	mov	r0, r7
 8006b7c:	b004      	add	sp, #16
 8006b7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (n = 0; lfn[n]; n++) ;
 8006b82:	3301      	adds	r3, #1
 8006b84:	f836 2013 	ldrh.w	r2, [r6, r3, lsl #1]
 8006b88:	2a00      	cmp	r2, #0
 8006b8a:	d1fa      	bne.n	8006b82 <dir_register+0x96>
		nent = (n + 25) / 13;
 8006b8c:	f103 0419 	add.w	r4, r3, #25
 8006b90:	4b32      	ldr	r3, [pc, #200]	; (8006c5c <dir_register+0x170>)
 8006b92:	fba3 3404 	umull	r3, r4, r3, r4
 8006b96:	08a4      	lsrs	r4, r4, #2
 8006b98:	e7e5      	b.n	8006b66 <dir_register+0x7a>
 8006b9a:	2300      	movs	r3, #0
 8006b9c:	e7f2      	b.n	8006b84 <dir_register+0x98>
		res = dir_sdi(dp, dp->index - nent);
 8006b9e:	f241 0306 	movw	r3, #4102	; 0x1006
 8006ba2:	5ae9      	ldrh	r1, [r5, r3]
 8006ba4:	1b09      	subs	r1, r1, r4
 8006ba6:	4628      	mov	r0, r5
 8006ba8:	f7ff fc34 	bl	8006414 <dir_sdi>
		if (res == FR_OK) {
 8006bac:	4607      	mov	r7, r0
 8006bae:	2800      	cmp	r0, #0
 8006bb0:	d1e1      	bne.n	8006b76 <dir_register+0x8a>
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 8006bb2:	f241 0318 	movw	r3, #4120	; 0x1018
 8006bb6:	58e8      	ldr	r0, [r5, r3]
 8006bb8:	f7fe fe37 	bl	800582a <sum_sfn>
 8006bbc:	4606      	mov	r6, r0
				res = move_window(dp->fs, dp->sect);
 8006bbe:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 8006bc2:	f241 0210 	movw	r2, #4112	; 0x1010
 8006bc6:	58a9      	ldr	r1, [r5, r2]
 8006bc8:	6818      	ldr	r0, [r3, #0]
 8006bca:	f7fe fea0 	bl	800590e <move_window>
				if (res != FR_OK) break;
 8006bce:	4607      	mov	r7, r0
 8006bd0:	2800      	cmp	r0, #0
 8006bd2:	d1d0      	bne.n	8006b76 <dir_register+0x8a>
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 8006bd4:	f505 5081 	add.w	r0, r5, #4128	; 0x1020
 8006bd8:	4633      	mov	r3, r6
 8006bda:	b2e2      	uxtb	r2, r4
 8006bdc:	f241 0114 	movw	r1, #4116	; 0x1014
 8006be0:	5869      	ldr	r1, [r5, r1]
 8006be2:	6800      	ldr	r0, [r0, #0]
 8006be4:	f7fe fd9c 	bl	8005720 <fit_lfn>
				dp->fs->wflag = 1;
 8006be8:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 8006bec:	681a      	ldr	r2, [r3, #0]
 8006bee:	2101      	movs	r1, #1
 8006bf0:	f241 0304 	movw	r3, #4100	; 0x1004
 8006bf4:	54d1      	strb	r1, [r2, r3]
				res = dir_next(dp, 0);	/* Next entry */
 8006bf6:	2100      	movs	r1, #0
 8006bf8:	4628      	mov	r0, r5
 8006bfa:	f7ff fdb3 	bl	8006764 <dir_next>
			} while (res == FR_OK && --nent);
 8006bfe:	4607      	mov	r7, r0
 8006c00:	2800      	cmp	r0, #0
 8006c02:	d1b8      	bne.n	8006b76 <dir_register+0x8a>
 8006c04:	3c01      	subs	r4, #1
 8006c06:	d1da      	bne.n	8006bbe <dir_register+0xd2>
 8006c08:	e7b5      	b.n	8006b76 <dir_register+0x8a>
		res = move_window(dp->fs, dp->sect);
 8006c0a:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 8006c0e:	f241 0210 	movw	r2, #4112	; 0x1010
 8006c12:	58a9      	ldr	r1, [r5, r2]
 8006c14:	6818      	ldr	r0, [r3, #0]
 8006c16:	f7fe fe7a 	bl	800590e <move_window>
		if (res == FR_OK) {
 8006c1a:	4607      	mov	r7, r0
 8006c1c:	2800      	cmp	r0, #0
 8006c1e:	d1ac      	bne.n	8006b7a <dir_register+0x8e>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
 8006c20:	f241 0414 	movw	r4, #4116	; 0x1014
 8006c24:	2220      	movs	r2, #32
 8006c26:	2100      	movs	r1, #0
 8006c28:	5928      	ldr	r0, [r5, r4]
 8006c2a:	f7fe fbe1 	bl	80053f0 <mem_set>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 8006c2e:	f241 0618 	movw	r6, #4120	; 0x1018
 8006c32:	220b      	movs	r2, #11
 8006c34:	59a9      	ldr	r1, [r5, r6]
 8006c36:	5928      	ldr	r0, [r5, r4]
 8006c38:	f7fe fbd0 	bl	80053dc <mem_cpy>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8006c3c:	592a      	ldr	r2, [r5, r4]
 8006c3e:	59ab      	ldr	r3, [r5, r6]
 8006c40:	7adb      	ldrb	r3, [r3, #11]
 8006c42:	f003 0318 	and.w	r3, r3, #24
 8006c46:	7313      	strb	r3, [r2, #12]
			dp->fs->wflag = 1;
 8006c48:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
 8006c4c:	682a      	ldr	r2, [r5, #0]
 8006c4e:	2101      	movs	r1, #1
 8006c50:	f241 0304 	movw	r3, #4100	; 0x1004
 8006c54:	54d1      	strb	r1, [r2, r3]
 8006c56:	e790      	b.n	8006b7a <dir_register+0x8e>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8006c58:	2707      	movs	r7, #7
 8006c5a:	e78e      	b.n	8006b7a <dir_register+0x8e>
 8006c5c:	4ec4ec4f 	.word	0x4ec4ec4f

08006c60 <dir_read>:
{
 8006c60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006c64:	4604      	mov	r4, r0
 8006c66:	460e      	mov	r6, r1
	BYTE ord = 0xFF, sum = 0xFF;
 8006c68:	27ff      	movs	r7, #255	; 0xff
 8006c6a:	463d      	mov	r5, r7
	res = FR_NO_FILE;
 8006c6c:	f04f 0804 	mov.w	r8, #4
	while (dp->sect) {
 8006c70:	e036      	b.n	8006ce0 <dir_read+0x80>
			if (a == AM_LFN) {			/* An LFN entry is found */
 8006c72:	2a0f      	cmp	r2, #15
 8006c74:	d11f      	bne.n	8006cb6 <dir_read+0x56>
				if (c & LLEF) {			/* Is it start of LFN sequence? */
 8006c76:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006c7a:	d009      	beq.n	8006c90 <dir_read+0x30>
					sum = dir[LDIR_Chksum];
 8006c7c:	7b4f      	ldrb	r7, [r1, #13]
					c &= ~LLEF; ord = c;
 8006c7e:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
					dp->lfn_idx = dp->index;
 8006c82:	f241 0206 	movw	r2, #4102	; 0x1006
 8006c86:	5aa0      	ldrh	r0, [r4, r2]
 8006c88:	f241 0224 	movw	r2, #4132	; 0x1024
 8006c8c:	52a0      	strh	r0, [r4, r2]
					c &= ~LLEF; ord = c;
 8006c8e:	461d      	mov	r5, r3
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8006c90:	42ab      	cmp	r3, r5
 8006c92:	d001      	beq.n	8006c98 <dir_read+0x38>
 8006c94:	25ff      	movs	r5, #255	; 0xff
 8006c96:	e01d      	b.n	8006cd4 <dir_read+0x74>
 8006c98:	7b4b      	ldrb	r3, [r1, #13]
 8006c9a:	429f      	cmp	r7, r3
 8006c9c:	d001      	beq.n	8006ca2 <dir_read+0x42>
 8006c9e:	25ff      	movs	r5, #255	; 0xff
 8006ca0:	e018      	b.n	8006cd4 <dir_read+0x74>
 8006ca2:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 8006ca6:	6818      	ldr	r0, [r3, #0]
 8006ca8:	f7fe fd00 	bl	80056ac <pick_lfn>
 8006cac:	2800      	cmp	r0, #0
 8006cae:	d038      	beq.n	8006d22 <dir_read+0xc2>
 8006cb0:	3d01      	subs	r5, #1
 8006cb2:	b2ed      	uxtb	r5, r5
 8006cb4:	e00e      	b.n	8006cd4 <dir_read+0x74>
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
 8006cb6:	b925      	cbnz	r5, 8006cc2 <dir_read+0x62>
 8006cb8:	4608      	mov	r0, r1
 8006cba:	f7fe fdb6 	bl	800582a <sum_sfn>
 8006cbe:	4287      	cmp	r7, r0
 8006cc0:	d033      	beq.n	8006d2a <dir_read+0xca>
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
 8006cc2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006cc6:	f241 0324 	movw	r3, #4132	; 0x1024
 8006cca:	52e2      	strh	r2, [r4, r3]
 8006ccc:	e02d      	b.n	8006d2a <dir_read+0xca>
			ord = 0xFF;
 8006cce:	25ff      	movs	r5, #255	; 0xff
 8006cd0:	e000      	b.n	8006cd4 <dir_read+0x74>
 8006cd2:	25ff      	movs	r5, #255	; 0xff
		res = dir_next(dp, 0);				/* Next entry */
 8006cd4:	2100      	movs	r1, #0
 8006cd6:	4620      	mov	r0, r4
 8006cd8:	f7ff fd44 	bl	8006764 <dir_next>
		if (res != FR_OK) break;
 8006cdc:	4680      	mov	r8, r0
 8006cde:	bb20      	cbnz	r0, 8006d2a <dir_read+0xca>
	while (dp->sect) {
 8006ce0:	f241 0310 	movw	r3, #4112	; 0x1010
 8006ce4:	58e1      	ldr	r1, [r4, r3]
 8006ce6:	b301      	cbz	r1, 8006d2a <dir_read+0xca>
		res = move_window(dp->fs, dp->sect);
 8006ce8:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8006cec:	6818      	ldr	r0, [r3, #0]
 8006cee:	f7fe fe0e 	bl	800590e <move_window>
		if (res != FR_OK) break;
 8006cf2:	4680      	mov	r8, r0
 8006cf4:	b9c8      	cbnz	r0, 8006d2a <dir_read+0xca>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8006cf6:	f241 0314 	movw	r3, #4116	; 0x1014
 8006cfa:	58e1      	ldr	r1, [r4, r3]
		c = dir[DIR_Name];
 8006cfc:	780b      	ldrb	r3, [r1, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8006cfe:	b193      	cbz	r3, 8006d26 <dir_read+0xc6>
		a = dir[DIR_Attr] & AM_MASK;
 8006d00:	7aca      	ldrb	r2, [r1, #11]
 8006d02:	f002 023f 	and.w	r2, r2, #63	; 0x3f
		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8006d06:	2be5      	cmp	r3, #229	; 0xe5
 8006d08:	d0e1      	beq.n	8006cce <dir_read+0x6e>
 8006d0a:	2b2e      	cmp	r3, #46	; 0x2e
 8006d0c:	d0e1      	beq.n	8006cd2 <dir_read+0x72>
 8006d0e:	f022 0020 	bic.w	r0, r2, #32
 8006d12:	2808      	cmp	r0, #8
 8006d14:	bf14      	ite	ne
 8006d16:	2000      	movne	r0, #0
 8006d18:	2001      	moveq	r0, #1
 8006d1a:	42b0      	cmp	r0, r6
 8006d1c:	d0a9      	beq.n	8006c72 <dir_read+0x12>
			ord = 0xFF;
 8006d1e:	25ff      	movs	r5, #255	; 0xff
 8006d20:	e7d8      	b.n	8006cd4 <dir_read+0x74>
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8006d22:	25ff      	movs	r5, #255	; 0xff
 8006d24:	e7d6      	b.n	8006cd4 <dir_read+0x74>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8006d26:	f04f 0804 	mov.w	r8, #4
	if (res != FR_OK) dp->sect = 0;
 8006d2a:	f1b8 0f00 	cmp.w	r8, #0
 8006d2e:	d003      	beq.n	8006d38 <dir_read+0xd8>
 8006d30:	2200      	movs	r2, #0
 8006d32:	f241 0310 	movw	r3, #4112	; 0x1010
 8006d36:	50e2      	str	r2, [r4, r3]
}
 8006d38:	4640      	mov	r0, r8
 8006d3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006d3e <remove_chain>:
{
 8006d3e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8006d40:	2901      	cmp	r1, #1
 8006d42:	d933      	bls.n	8006dac <remove_chain+0x6e>
 8006d44:	4604      	mov	r4, r0
 8006d46:	460d      	mov	r5, r1
 8006d48:	f241 0314 	movw	r3, #4116	; 0x1014
 8006d4c:	58c3      	ldr	r3, [r0, r3]
 8006d4e:	4299      	cmp	r1, r3
 8006d50:	d301      	bcc.n	8006d56 <remove_chain+0x18>
		res = FR_INT_ERR;
 8006d52:	2702      	movs	r7, #2
 8006d54:	e02b      	b.n	8006dae <remove_chain+0x70>
 8006d56:	2700      	movs	r7, #0
 8006d58:	e000      	b.n	8006d5c <remove_chain+0x1e>
 8006d5a:	4635      	mov	r5, r6
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8006d5c:	f241 0314 	movw	r3, #4116	; 0x1014
 8006d60:	58e3      	ldr	r3, [r4, r3]
 8006d62:	429d      	cmp	r5, r3
 8006d64:	d223      	bcs.n	8006dae <remove_chain+0x70>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 8006d66:	4629      	mov	r1, r5
 8006d68:	4620      	mov	r0, r4
 8006d6a:	f7ff fabb 	bl	80062e4 <get_fat>
			if (nxt == 0) break;				/* Empty cluster? */
 8006d6e:	4606      	mov	r6, r0
 8006d70:	b1e8      	cbz	r0, 8006dae <remove_chain+0x70>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8006d72:	2801      	cmp	r0, #1
 8006d74:	d01d      	beq.n	8006db2 <remove_chain+0x74>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8006d76:	f1b0 3fff 	cmp.w	r0, #4294967295
 8006d7a:	d01c      	beq.n	8006db6 <remove_chain+0x78>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 8006d7c:	2200      	movs	r2, #0
 8006d7e:	4629      	mov	r1, r5
 8006d80:	4620      	mov	r0, r4
 8006d82:	f7ff fbc1 	bl	8006508 <put_fat>
			if (res != FR_OK) break;
 8006d86:	4607      	mov	r7, r0
 8006d88:	b988      	cbnz	r0, 8006dae <remove_chain+0x70>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8006d8a:	f241 0310 	movw	r3, #4112	; 0x1010
 8006d8e:	58e3      	ldr	r3, [r4, r3]
 8006d90:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006d94:	d0e1      	beq.n	8006d5a <remove_chain+0x1c>
				fs->free_clust++;
 8006d96:	3301      	adds	r3, #1
 8006d98:	f241 0210 	movw	r2, #4112	; 0x1010
 8006d9c:	50a3      	str	r3, [r4, r2]
				fs->fsi_flag |= 1;
 8006d9e:	f241 0205 	movw	r2, #4101	; 0x1005
 8006da2:	5ca3      	ldrb	r3, [r4, r2]
 8006da4:	f043 0301 	orr.w	r3, r3, #1
 8006da8:	54a3      	strb	r3, [r4, r2]
 8006daa:	e7d6      	b.n	8006d5a <remove_chain+0x1c>
		res = FR_INT_ERR;
 8006dac:	2702      	movs	r7, #2
}
 8006dae:	4638      	mov	r0, r7
 8006db0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8006db2:	2702      	movs	r7, #2
 8006db4:	e7fb      	b.n	8006dae <remove_chain+0x70>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8006db6:	2701      	movs	r7, #1
 8006db8:	e7f9      	b.n	8006dae <remove_chain+0x70>
	...

08006dbc <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8006dbc:	b570      	push	{r4, r5, r6, lr}
 8006dbe:	b084      	sub	sp, #16
 8006dc0:	9001      	str	r0, [sp, #4]
 8006dc2:	9100      	str	r1, [sp, #0]
 8006dc4:	4616      	mov	r6, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 8006dc6:	a804      	add	r0, sp, #16
 8006dc8:	f840 1d04 	str.w	r1, [r0, #-4]!


	vol = get_ldnumber(&rp);
 8006dcc:	f7fe fd3b 	bl	8005846 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8006dd0:	1e05      	subs	r5, r0, #0
 8006dd2:	db1e      	blt.n	8006e12 <f_mount+0x56>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8006dd4:	4b11      	ldr	r3, [pc, #68]	; (8006e1c <f_mount+0x60>)
 8006dd6:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]

	if (cfs) {
 8006dda:	b134      	cbz	r4, 8006dea <f_mount+0x2e>
#if _FS_LOCK
		clear_lock(cfs);
 8006ddc:	4620      	mov	r0, r4
 8006dde:	f7fe fc15 	bl	800560c <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8006de2:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
 8006de6:	2300      	movs	r3, #0
 8006de8:	7023      	strb	r3, [r4, #0]
	}

	if (fs) {
 8006dea:	9b01      	ldr	r3, [sp, #4]
 8006dec:	b11b      	cbz	r3, 8006df6 <f_mount+0x3a>
		fs->fs_type = 0;				/* Clear new fs object */
 8006dee:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8006df2:	2100      	movs	r1, #0
 8006df4:	7011      	strb	r1, [r2, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8006df6:	4a09      	ldr	r2, [pc, #36]	; (8006e1c <f_mount+0x60>)
 8006df8:	f842 3025 	str.w	r3, [r2, r5, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8006dfc:	b163      	cbz	r3, 8006e18 <f_mount+0x5c>
 8006dfe:	2e01      	cmp	r6, #1
 8006e00:	d001      	beq.n	8006e06 <f_mount+0x4a>
 8006e02:	2000      	movs	r0, #0
 8006e04:	e006      	b.n	8006e14 <f_mount+0x58>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 8006e06:	2200      	movs	r2, #0
 8006e08:	4669      	mov	r1, sp
 8006e0a:	a801      	add	r0, sp, #4
 8006e0c:	f7fe fe14 	bl	8005a38 <find_volume>
	LEAVE_FF(fs, res);
 8006e10:	e000      	b.n	8006e14 <f_mount+0x58>
	if (vol < 0) return FR_INVALID_DRIVE;
 8006e12:	200b      	movs	r0, #11
}
 8006e14:	b004      	add	sp, #16
 8006e16:	bd70      	pop	{r4, r5, r6, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8006e18:	2000      	movs	r0, #0
 8006e1a:	e7fb      	b.n	8006e14 <f_mount+0x58>
 8006e1c:	2000020c 	.word	0x2000020c

08006e20 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8006e20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006e24:	f5ad 5d82 	sub.w	sp, sp, #4160	; 0x1040
 8006e28:	9101      	str	r1, [sp, #4]
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 8006e2a:	2800      	cmp	r0, #0
 8006e2c:	f000 8104 	beq.w	8007038 <f_open+0x218>
 8006e30:	4604      	mov	r4, r0
 8006e32:	4615      	mov	r5, r2
	fp->fs = 0;			/* Clear file object */
 8006e34:	f500 5380 	add.w	r3, r0, #4096	; 0x1000
 8006e38:	2200      	movs	r2, #0
 8006e3a:	601a      	str	r2, [r3, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 8006e3c:	f005 081f 	and.w	r8, r5, #31
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8006e40:	f005 021e 	and.w	r2, r5, #30
 8006e44:	ab08      	add	r3, sp, #32
 8006e46:	a901      	add	r1, sp, #4
 8006e48:	f603 70f8 	addw	r0, r3, #4088	; 0xff8
 8006e4c:	f7fe fdf4 	bl	8005a38 <find_volume>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 8006e50:	4606      	mov	r6, r0
 8006e52:	2800      	cmp	r0, #0
 8006e54:	f040 80f1 	bne.w	800703a <f_open+0x21a>
		INIT_BUF(dj);
 8006e58:	ab08      	add	r3, sp, #32
 8006e5a:	ae06      	add	r6, sp, #24
 8006e5c:	f1a3 0214 	sub.w	r2, r3, #20
 8006e60:	f241 0318 	movw	r3, #4120	; 0x1018
 8006e64:	50f2      	str	r2, [r6, r3]
 8006e66:	f506 5381 	add.w	r3, r6, #4128	; 0x1020
 8006e6a:	4a76      	ldr	r2, [pc, #472]	; (8007044 <f_open+0x224>)
 8006e6c:	601a      	str	r2, [r3, #0]
		res = follow_path(&dj, path);	/* Follow the file path */
 8006e6e:	9901      	ldr	r1, [sp, #4]
 8006e70:	4630      	mov	r0, r6
 8006e72:	f7ff fdc2 	bl	80069fa <follow_path>
		dir = dj.dir;
 8006e76:	f241 0314 	movw	r3, #4116	; 0x1014
 8006e7a:	58f7      	ldr	r7, [r6, r3]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 8006e7c:	4606      	mov	r6, r0
 8006e7e:	b950      	cbnz	r0, 8006e96 <f_open+0x76>
			if (!dir)	/* Default directory itself */
 8006e80:	2f00      	cmp	r7, #0
 8006e82:	d070      	beq.n	8006f66 <f_open+0x146>
				res = FR_INVALID_NAME;
#if _FS_LOCK
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8006e84:	f038 0301 	bics.w	r3, r8, #1
 8006e88:	bf14      	ite	ne
 8006e8a:	2101      	movne	r1, #1
 8006e8c:	2100      	moveq	r1, #0
 8006e8e:	a806      	add	r0, sp, #24
 8006e90:	f7fe fad0 	bl	8005434 <chk_lock>
 8006e94:	4606      	mov	r6, r0
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8006e96:	f015 0f1c 	tst.w	r5, #28
 8006e9a:	f000 80ba 	beq.w	8007012 <f_open+0x1f2>
			if (res != FR_OK) {					/* No file, create new */
 8006e9e:	2e00      	cmp	r6, #0
 8006ea0:	d06d      	beq.n	8006f7e <f_open+0x15e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8006ea2:	2e04      	cmp	r6, #4
 8006ea4:	d061      	beq.n	8006f6a <f_open+0x14a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 8006ea6:	f048 0808 	orr.w	r8, r8, #8
				dir = dj.dir;					/* New entry */
 8006eaa:	f241 0314 	movw	r3, #4116	; 0x1014
 8006eae:	aa06      	add	r2, sp, #24
 8006eb0:	58d7      	ldr	r7, [r2, r3]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8006eb2:	b916      	cbnz	r6, 8006eba <f_open+0x9a>
 8006eb4:	f018 0f08 	tst.w	r8, #8
 8006eb8:	d16c      	bne.n	8006f94 <f_open+0x174>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 8006eba:	b9ee      	cbnz	r6, 8006ef8 <f_open+0xd8>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 8006ebc:	f018 0f08 	tst.w	r8, #8
 8006ec0:	d001      	beq.n	8006ec6 <f_open+0xa6>
				mode |= FA__WRITTEN;
 8006ec2:	f048 0820 	orr.w	r8, r8, #32
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8006ec6:	a808      	add	r0, sp, #32
 8006ec8:	f8d0 2ff8 	ldr.w	r2, [r0, #4088]	; 0xff8
 8006ecc:	f241 032c 	movw	r3, #4140	; 0x102c
 8006ed0:	58d2      	ldr	r2, [r2, r3]
 8006ed2:	f241 031c 	movw	r3, #4124	; 0x101c
 8006ed6:	50e2      	str	r2, [r4, r3]
			fp->dir_ptr = dir;
 8006ed8:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 8006edc:	601f      	str	r7, [r3, #0]
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8006ede:	f038 0301 	bics.w	r3, r8, #1
 8006ee2:	bf14      	ite	ne
 8006ee4:	2101      	movne	r1, #1
 8006ee6:	2100      	moveq	r1, #0
 8006ee8:	a806      	add	r0, sp, #24
 8006eea:	f7fe fafd 	bl	80054e8 <inc_lock>
 8006eee:	f241 0328 	movw	r3, #4136	; 0x1028
 8006ef2:	50e0      	str	r0, [r4, r3]
			if (!fp->lockid) res = FR_INT_ERR;
 8006ef4:	b900      	cbnz	r0, 8006ef8 <f_open+0xd8>
 8006ef6:	2602      	movs	r6, #2
			}
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
 8006ef8:	2e00      	cmp	r6, #0
 8006efa:	f040 809e 	bne.w	800703a <f_open+0x21a>
			fp->flag = mode;					/* File access mode */
 8006efe:	f241 0906 	movw	r9, #4102	; 0x1006
 8006f02:	f804 8009 	strb.w	r8, [r4, r9]
			fp->err = 0;						/* Clear error flag */
 8006f06:	2500      	movs	r5, #0
 8006f08:	f241 0307 	movw	r3, #4103	; 0x1007
 8006f0c:	54e5      	strb	r5, [r4, r3]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8006f0e:	f50d 5380 	add.w	r3, sp, #4096	; 0x1000
 8006f12:	3318      	adds	r3, #24
 8006f14:	f8d3 8000 	ldr.w	r8, [r3]
 8006f18:	4639      	mov	r1, r7
 8006f1a:	4640      	mov	r0, r8
 8006f1c:	f7fe fbab 	bl	8005676 <ld_clust>
 8006f20:	f241 0310 	movw	r3, #4112	; 0x1010
 8006f24:	50e0      	str	r0, [r4, r3]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
 8006f26:	7ffa      	ldrb	r2, [r7, #31]
 8006f28:	7fbb      	ldrb	r3, [r7, #30]
 8006f2a:	041b      	lsls	r3, r3, #16
 8006f2c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8006f30:	7f7a      	ldrb	r2, [r7, #29]
 8006f32:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006f36:	7f3a      	ldrb	r2, [r7, #28]
 8006f38:	4313      	orrs	r3, r2
 8006f3a:	f241 020c 	movw	r2, #4108	; 0x100c
 8006f3e:	50a3      	str	r3, [r4, r2]
			fp->fptr = 0;						/* File pointer */
 8006f40:	f241 0308 	movw	r3, #4104	; 0x1008
 8006f44:	50e5      	str	r5, [r4, r3]
			fp->dsect = 0;
 8006f46:	f241 0318 	movw	r3, #4120	; 0x1018
 8006f4a:	50e5      	str	r5, [r4, r3]
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
 8006f4c:	f241 0324 	movw	r3, #4132	; 0x1024
 8006f50:	50e5      	str	r5, [r4, r3]
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 8006f52:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8006f56:	f8c3 8000 	str.w	r8, [r3]
			fp->id = fp->fs->id;
 8006f5a:	f838 2009 	ldrh.w	r2, [r8, r9]
 8006f5e:	f241 0304 	movw	r3, #4100	; 0x1004
 8006f62:	52e2      	strh	r2, [r4, r3]
 8006f64:	e069      	b.n	800703a <f_open+0x21a>
				res = FR_INVALID_NAME;
 8006f66:	2606      	movs	r6, #6
 8006f68:	e795      	b.n	8006e96 <f_open+0x76>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 8006f6a:	f7fe faab 	bl	80054c4 <enq_lock>
 8006f6e:	b908      	cbnz	r0, 8006f74 <f_open+0x154>
 8006f70:	2612      	movs	r6, #18
 8006f72:	e798      	b.n	8006ea6 <f_open+0x86>
 8006f74:	a806      	add	r0, sp, #24
 8006f76:	f7ff fdb9 	bl	8006aec <dir_register>
 8006f7a:	4606      	mov	r6, r0
 8006f7c:	e793      	b.n	8006ea6 <f_open+0x86>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8006f7e:	7afb      	ldrb	r3, [r7, #11]
 8006f80:	f013 0f11 	tst.w	r3, #17
 8006f84:	d104      	bne.n	8006f90 <f_open+0x170>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 8006f86:	f015 0f04 	tst.w	r5, #4
 8006f8a:	d092      	beq.n	8006eb2 <f_open+0x92>
						res = FR_EXIST;
 8006f8c:	2608      	movs	r6, #8
 8006f8e:	e790      	b.n	8006eb2 <f_open+0x92>
					res = FR_DENIED;
 8006f90:	2607      	movs	r6, #7
 8006f92:	e78e      	b.n	8006eb2 <f_open+0x92>
				dw = GET_FATTIME();				/* Created time */
 8006f94:	f000 fba2 	bl	80076dc <get_fattime>
				ST_DWORD(dir + DIR_CrtTime, dw);
 8006f98:	73b8      	strb	r0, [r7, #14]
 8006f9a:	f3c0 2307 	ubfx	r3, r0, #8, #8
 8006f9e:	73fb      	strb	r3, [r7, #15]
 8006fa0:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8006fa4:	743b      	strb	r3, [r7, #16]
 8006fa6:	0e00      	lsrs	r0, r0, #24
 8006fa8:	7478      	strb	r0, [r7, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8006faa:	2500      	movs	r5, #0
 8006fac:	72fd      	strb	r5, [r7, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
 8006fae:	773d      	strb	r5, [r7, #28]
 8006fb0:	777d      	strb	r5, [r7, #29]
 8006fb2:	77bd      	strb	r5, [r7, #30]
 8006fb4:	77fd      	strb	r5, [r7, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 8006fb6:	f10d 0920 	add.w	r9, sp, #32
 8006fba:	4639      	mov	r1, r7
 8006fbc:	f8d9 0ff8 	ldr.w	r0, [r9, #4088]	; 0xff8
 8006fc0:	f7fe fb59 	bl	8005676 <ld_clust>
 8006fc4:	4682      	mov	sl, r0
				st_clust(dir, 0);				/* cluster = 0 */
 8006fc6:	4629      	mov	r1, r5
 8006fc8:	4638      	mov	r0, r7
 8006fca:	f7fe fb66 	bl	800569a <st_clust>
				dj.fs->wflag = 1;
 8006fce:	f8d9 0ff8 	ldr.w	r0, [r9, #4088]	; 0xff8
 8006fd2:	2201      	movs	r2, #1
 8006fd4:	f241 0304 	movw	r3, #4100	; 0x1004
 8006fd8:	54c2      	strb	r2, [r0, r3]
				if (cl) {						/* Remove the cluster chain if exist */
 8006fda:	f1ba 0f00 	cmp.w	sl, #0
 8006fde:	f43f af6c 	beq.w	8006eba <f_open+0x9a>
					dw = dj.fs->winsect;
 8006fe2:	f241 032c 	movw	r3, #4140	; 0x102c
 8006fe6:	58c5      	ldr	r5, [r0, r3]
					res = remove_chain(dj.fs, cl);
 8006fe8:	4651      	mov	r1, sl
 8006fea:	f7ff fea8 	bl	8006d3e <remove_chain>
					if (res == FR_OK) {
 8006fee:	4606      	mov	r6, r0
 8006ff0:	2800      	cmp	r0, #0
 8006ff2:	f47f af62 	bne.w	8006eba <f_open+0x9a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8006ff6:	f50d 5380 	add.w	r3, sp, #4096	; 0x1000
 8006ffa:	3318      	adds	r3, #24
 8006ffc:	6818      	ldr	r0, [r3, #0]
 8006ffe:	f10a 33ff 	add.w	r3, sl, #4294967295
 8007002:	f241 020c 	movw	r2, #4108	; 0x100c
 8007006:	5083      	str	r3, [r0, r2]
						res = move_window(dj.fs, dw);
 8007008:	4629      	mov	r1, r5
 800700a:	f7fe fc80 	bl	800590e <move_window>
 800700e:	4606      	mov	r6, r0
 8007010:	e753      	b.n	8006eba <f_open+0x9a>
			if (res == FR_OK) {					/* Follow succeeded */
 8007012:	2e00      	cmp	r6, #0
 8007014:	f47f af51 	bne.w	8006eba <f_open+0x9a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 8007018:	7afb      	ldrb	r3, [r7, #11]
 800701a:	f013 0f10 	tst.w	r3, #16
 800701e:	d109      	bne.n	8007034 <f_open+0x214>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 8007020:	f015 0f02 	tst.w	r5, #2
 8007024:	f43f af49 	beq.w	8006eba <f_open+0x9a>
 8007028:	f013 0f01 	tst.w	r3, #1
 800702c:	f43f af45 	beq.w	8006eba <f_open+0x9a>
						res = FR_DENIED;
 8007030:	2607      	movs	r6, #7
 8007032:	e742      	b.n	8006eba <f_open+0x9a>
					res = FR_NO_FILE;
 8007034:	2604      	movs	r6, #4
 8007036:	e740      	b.n	8006eba <f_open+0x9a>
	if (!fp) return FR_INVALID_OBJECT;
 8007038:	2609      	movs	r6, #9
		}
	}

	LEAVE_FF(dj.fs, res);
}
 800703a:	4630      	mov	r0, r6
 800703c:	f50d 5d82 	add.w	sp, sp, #4160	; 0x1040
 8007040:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007044:	2000022c 	.word	0x2000022c

08007048 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
 8007048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800704c:	b083      	sub	sp, #12
 800704e:	4604      	mov	r4, r0
 8007050:	460f      	mov	r7, r1
 8007052:	4616      	mov	r6, r2
 8007054:	4698      	mov	r8, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 8007056:	2300      	movs	r3, #0
 8007058:	f8c8 3000 	str.w	r3, [r8]

	res = validate(fp);							/* Check validity */
 800705c:	f7fe fcc4 	bl	80059e8 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8007060:	9001      	str	r0, [sp, #4]
 8007062:	b968      	cbnz	r0, 8007080 <f_read+0x38>
	if (fp->err)								/* Check error */
 8007064:	f241 0307 	movw	r3, #4103	; 0x1007
 8007068:	5ce3      	ldrb	r3, [r4, r3]
 800706a:	2b00      	cmp	r3, #0
 800706c:	f040 812d 	bne.w	80072ca <f_read+0x282>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 8007070:	f241 0306 	movw	r3, #4102	; 0x1006
 8007074:	5ce3      	ldrb	r3, [r4, r3]
 8007076:	f013 0f01 	tst.w	r3, #1
 800707a:	d105      	bne.n	8007088 <f_read+0x40>
		LEAVE_FF(fp->fs, FR_DENIED);
 800707c:	2307      	movs	r3, #7
 800707e:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf.d8[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
 8007080:	9801      	ldr	r0, [sp, #4]
 8007082:	b003      	add	sp, #12
 8007084:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	remain = fp->fsize - fp->fptr;
 8007088:	f241 030c 	movw	r3, #4108	; 0x100c
 800708c:	58e3      	ldr	r3, [r4, r3]
 800708e:	f241 0208 	movw	r2, #4104	; 0x1008
 8007092:	58a2      	ldr	r2, [r4, r2]
 8007094:	1a9b      	subs	r3, r3, r2
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8007096:	42b3      	cmp	r3, r6
 8007098:	f080 8094 	bcs.w	80071c4 <f_read+0x17c>
 800709c:	461e      	mov	r6, r3
 800709e:	e091      	b.n	80071c4 <f_read+0x17c>
					if (fp->cltbl)
 80070a0:	f241 0324 	movw	r3, #4132	; 0x1024
 80070a4:	58e3      	ldr	r3, [r4, r3]
 80070a6:	b11b      	cbz	r3, 80070b0 <f_read+0x68>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 80070a8:	4620      	mov	r0, r4
 80070aa:	f7fe fac9 	bl	8005640 <clmt_clust>
 80070ae:	e0aa      	b.n	8007206 <f_read+0x1be>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 80070b0:	f241 0314 	movw	r3, #4116	; 0x1014
 80070b4:	58e1      	ldr	r1, [r4, r3]
 80070b6:	f7ff f915 	bl	80062e4 <get_fat>
 80070ba:	e0a4      	b.n	8007206 <f_read+0x1be>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 80070bc:	f04f 0902 	mov.w	r9, #2
 80070c0:	f241 0307 	movw	r3, #4103	; 0x1007
 80070c4:	f804 9003 	strb.w	r9, [r4, r3]
 80070c8:	f8cd 9004 	str.w	r9, [sp, #4]
 80070cc:	e7d8      	b.n	8007080 <f_read+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 80070ce:	f04f 0901 	mov.w	r9, #1
 80070d2:	f241 0307 	movw	r3, #4103	; 0x1007
 80070d6:	f804 9003 	strb.w	r9, [r4, r3]
 80070da:	f8cd 9004 	str.w	r9, [sp, #4]
 80070de:	e7cf      	b.n	8007080 <f_read+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 80070e0:	f04f 0902 	mov.w	r9, #2
 80070e4:	f241 0307 	movw	r3, #4103	; 0x1007
 80070e8:	f804 9003 	strb.w	r9, [r4, r3]
 80070ec:	f8cd 9004 	str.w	r9, [sp, #4]
 80070f0:	e7c6      	b.n	8007080 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
 80070f2:	f04f 0901 	mov.w	r9, #1
 80070f6:	f241 0307 	movw	r3, #4103	; 0x1007
 80070fa:	f804 9003 	strb.w	r9, [r4, r3]
 80070fe:	f8cd 9004 	str.w	r9, [sp, #4]
 8007102:	e7bd      	b.n	8007080 <f_read+0x38>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf.d8, SS(fp->fs));
 8007104:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8007108:	681a      	ldr	r2, [r3, #0]
 800710a:	f241 030a 	movw	r3, #4106	; 0x100a
 800710e:	5ad3      	ldrh	r3, [r2, r3]
 8007110:	461a      	mov	r2, r3
 8007112:	4621      	mov	r1, r4
 8007114:	fb03 7000 	mla	r0, r3, r0, r7
 8007118:	f7fe f960 	bl	80053dc <mem_cpy>
 800711c:	e0ba      	b.n	8007294 <f_read+0x24c>
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
 800711e:	f241 0318 	movw	r3, #4120	; 0x1018
 8007122:	58e2      	ldr	r2, [r4, r3]
 8007124:	4591      	cmp	r9, r2
 8007126:	d024      	beq.n	8007172 <f_read+0x12a>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 8007128:	f241 0306 	movw	r3, #4102	; 0x1006
 800712c:	5ce3      	ldrb	r3, [r4, r3]
 800712e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007132:	d010      	beq.n	8007156 <f_read+0x10e>
					if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 8007134:	2301      	movs	r3, #1
 8007136:	4621      	mov	r1, r4
 8007138:	f241 0001 	movw	r0, #4097	; 0x1001
 800713c:	f81b 0000 	ldrb.w	r0, [fp, r0]
 8007140:	f7fe f8b0 	bl	80052a4 <disk_write>
 8007144:	2800      	cmp	r0, #0
 8007146:	f040 80ae 	bne.w	80072a6 <f_read+0x25e>
					fp->flag &= ~FA__DIRTY;
 800714a:	f241 0206 	movw	r2, #4102	; 0x1006
 800714e:	5ca3      	ldrb	r3, [r4, r2]
 8007150:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007154:	54a3      	strb	r3, [r4, r2]
				if (disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)	/* Fill sector cache */
 8007156:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 800715a:	681d      	ldr	r5, [r3, #0]
 800715c:	2301      	movs	r3, #1
 800715e:	464a      	mov	r2, r9
 8007160:	4621      	mov	r1, r4
 8007162:	f241 0001 	movw	r0, #4097	; 0x1001
 8007166:	5c28      	ldrb	r0, [r5, r0]
 8007168:	f7fe f890 	bl	800528c <disk_read>
 800716c:	2800      	cmp	r0, #0
 800716e:	f040 80a3 	bne.w	80072b8 <f_read+0x270>
			fp->dsect = sect;
 8007172:	f241 0318 	movw	r3, #4120	; 0x1018
 8007176:	f844 9003 	str.w	r9, [r4, r3]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 800717a:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 800717e:	681a      	ldr	r2, [r3, #0]
 8007180:	f241 030a 	movw	r3, #4106	; 0x100a
 8007184:	f832 a003 	ldrh.w	sl, [r2, r3]
 8007188:	f241 0308 	movw	r3, #4104	; 0x1008
 800718c:	58e3      	ldr	r3, [r4, r3]
 800718e:	fbb3 f1fa 	udiv	r1, r3, sl
 8007192:	fb0a 3111 	mls	r1, sl, r1, r3
 8007196:	ebaa 0a01 	sub.w	sl, sl, r1
		if (rcnt > btr) rcnt = btr;
 800719a:	4556      	cmp	r6, sl
 800719c:	d200      	bcs.n	80071a0 <f_read+0x158>
 800719e:	46b2      	mov	sl, r6
		mem_cpy(rbuff, &fp->buf.d8[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 80071a0:	4652      	mov	r2, sl
 80071a2:	4421      	add	r1, r4
 80071a4:	4638      	mov	r0, r7
 80071a6:	f7fe f919 	bl	80053dc <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 80071aa:	4457      	add	r7, sl
 80071ac:	f241 0208 	movw	r2, #4104	; 0x1008
 80071b0:	58a3      	ldr	r3, [r4, r2]
 80071b2:	4453      	add	r3, sl
 80071b4:	50a3      	str	r3, [r4, r2]
 80071b6:	f8d8 3000 	ldr.w	r3, [r8]
 80071ba:	4453      	add	r3, sl
 80071bc:	f8c8 3000 	str.w	r3, [r8]
 80071c0:	eba6 060a 	sub.w	r6, r6, sl
	for ( ;  btr;								/* Repeat until all data read */
 80071c4:	2e00      	cmp	r6, #0
 80071c6:	f43f af5b 	beq.w	8007080 <f_read+0x38>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 80071ca:	f241 0308 	movw	r3, #4104	; 0x1008
 80071ce:	58e1      	ldr	r1, [r4, r3]
 80071d0:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 80071d4:	6818      	ldr	r0, [r3, #0]
 80071d6:	f241 030a 	movw	r3, #4106	; 0x100a
 80071da:	5ac5      	ldrh	r5, [r0, r3]
 80071dc:	fbb1 f3f5 	udiv	r3, r1, r5
 80071e0:	fb05 1313 	mls	r3, r5, r3, r1
 80071e4:	2b00      	cmp	r3, #0
 80071e6:	d1c8      	bne.n	800717a <f_read+0x132>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 80071e8:	fbb1 f5f5 	udiv	r5, r1, r5
 80071ec:	f241 0302 	movw	r3, #4098	; 0x1002
 80071f0:	5cc3      	ldrb	r3, [r0, r3]
 80071f2:	3b01      	subs	r3, #1
 80071f4:	b2db      	uxtb	r3, r3
			if (!csect) {						/* On the cluster boundary? */
 80071f6:	401d      	ands	r5, r3
 80071f8:	d10f      	bne.n	800721a <f_read+0x1d2>
				if (fp->fptr == 0) {			/* On the top of the file? */
 80071fa:	2900      	cmp	r1, #0
 80071fc:	f47f af50 	bne.w	80070a0 <f_read+0x58>
					clst = fp->sclust;			/* Follow from the origin */
 8007200:	f241 0310 	movw	r3, #4112	; 0x1010
 8007204:	58e0      	ldr	r0, [r4, r3]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 8007206:	2801      	cmp	r0, #1
 8007208:	f67f af58 	bls.w	80070bc <f_read+0x74>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800720c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007210:	f43f af5d 	beq.w	80070ce <f_read+0x86>
				fp->clust = clst;				/* Update current cluster */
 8007214:	f241 0314 	movw	r3, #4116	; 0x1014
 8007218:	50e0      	str	r0, [r4, r3]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 800721a:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 800721e:	f8d3 b000 	ldr.w	fp, [r3]
 8007222:	f241 0314 	movw	r3, #4116	; 0x1014
 8007226:	58e1      	ldr	r1, [r4, r3]
 8007228:	4658      	mov	r0, fp
 800722a:	f7ff f849 	bl	80062c0 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 800722e:	4681      	mov	r9, r0
 8007230:	2800      	cmp	r0, #0
 8007232:	f43f af55 	beq.w	80070e0 <f_read+0x98>
			sect += csect;
 8007236:	44a9      	add	r9, r5
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
 8007238:	f241 030a 	movw	r3, #4106	; 0x100a
 800723c:	f83b a003 	ldrh.w	sl, [fp, r3]
 8007240:	fbb6 fafa 	udiv	sl, r6, sl
			if (cc) {							/* Read maximum contiguous sectors directly */
 8007244:	f1ba 0f00 	cmp.w	sl, #0
 8007248:	f43f af69 	beq.w	800711e <f_read+0xd6>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800724c:	eb05 030a 	add.w	r3, r5, sl
 8007250:	f241 0202 	movw	r2, #4098	; 0x1002
 8007254:	f81b 2002 	ldrb.w	r2, [fp, r2]
 8007258:	4293      	cmp	r3, r2
 800725a:	d901      	bls.n	8007260 <f_read+0x218>
					cc = fp->fs->csize - csect;
 800725c:	eba2 0a05 	sub.w	sl, r2, r5
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
 8007260:	4653      	mov	r3, sl
 8007262:	464a      	mov	r2, r9
 8007264:	4639      	mov	r1, r7
 8007266:	f241 0001 	movw	r0, #4097	; 0x1001
 800726a:	f81b 0000 	ldrb.w	r0, [fp, r0]
 800726e:	f7fe f80d 	bl	800528c <disk_read>
 8007272:	2800      	cmp	r0, #0
 8007274:	f47f af3d 	bne.w	80070f2 <f_read+0xaa>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 8007278:	f241 0306 	movw	r3, #4102	; 0x1006
 800727c:	5ce3      	ldrb	r3, [r4, r3]
 800727e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007282:	d007      	beq.n	8007294 <f_read+0x24c>
 8007284:	f241 0318 	movw	r3, #4120	; 0x1018
 8007288:	58e0      	ldr	r0, [r4, r3]
 800728a:	eba0 0009 	sub.w	r0, r0, r9
 800728e:	4582      	cmp	sl, r0
 8007290:	f63f af38 	bhi.w	8007104 <f_read+0xbc>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 8007294:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 8007298:	681a      	ldr	r2, [r3, #0]
 800729a:	f241 030a 	movw	r3, #4106	; 0x100a
 800729e:	5ad3      	ldrh	r3, [r2, r3]
 80072a0:	fb03 fa0a 	mul.w	sl, r3, sl
				continue;
 80072a4:	e781      	b.n	80071aa <f_read+0x162>
						ABORT(fp->fs, FR_DISK_ERR);
 80072a6:	f04f 0901 	mov.w	r9, #1
 80072aa:	f241 0307 	movw	r3, #4103	; 0x1007
 80072ae:	f804 9003 	strb.w	r9, [r4, r3]
 80072b2:	f8cd 9004 	str.w	r9, [sp, #4]
 80072b6:	e6e3      	b.n	8007080 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
 80072b8:	f04f 0901 	mov.w	r9, #1
 80072bc:	f241 0307 	movw	r3, #4103	; 0x1007
 80072c0:	f804 9003 	strb.w	r9, [r4, r3]
 80072c4:	f8cd 9004 	str.w	r9, [sp, #4]
 80072c8:	e6da      	b.n	8007080 <f_read+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
 80072ca:	9301      	str	r3, [sp, #4]
 80072cc:	e6d8      	b.n	8007080 <f_read+0x38>

080072ce <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80072ce:	b538      	push	{r3, r4, r5, lr}
 80072d0:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 80072d2:	f7fe fb89 	bl	80059e8 <validate>
	if (res == FR_OK) {
 80072d6:	4603      	mov	r3, r0
 80072d8:	bb38      	cbnz	r0, 800732a <f_sync+0x5c>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80072da:	f241 0206 	movw	r2, #4102	; 0x1006
 80072de:	5ca2      	ldrb	r2, [r4, r2]
 80072e0:	f012 0f20 	tst.w	r2, #32
 80072e4:	d021      	beq.n	800732a <f_sync+0x5c>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 80072e6:	f012 0f40 	tst.w	r2, #64	; 0x40
 80072ea:	d014      	beq.n	8007316 <f_sync+0x48>
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 80072ec:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 80072f0:	681d      	ldr	r5, [r3, #0]
 80072f2:	2301      	movs	r3, #1
 80072f4:	f241 0218 	movw	r2, #4120	; 0x1018
 80072f8:	58a2      	ldr	r2, [r4, r2]
 80072fa:	4621      	mov	r1, r4
 80072fc:	f241 0001 	movw	r0, #4097	; 0x1001
 8007300:	5c28      	ldrb	r0, [r5, r0]
 8007302:	f7fd ffcf 	bl	80052a4 <disk_write>
 8007306:	2800      	cmp	r0, #0
 8007308:	d14c      	bne.n	80073a4 <f_sync+0xd6>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800730a:	f241 0206 	movw	r2, #4102	; 0x1006
 800730e:	5ca3      	ldrb	r3, [r4, r2]
 8007310:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007314:	54a3      	strb	r3, [r4, r2]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 8007316:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 800731a:	f241 021c 	movw	r2, #4124	; 0x101c
 800731e:	58a1      	ldr	r1, [r4, r2]
 8007320:	6818      	ldr	r0, [r3, #0]
 8007322:	f7fe faf4 	bl	800590e <move_window>
			if (res == FR_OK) {
 8007326:	4603      	mov	r3, r0
 8007328:	b108      	cbz	r0, 800732e <f_sync+0x60>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 800732a:	4618      	mov	r0, r3
 800732c:	bd38      	pop	{r3, r4, r5, pc}
				dir = fp->dir_ptr;
 800732e:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 8007332:	681d      	ldr	r5, [r3, #0]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 8007334:	7aeb      	ldrb	r3, [r5, #11]
 8007336:	f043 0320 	orr.w	r3, r3, #32
 800733a:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
 800733c:	f241 030c 	movw	r3, #4108	; 0x100c
 8007340:	5ce2      	ldrb	r2, [r4, r3]
 8007342:	772a      	strb	r2, [r5, #28]
 8007344:	5ae2      	ldrh	r2, [r4, r3]
 8007346:	0a12      	lsrs	r2, r2, #8
 8007348:	776a      	strb	r2, [r5, #29]
 800734a:	58e2      	ldr	r2, [r4, r3]
 800734c:	f3c2 4207 	ubfx	r2, r2, #16, #8
 8007350:	77aa      	strb	r2, [r5, #30]
 8007352:	58e3      	ldr	r3, [r4, r3]
 8007354:	0e1b      	lsrs	r3, r3, #24
 8007356:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8007358:	f241 0310 	movw	r3, #4112	; 0x1010
 800735c:	58e1      	ldr	r1, [r4, r3]
 800735e:	4628      	mov	r0, r5
 8007360:	f7fe f99b 	bl	800569a <st_clust>
				tm = GET_FATTIME();							/* Update updated time */
 8007364:	f000 f9ba 	bl	80076dc <get_fattime>
				ST_DWORD(dir + DIR_WrtTime, tm);
 8007368:	75a8      	strb	r0, [r5, #22]
 800736a:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800736e:	75eb      	strb	r3, [r5, #23]
 8007370:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8007374:	762b      	strb	r3, [r5, #24]
 8007376:	0e00      	lsrs	r0, r0, #24
 8007378:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
 800737a:	2300      	movs	r3, #0
 800737c:	74ab      	strb	r3, [r5, #18]
 800737e:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 8007380:	f241 0206 	movw	r2, #4102	; 0x1006
 8007384:	5ca3      	ldrb	r3, [r4, r2]
 8007386:	f023 0320 	bic.w	r3, r3, #32
 800738a:	54a3      	strb	r3, [r4, r2]
				fp->fs->wflag = 1;
 800738c:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
 8007390:	6822      	ldr	r2, [r4, #0]
 8007392:	2101      	movs	r1, #1
 8007394:	f241 0304 	movw	r3, #4100	; 0x1004
 8007398:	54d1      	strb	r1, [r2, r3]
				res = sync_fs(fp->fs);
 800739a:	6820      	ldr	r0, [r4, #0]
 800739c:	f7fe fd4a 	bl	8005e34 <sync_fs>
 80073a0:	4603      	mov	r3, r0
 80073a2:	e7c2      	b.n	800732a <f_sync+0x5c>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 80073a4:	2301      	movs	r3, #1
 80073a6:	e7c0      	b.n	800732a <f_sync+0x5c>

080073a8 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 80073a8:	b510      	push	{r4, lr}
 80073aa:	4604      	mov	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 80073ac:	f7ff ff8f 	bl	80072ce <f_sync>
	if (res == FR_OK)
 80073b0:	4603      	mov	r3, r0
 80073b2:	b108      	cbz	r0, 80073b8 <f_close+0x10>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80073b4:	4618      	mov	r0, r3
 80073b6:	bd10      	pop	{r4, pc}
		res = validate(fp);				/* Lock volume */
 80073b8:	4620      	mov	r0, r4
 80073ba:	f7fe fb15 	bl	80059e8 <validate>
		if (res == FR_OK) {
 80073be:	4603      	mov	r3, r0
 80073c0:	2800      	cmp	r0, #0
 80073c2:	d1f7      	bne.n	80073b4 <f_close+0xc>
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
 80073c4:	f241 0328 	movw	r3, #4136	; 0x1028
 80073c8:	58e0      	ldr	r0, [r4, r3]
 80073ca:	f7fe f8fd 	bl	80055c8 <dec_lock>
			if (res == FR_OK)
 80073ce:	4603      	mov	r3, r0
 80073d0:	2800      	cmp	r0, #0
 80073d2:	d1ef      	bne.n	80073b4 <f_close+0xc>
				fp->fs = 0;				/* Invalidate file object */
 80073d4:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
 80073d8:	2200      	movs	r2, #0
 80073da:	6022      	str	r2, [r4, #0]
 80073dc:	e7ea      	b.n	80073b4 <f_close+0xc>
	...

080073e0 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80073e0:	b530      	push	{r4, r5, lr}
 80073e2:	b087      	sub	sp, #28
 80073e4:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
 80073e6:	2800      	cmp	r0, #0
 80073e8:	d057      	beq.n	800749a <f_opendir+0xba>
 80073ea:	4604      	mov	r4, r0

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
 80073ec:	2200      	movs	r2, #0
 80073ee:	a901      	add	r1, sp, #4
 80073f0:	a805      	add	r0, sp, #20
 80073f2:	f7fe fb21 	bl	8005a38 <find_volume>
	if (res == FR_OK) {
 80073f6:	4605      	mov	r5, r0
 80073f8:	b130      	cbz	r0, 8007408 <f_opendir+0x28>
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
 80073fa:	2d00      	cmp	r5, #0
 80073fc:	d04e      	beq.n	800749c <f_opendir+0xbc>
 80073fe:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
 8007402:	2300      	movs	r3, #0
 8007404:	6023      	str	r3, [r4, #0]
 8007406:	e049      	b.n	800749c <f_opendir+0xbc>
		dp->fs = fs;
 8007408:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 800740c:	9a05      	ldr	r2, [sp, #20]
 800740e:	601a      	str	r2, [r3, #0]
		INIT_BUF(*dp);
 8007410:	aa02      	add	r2, sp, #8
 8007412:	f241 0318 	movw	r3, #4120	; 0x1018
 8007416:	50e2      	str	r2, [r4, r3]
 8007418:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 800741c:	4a21      	ldr	r2, [pc, #132]	; (80074a4 <f_opendir+0xc4>)
 800741e:	601a      	str	r2, [r3, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8007420:	9901      	ldr	r1, [sp, #4]
 8007422:	4620      	mov	r0, r4
 8007424:	f7ff fae9 	bl	80069fa <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8007428:	4605      	mov	r5, r0
 800742a:	b980      	cbnz	r0, 800744e <f_opendir+0x6e>
			if (dp->dir) {						/* It is not the origin directory itself */
 800742c:	f241 0314 	movw	r3, #4116	; 0x1014
 8007430:	58e1      	ldr	r1, [r4, r3]
 8007432:	b159      	cbz	r1, 800744c <f_opendir+0x6c>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
 8007434:	7acb      	ldrb	r3, [r1, #11]
 8007436:	f013 0f10 	tst.w	r3, #16
 800743a:	d006      	beq.n	800744a <f_opendir+0x6a>
					dp->sclust = ld_clust(fs, dp->dir);
 800743c:	9805      	ldr	r0, [sp, #20]
 800743e:	f7fe f91a 	bl	8005676 <ld_clust>
 8007442:	f241 0308 	movw	r3, #4104	; 0x1008
 8007446:	50e0      	str	r0, [r4, r3]
 8007448:	e000      	b.n	800744c <f_opendir+0x6c>
					res = FR_NO_PATH;
 800744a:	2505      	movs	r5, #5
			if (res == FR_OK) {
 800744c:	b11d      	cbz	r5, 8007456 <f_opendir+0x76>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800744e:	2d04      	cmp	r5, #4
 8007450:	d1d3      	bne.n	80073fa <f_opendir+0x1a>
 8007452:	2505      	movs	r5, #5
 8007454:	e7d1      	b.n	80073fa <f_opendir+0x1a>
				dp->id = fs->id;
 8007456:	f241 0306 	movw	r3, #4102	; 0x1006
 800745a:	9a05      	ldr	r2, [sp, #20]
 800745c:	5ad2      	ldrh	r2, [r2, r3]
 800745e:	f241 0304 	movw	r3, #4100	; 0x1004
 8007462:	52e2      	strh	r2, [r4, r3]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8007464:	2100      	movs	r1, #0
 8007466:	4620      	mov	r0, r4
 8007468:	f7fe ffd4 	bl	8006414 <dir_sdi>
				if (res == FR_OK) {
 800746c:	4605      	mov	r5, r0
 800746e:	2800      	cmp	r0, #0
 8007470:	d1ed      	bne.n	800744e <f_opendir+0x6e>
					if (dp->sclust) {
 8007472:	f241 0308 	movw	r3, #4104	; 0x1008
 8007476:	58e3      	ldr	r3, [r4, r3]
 8007478:	b923      	cbnz	r3, 8007484 <f_opendir+0xa4>
						dp->lockid = 0;	/* Root directory need not to be locked */
 800747a:	2200      	movs	r2, #0
 800747c:	f241 031c 	movw	r3, #4124	; 0x101c
 8007480:	50e2      	str	r2, [r4, r3]
 8007482:	e7e4      	b.n	800744e <f_opendir+0x6e>
						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 8007484:	2100      	movs	r1, #0
 8007486:	4620      	mov	r0, r4
 8007488:	f7fe f82e 	bl	80054e8 <inc_lock>
 800748c:	f241 031c 	movw	r3, #4124	; 0x101c
 8007490:	50e0      	str	r0, [r4, r3]
						if (!dp->lockid)
 8007492:	2800      	cmp	r0, #0
 8007494:	d1db      	bne.n	800744e <f_opendir+0x6e>
							res = FR_TOO_MANY_OPEN_FILES;
 8007496:	2512      	movs	r5, #18
 8007498:	e7d9      	b.n	800744e <f_opendir+0x6e>
	if (!dp) return FR_INVALID_OBJECT;
 800749a:	2509      	movs	r5, #9

	LEAVE_FF(fs, res);
}
 800749c:	4628      	mov	r0, r5
 800749e:	b007      	add	sp, #28
 80074a0:	bd30      	pop	{r4, r5, pc}
 80074a2:	bf00      	nop
 80074a4:	2000022c 	.word	0x2000022c

080074a8 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 80074a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80074aa:	b085      	sub	sp, #20
 80074ac:	4604      	mov	r4, r0
 80074ae:	460f      	mov	r7, r1
	FRESULT res;
	DEFINE_NAMEBUF;


	res = validate(dp);						/* Check validity of the object */
 80074b0:	f7fe fa9a 	bl	80059e8 <validate>
	if (res == FR_OK) {
 80074b4:	4605      	mov	r5, r0
 80074b6:	b988      	cbnz	r0, 80074dc <f_readdir+0x34>
		if (!fno) {
 80074b8:	b19f      	cbz	r7, 80074e2 <f_readdir+0x3a>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dp);
 80074ba:	aa01      	add	r2, sp, #4
 80074bc:	f241 0318 	movw	r3, #4120	; 0x1018
 80074c0:	50e2      	str	r2, [r4, r3]
 80074c2:	f504 5381 	add.w	r3, r4, #4128	; 0x1020
 80074c6:	4a15      	ldr	r2, [pc, #84]	; (800751c <f_readdir+0x74>)
 80074c8:	601a      	str	r2, [r3, #0]
			res = dir_read(dp, 0);			/* Read an item */
 80074ca:	2100      	movs	r1, #0
 80074cc:	4620      	mov	r0, r4
 80074ce:	f7ff fbc7 	bl	8006c60 <dir_read>
 80074d2:	4606      	mov	r6, r0
			if (res == FR_NO_FILE) {		/* Reached end of directory */
 80074d4:	2804      	cmp	r0, #4
 80074d6:	d00a      	beq.n	80074ee <f_readdir+0x46>
				dp->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
 80074d8:	b17e      	cbz	r6, 80074fa <f_readdir+0x52>
 80074da:	4635      	mov	r5, r6
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
 80074dc:	4628      	mov	r0, r5
 80074de:	b005      	add	sp, #20
 80074e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80074e2:	2100      	movs	r1, #0
 80074e4:	4620      	mov	r0, r4
 80074e6:	f7fe ff95 	bl	8006414 <dir_sdi>
 80074ea:	4605      	mov	r5, r0
 80074ec:	e7f6      	b.n	80074dc <f_readdir+0x34>
				dp->sect = 0;
 80074ee:	2200      	movs	r2, #0
 80074f0:	f241 0310 	movw	r3, #4112	; 0x1010
 80074f4:	50e2      	str	r2, [r4, r3]
				res = FR_OK;
 80074f6:	462e      	mov	r6, r5
 80074f8:	e7ee      	b.n	80074d8 <f_readdir+0x30>
				get_fileinfo(dp, fno);		/* Get the object information */
 80074fa:	4639      	mov	r1, r7
 80074fc:	4620      	mov	r0, r4
 80074fe:	f7fe fe1d 	bl	800613c <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 8007502:	2100      	movs	r1, #0
 8007504:	4620      	mov	r0, r4
 8007506:	f7ff f92d 	bl	8006764 <dir_next>
 800750a:	4605      	mov	r5, r0
				if (res == FR_NO_FILE) {
 800750c:	2804      	cmp	r0, #4
 800750e:	d1e5      	bne.n	80074dc <f_readdir+0x34>
					dp->sect = 0;
 8007510:	2200      	movs	r2, #0
 8007512:	f241 0310 	movw	r3, #4112	; 0x1010
 8007516:	50e2      	str	r2, [r4, r3]
					res = FR_OK;
 8007518:	4635      	mov	r5, r6
 800751a:	e7df      	b.n	80074dc <f_readdir+0x34>
 800751c:	2000022c 	.word	0x2000022c

08007520 <FATFS_LinkDriverEx>:
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 8007520:	4b11      	ldr	r3, [pc, #68]	; (8007568 <FATFS_LinkDriverEx+0x48>)
 8007522:	7a5b      	ldrb	r3, [r3, #9]
 8007524:	b2db      	uxtb	r3, r3
 8007526:	2b01      	cmp	r3, #1
 8007528:	d901      	bls.n	800752e <FATFS_LinkDriverEx+0xe>
  uint8_t ret = 1;
 800752a:	2001      	movs	r0, #1
 800752c:	4770      	bx	lr
{
 800752e:	b430      	push	{r4, r5}
  {
    disk.is_initialized[disk.nbr] = 0;
 8007530:	4c0d      	ldr	r4, [pc, #52]	; (8007568 <FATFS_LinkDriverEx+0x48>)
 8007532:	7a65      	ldrb	r5, [r4, #9]
 8007534:	b2ed      	uxtb	r5, r5
 8007536:	2300      	movs	r3, #0
 8007538:	5563      	strb	r3, [r4, r5]
    disk.drv[disk.nbr] = drv;  
 800753a:	7a65      	ldrb	r5, [r4, #9]
 800753c:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 8007540:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 8007542:	7a60      	ldrb	r0, [r4, #9]
 8007544:	4420      	add	r0, r4
 8007546:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 8007548:	7a62      	ldrb	r2, [r4, #9]
 800754a:	b2d2      	uxtb	r2, r2
 800754c:	1c50      	adds	r0, r2, #1
 800754e:	b2c0      	uxtb	r0, r0
 8007550:	7260      	strb	r0, [r4, #9]
    path[0] = DiskNum + '0';
 8007552:	3230      	adds	r2, #48	; 0x30
 8007554:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
 8007556:	223a      	movs	r2, #58	; 0x3a
 8007558:	704a      	strb	r2, [r1, #1]
    path[2] = '/';
 800755a:	222f      	movs	r2, #47	; 0x2f
 800755c:	708a      	strb	r2, [r1, #2]
    path[3] = 0;
 800755e:	70cb      	strb	r3, [r1, #3]
    ret = 0;
 8007560:	4618      	mov	r0, r3
  }
  
  return ret;
}
 8007562:	bc30      	pop	{r4, r5}
 8007564:	4770      	bx	lr
 8007566:	bf00      	nop
 8007568:	2000042c 	.word	0x2000042c

0800756c <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
 800756c:	b508      	push	{r3, lr}
  return FATFS_LinkDriverEx(drv, path, 0);
 800756e:	2200      	movs	r2, #0
 8007570:	f7ff ffd6 	bl	8007520 <FATFS_LinkDriverEx>
}
 8007574:	bd08      	pop	{r3, pc}
	...

08007578 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8007578:	287f      	cmp	r0, #127	; 0x7f
 800757a:	d916      	bls.n	80075aa <ff_convert+0x32>
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
 800757c:	b131      	cbz	r1, 800758c <ff_convert+0x14>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 800757e:	28ff      	cmp	r0, #255	; 0xff
 8007580:	d812      	bhi.n	80075a8 <ff_convert+0x30>
 8007582:	3880      	subs	r0, #128	; 0x80
 8007584:	4b09      	ldr	r3, [pc, #36]	; (80075ac <ff_convert+0x34>)
 8007586:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 800758a:	4770      	bx	lr
 800758c:	2300      	movs	r3, #0

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
 800758e:	2b7f      	cmp	r3, #127	; 0x7f
 8007590:	d807      	bhi.n	80075a2 <ff_convert+0x2a>
				if (chr == Tbl[c]) break;
 8007592:	4a06      	ldr	r2, [pc, #24]	; (80075ac <ff_convert+0x34>)
 8007594:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 8007598:	4290      	cmp	r0, r2
 800759a:	d002      	beq.n	80075a2 <ff_convert+0x2a>
			for (c = 0; c < 0x80; c++) {
 800759c:	3301      	adds	r3, #1
 800759e:	b29b      	uxth	r3, r3
 80075a0:	e7f5      	b.n	800758e <ff_convert+0x16>
			}
			c = (c + 0x80) & 0xFF;
 80075a2:	3380      	adds	r3, #128	; 0x80
 80075a4:	b2d8      	uxtb	r0, r3
 80075a6:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 80075a8:	2000      	movs	r0, #0
		}
	}

	return c;
}
 80075aa:	4770      	bx	lr
 80075ac:	08009f8c 	.word	0x08009f8c

080075b0 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 80075b0:	2200      	movs	r2, #0
 80075b2:	e000      	b.n	80075b6 <ff_wtoupper+0x6>
 80075b4:	3201      	adds	r2, #1
 80075b6:	4b05      	ldr	r3, [pc, #20]	; (80075cc <ff_wtoupper+0x1c>)
 80075b8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80075bc:	b10b      	cbz	r3, 80075c2 <ff_wtoupper+0x12>
 80075be:	4283      	cmp	r3, r0
 80075c0:	d1f8      	bne.n	80075b4 <ff_wtoupper+0x4>

	return tbl_lower[i] ? tbl_upper[i] : chr;
 80075c2:	b113      	cbz	r3, 80075ca <ff_wtoupper+0x1a>
 80075c4:	4b02      	ldr	r3, [pc, #8]	; (80075d0 <ff_wtoupper+0x20>)
 80075c6:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
 80075ca:	4770      	bx	lr
 80075cc:	0800a08c 	.word	0x0800a08c
 80075d0:	0800a26c 	.word	0x0800a26c

080075d4 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 80075d4:	b500      	push	{lr}
 80075d6:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;
  
  if (HAL_SD_ReadBlocks(&hsd, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
 80075d8:	9300      	str	r3, [sp, #0]
 80075da:	4613      	mov	r3, r2
 80075dc:	460a      	mov	r2, r1
 80075de:	4601      	mov	r1, r0
 80075e0:	4803      	ldr	r0, [pc, #12]	; (80075f0 <BSP_SD_ReadBlocks+0x1c>)
 80075e2:	f7fa fd59 	bl	8002098 <HAL_SD_ReadBlocks>
 80075e6:	b100      	cbz	r0, 80075ea <BSP_SD_ReadBlocks+0x16>
  {
    sd_state = MSD_ERROR;
 80075e8:	2001      	movs	r0, #1
  }

  return sd_state;  
}
 80075ea:	b003      	add	sp, #12
 80075ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80075f0:	2000cd5c 	.word	0x2000cd5c

080075f4 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 80075f4:	b500      	push	{lr}
 80075f6:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;
  
  if (HAL_SD_WriteBlocks(&hsd, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
 80075f8:	9300      	str	r3, [sp, #0]
 80075fa:	4613      	mov	r3, r2
 80075fc:	460a      	mov	r2, r1
 80075fe:	4601      	mov	r1, r0
 8007600:	4803      	ldr	r0, [pc, #12]	; (8007610 <BSP_SD_WriteBlocks+0x1c>)
 8007602:	f7fa fe7b 	bl	80022fc <HAL_SD_WriteBlocks>
 8007606:	b100      	cbz	r0, 800760a <BSP_SD_WriteBlocks+0x16>
  {
    sd_state = MSD_ERROR;
 8007608:	2001      	movs	r0, #1
  }

  return sd_state;  
}
 800760a:	b003      	add	sp, #12
 800760c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007610:	2000cd5c 	.word	0x2000cd5c

08007614 <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
uint8_t BSP_SD_GetCardState(void)
{
 8007614:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 8007616:	4803      	ldr	r0, [pc, #12]	; (8007624 <BSP_SD_GetCardState+0x10>)
 8007618:	f7fb f998 	bl	800294c <HAL_SD_GetCardState>
}
 800761c:	3804      	subs	r0, #4
 800761e:	bf18      	it	ne
 8007620:	2001      	movne	r0, #1
 8007622:	bd08      	pop	{r3, pc}
 8007624:	2000cd5c 	.word	0x2000cd5c

08007628 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None 
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
 8007628:	b508      	push	{r3, lr}
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd, CardInfo);
 800762a:	4601      	mov	r1, r0
 800762c:	4801      	ldr	r0, [pc, #4]	; (8007634 <BSP_SD_GetCardInfo+0xc>)
 800762e:	f7fb f928 	bl	8002882 <HAL_SD_GetCardInfo>
 8007632:	bd08      	pop	{r3, pc}
 8007634:	2000cd5c 	.word	0x2000cd5c

08007638 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
 8007638:	b082      	sub	sp, #8
  __IO uint8_t status = SD_PRESENT;
 800763a:	2301      	movs	r3, #1
 800763c:	f88d 3007 	strb.w	r3, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8007640:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8007644:	b002      	add	sp, #8
 8007646:	4770      	bx	lr

08007648 <BSP_SD_Init>:
{
 8007648:	b510      	push	{r4, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
 800764a:	f7ff fff5 	bl	8007638 <BSP_SD_IsDetected>
 800764e:	2801      	cmp	r0, #1
 8007650:	d002      	beq.n	8007658 <BSP_SD_Init+0x10>
    return MSD_ERROR;
 8007652:	2401      	movs	r4, #1
}
 8007654:	4620      	mov	r0, r4
 8007656:	bd10      	pop	{r4, pc}
  sd_state = HAL_SD_Init(&hsd);
 8007658:	4807      	ldr	r0, [pc, #28]	; (8007678 <BSP_SD_Init+0x30>)
 800765a:	f7fb f8f3 	bl	8002844 <HAL_SD_Init>
  if (sd_state == MSD_OK)
 800765e:	4604      	mov	r4, r0
 8007660:	2800      	cmp	r0, #0
 8007662:	d1f7      	bne.n	8007654 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) != HAL_OK)
 8007664:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007668:	4803      	ldr	r0, [pc, #12]	; (8007678 <BSP_SD_Init+0x30>)
 800766a:	f7fb f91d 	bl	80028a8 <HAL_SD_ConfigWideBusOperation>
 800766e:	2800      	cmp	r0, #0
 8007670:	d0f0      	beq.n	8007654 <BSP_SD_Init+0xc>
      sd_state = MSD_ERROR;
 8007672:	2401      	movs	r4, #1
 8007674:	e7ee      	b.n	8007654 <BSP_SD_Init+0xc>
 8007676:	bf00      	nop
 8007678:	2000cd5c 	.word	0x2000cd5c

0800767c <DWT_Delay_Init>:
 *         1: clock cycle counter not started
 *         0: clock cycle counter works
 */
uint32_t DWT_Delay_Init(void) {
  /* Disable TRC */
  CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk; // ~0x01000000;
 800767c:	4b0e      	ldr	r3, [pc, #56]	; (80076b8 <DWT_Delay_Init+0x3c>)
 800767e:	68da      	ldr	r2, [r3, #12]
 8007680:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8007684:	60da      	str	r2, [r3, #12]
  /* Enable TRC */
  CoreDebug->DEMCR |=  CoreDebug_DEMCR_TRCENA_Msk; // 0x01000000;
 8007686:	68da      	ldr	r2, [r3, #12]
 8007688:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800768c:	60da      	str	r2, [r3, #12]

  /* Disable clock cycle counter */
  DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; //~0x00000001;
 800768e:	4b0b      	ldr	r3, [pc, #44]	; (80076bc <DWT_Delay_Init+0x40>)
 8007690:	681a      	ldr	r2, [r3, #0]
 8007692:	f022 0201 	bic.w	r2, r2, #1
 8007696:	601a      	str	r2, [r3, #0]
  /* Enable  clock cycle counter */
  DWT->CTRL |=  DWT_CTRL_CYCCNTENA_Msk; //0x00000001;
 8007698:	681a      	ldr	r2, [r3, #0]
 800769a:	f042 0201 	orr.w	r2, r2, #1
 800769e:	601a      	str	r2, [r3, #0]

  /* Reset the clock cycle counter value */
  DWT->CYCCNT = 0;
 80076a0:	2200      	movs	r2, #0
 80076a2:	605a      	str	r2, [r3, #4]

     /* 3 NO OPERATION instructions */
     __ASM volatile ("NOP");
 80076a4:	bf00      	nop
     __ASM volatile ("NOP");
 80076a6:	bf00      	nop
  __ASM volatile ("NOP");
 80076a8:	bf00      	nop

  /* Check if clock cycle counter has started */
     if(DWT->CYCCNT)
 80076aa:	685b      	ldr	r3, [r3, #4]
 80076ac:	b90b      	cbnz	r3, 80076b2 <DWT_Delay_Init+0x36>
     {
       return 0; /*clock cycle counter started*/
     }
     else
  {
    return 1; /*clock cycle counter not started*/
 80076ae:	2001      	movs	r0, #1
  }
}
 80076b0:	4770      	bx	lr
       return 0; /*clock cycle counter started*/
 80076b2:	4610      	mov	r0, r2
 80076b4:	4770      	bx	lr
 80076b6:	bf00      	nop
 80076b8:	e000edf0 	.word	0xe000edf0
 80076bc:	e0001000 	.word	0xe0001000

080076c0 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 80076c0:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 80076c2:	4903      	ldr	r1, [pc, #12]	; (80076d0 <MX_FATFS_Init+0x10>)
 80076c4:	4803      	ldr	r0, [pc, #12]	; (80076d4 <MX_FATFS_Init+0x14>)
 80076c6:	f7ff ff51 	bl	800756c <FATFS_LinkDriver>
 80076ca:	4b03      	ldr	r3, [pc, #12]	; (80076d8 <MX_FATFS_Init+0x18>)
 80076cc:	7018      	strb	r0, [r3, #0]
 80076ce:	bd08      	pop	{r3, pc}
 80076d0:	2000098c 	.word	0x2000098c
 80076d4:	08009ed4 	.word	0x08009ed4
 80076d8:	20000988 	.word	0x20000988

080076dc <get_fattime>:
DWORD get_fattime(void)
{
  /* USER CODE BEGIN get_fattime */
  return 0;
  /* USER CODE END get_fattime */  
}
 80076dc:	2000      	movs	r0, #0
 80076de:	4770      	bx	lr

080076e0 <MX_SDIO_SD_Init>:
  /* USER CODE END SDIO_Init 0 */

  /* USER CODE BEGIN SDIO_Init 1 */

  /* USER CODE END SDIO_Init 1 */
  hsd.Instance = SDIO;
 80076e0:	4b05      	ldr	r3, [pc, #20]	; (80076f8 <MX_SDIO_SD_Init+0x18>)
 80076e2:	4a06      	ldr	r2, [pc, #24]	; (80076fc <MX_SDIO_SD_Init+0x1c>)
 80076e4:	601a      	str	r2, [r3, #0]
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 80076e6:	2200      	movs	r2, #0
 80076e8:	605a      	str	r2, [r3, #4]
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 80076ea:	609a      	str	r2, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 80076ec:	60da      	str	r2, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 80076ee:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 80076f0:	615a      	str	r2, [r3, #20]
  hsd.Init.ClockDiv = 4;
 80076f2:	2204      	movs	r2, #4
 80076f4:	619a      	str	r2, [r3, #24]
 80076f6:	4770      	bx	lr
 80076f8:	2000cd5c 	.word	0x2000cd5c
 80076fc:	40018000 	.word	0x40018000

08007700 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8007700:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007704:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007706:	2400      	movs	r4, #0
 8007708:	9404      	str	r4, [sp, #16]
 800770a:	9405      	str	r4, [sp, #20]
 800770c:	9406      	str	r4, [sp, #24]
 800770e:	9407      	str	r4, [sp, #28]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8007710:	4b34      	ldr	r3, [pc, #208]	; (80077e4 <MX_GPIO_Init+0xe4>)
 8007712:	699a      	ldr	r2, [r3, #24]
 8007714:	f042 0220 	orr.w	r2, r2, #32
 8007718:	619a      	str	r2, [r3, #24]
 800771a:	699a      	ldr	r2, [r3, #24]
 800771c:	f002 0220 	and.w	r2, r2, #32
 8007720:	9200      	str	r2, [sp, #0]
 8007722:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8007724:	699a      	ldr	r2, [r3, #24]
 8007726:	f042 0210 	orr.w	r2, r2, #16
 800772a:	619a      	str	r2, [r3, #24]
 800772c:	699a      	ldr	r2, [r3, #24]
 800772e:	f002 0210 	and.w	r2, r2, #16
 8007732:	9201      	str	r2, [sp, #4]
 8007734:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8007736:	699a      	ldr	r2, [r3, #24]
 8007738:	f042 0204 	orr.w	r2, r2, #4
 800773c:	619a      	str	r2, [r3, #24]
 800773e:	699a      	ldr	r2, [r3, #24]
 8007740:	f002 0204 	and.w	r2, r2, #4
 8007744:	9202      	str	r2, [sp, #8]
 8007746:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8007748:	699a      	ldr	r2, [r3, #24]
 800774a:	f042 0208 	orr.w	r2, r2, #8
 800774e:	619a      	str	r2, [r3, #24]
 8007750:	699b      	ldr	r3, [r3, #24]
 8007752:	f003 0308 	and.w	r3, r3, #8
 8007756:	9303      	str	r3, [sp, #12]
 8007758:	9b03      	ldr	r3, [sp, #12]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, SN_D0_Pin|SN_D1_Pin|SN_D2_Pin|SN_D3_Pin 
 800775a:	f8df 9090 	ldr.w	r9, [pc, #144]	; 80077ec <MX_GPIO_Init+0xec>
 800775e:	4622      	mov	r2, r4
 8007760:	21ff      	movs	r1, #255	; 0xff
 8007762:	4648      	mov	r0, r9
 8007764:	f7f8 ff2c 	bl	80005c0 <HAL_GPIO_WritePin>
                          |SN_D4_Pin|SN_D5_Pin|SN_D6_Pin|SN_D7_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, YM_D0_Pin|YM_D1_Pin|YM_D2_Pin|YM_D3_Pin 
 8007768:	f8df 8084 	ldr.w	r8, [pc, #132]	; 80077f0 <MX_GPIO_Init+0xf0>
 800776c:	4622      	mov	r2, r4
 800776e:	f248 71ff 	movw	r1, #34815	; 0x87ff
 8007772:	4640      	mov	r0, r8
 8007774:	f7f8 ff24 	bl	80005c0 <HAL_GPIO_WritePin>
                          |YM_D4_Pin|YM_D5_Pin|YM_D6_Pin|YM_D7_Pin 
                          |YM_A1_Pin|LED1_Pin|LED2_Pin|LED3_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, SN_WE_Pin|YM_IC_Pin|YM_CS_Pin|YM_WR_Pin 
 8007778:	4d1b      	ldr	r5, [pc, #108]	; (80077e8 <MX_GPIO_Init+0xe8>)
 800777a:	2201      	movs	r2, #1
 800777c:	f24f 0145 	movw	r1, #61509	; 0xf045
 8007780:	4628      	mov	r0, r5
 8007782:	f7f8 ff1d 	bl	80005c0 <HAL_GPIO_WritePin>
                          |YM_RD_Pin|YM_A0_Pin|SPI1_CS_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SN_OE_GPIO_Port, SN_OE_Pin, GPIO_PIN_RESET);
 8007786:	4622      	mov	r2, r4
 8007788:	2102      	movs	r1, #2
 800778a:	4628      	mov	r0, r5
 800778c:	f7f8 ff18 	bl	80005c0 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : SN_D0_Pin SN_D1_Pin SN_D2_Pin SN_D3_Pin 
                           SN_D4_Pin SN_D5_Pin SN_D6_Pin SN_D7_Pin */
  GPIO_InitStruct.Pin = SN_D0_Pin|SN_D1_Pin|SN_D2_Pin|SN_D3_Pin 
 8007790:	23ff      	movs	r3, #255	; 0xff
 8007792:	9304      	str	r3, [sp, #16]
                          |SN_D4_Pin|SN_D5_Pin|SN_D6_Pin|SN_D7_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8007794:	2701      	movs	r7, #1
 8007796:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007798:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800779a:	2602      	movs	r6, #2
 800779c:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800779e:	a904      	add	r1, sp, #16
 80077a0:	4648      	mov	r0, r9
 80077a2:	f7f8 fe0d 	bl	80003c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : YM_D0_Pin YM_D1_Pin YM_D2_Pin YM_D3_Pin 
                           YM_D4_Pin YM_D5_Pin YM_D6_Pin YM_D7_Pin 
                           YM_A1_Pin LED1_Pin LED2_Pin LED3_Pin */
  GPIO_InitStruct.Pin = YM_D0_Pin|YM_D1_Pin|YM_D2_Pin|YM_D3_Pin 
 80077a6:	f248 73ff 	movw	r3, #34815	; 0x87ff
 80077aa:	9304      	str	r3, [sp, #16]
                          |YM_D4_Pin|YM_D5_Pin|YM_D6_Pin|YM_D7_Pin 
                          |YM_A1_Pin|LED1_Pin|LED2_Pin|LED3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80077ac:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80077ae:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80077b0:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80077b2:	a904      	add	r1, sp, #16
 80077b4:	4640      	mov	r0, r8
 80077b6:	f7f8 fe03 	bl	80003c0 <HAL_GPIO_Init>

  /*Configure GPIO pins : SN_WE_Pin SN_OE_Pin YM_IC_Pin YM_CS_Pin 
                           YM_WR_Pin YM_RD_Pin YM_A0_Pin SPI1_CS_Pin */
  GPIO_InitStruct.Pin = SN_WE_Pin|SN_OE_Pin|YM_IC_Pin|YM_CS_Pin 
 80077ba:	f24f 0347 	movw	r3, #61511	; 0xf047
 80077be:	9304      	str	r3, [sp, #16]
                          |YM_WR_Pin|YM_RD_Pin|YM_A0_Pin|SPI1_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80077c0:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80077c2:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80077c4:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80077c6:	a904      	add	r1, sp, #16
 80077c8:	4628      	mov	r0, r5
 80077ca:	f7f8 fdf9 	bl	80003c0 <HAL_GPIO_Init>

  /*Configure GPIO pin : GOMB_Pin_Pin */
  GPIO_InitStruct.Pin = GOMB_Pin_Pin;
 80077ce:	2380      	movs	r3, #128	; 0x80
 80077d0:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80077d2:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80077d4:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(GOMB_Pin_GPIO_Port, &GPIO_InitStruct);
 80077d6:	a904      	add	r1, sp, #16
 80077d8:	4628      	mov	r0, r5
 80077da:	f7f8 fdf1 	bl	80003c0 <HAL_GPIO_Init>

}
 80077de:	b009      	add	sp, #36	; 0x24
 80077e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80077e4:	40021000 	.word	0x40021000
 80077e8:	40010c00 	.word	0x40010c00
 80077ec:	40011000 	.word	0x40011000
 80077f0:	40010800 	.word	0x40010800

080077f4 <MX_SPI1_Init>:
{
 80077f4:	b508      	push	{r3, lr}
  hspi1.Instance = SPI1;
 80077f6:	480c      	ldr	r0, [pc, #48]	; (8007828 <MX_SPI1_Init+0x34>)
 80077f8:	4b0c      	ldr	r3, [pc, #48]	; (800782c <MX_SPI1_Init+0x38>)
 80077fa:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80077fc:	f44f 7382 	mov.w	r3, #260	; 0x104
 8007800:	6043      	str	r3, [r0, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8007802:	2300      	movs	r3, #0
 8007804:	6083      	str	r3, [r0, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8007806:	60c3      	str	r3, [r0, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8007808:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 800780a:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 800780c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8007810:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8007812:	2208      	movs	r2, #8
 8007814:	61c2      	str	r2, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8007816:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8007818:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800781a:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 800781c:	230a      	movs	r3, #10
 800781e:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8007820:	f7fb f93f 	bl	8002aa2 <HAL_SPI_Init>
 8007824:	bd08      	pop	{r3, pc}
 8007826:	bf00      	nop
 8007828:	2000e660 	.word	0x2000e660
 800782c:	40013000 	.word	0x40013000

08007830 <MX_I2C2_Init>:
{
 8007830:	b508      	push	{r3, lr}
  hi2c2.Instance = I2C2;
 8007832:	4809      	ldr	r0, [pc, #36]	; (8007858 <MX_I2C2_Init+0x28>)
 8007834:	4b09      	ldr	r3, [pc, #36]	; (800785c <MX_I2C2_Init+0x2c>)
 8007836:	6003      	str	r3, [r0, #0]
  hi2c2.Init.ClockSpeed = 400000;
 8007838:	4b09      	ldr	r3, [pc, #36]	; (8007860 <MX_I2C2_Init+0x30>)
 800783a:	6043      	str	r3, [r0, #4]
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
 800783c:	2300      	movs	r3, #0
 800783e:	6083      	str	r3, [r0, #8]
  hi2c2.Init.OwnAddress1 = 0;
 8007840:	60c3      	str	r3, [r0, #12]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007842:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8007846:	6102      	str	r2, [r0, #16]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8007848:	6143      	str	r3, [r0, #20]
  hi2c2.Init.OwnAddress2 = 0;
 800784a:	6183      	str	r3, [r0, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800784c:	61c3      	str	r3, [r0, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800784e:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8007850:	f7f9 f80e 	bl	8000870 <HAL_I2C_Init>
 8007854:	bd08      	pop	{r3, pc}
 8007856:	bf00      	nop
 8007858:	20004a48 	.word	0x20004a48
 800785c:	40005800 	.word	0x40005800
 8007860:	00061a80 	.word	0x00061a80

08007864 <MX_TIM6_Init>:
{
 8007864:	b530      	push	{r4, r5, lr}
 8007866:	b083      	sub	sp, #12
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007868:	2500      	movs	r5, #0
 800786a:	9500      	str	r5, [sp, #0]
 800786c:	9501      	str	r5, [sp, #4]
  htim6.Instance = TIM6;
 800786e:	4c0a      	ldr	r4, [pc, #40]	; (8007898 <MX_TIM6_Init+0x34>)
 8007870:	4b0a      	ldr	r3, [pc, #40]	; (800789c <MX_TIM6_Init+0x38>)
 8007872:	6023      	str	r3, [r4, #0]
  htim6.Init.Prescaler = 1;
 8007874:	2301      	movs	r3, #1
 8007876:	6063      	str	r3, [r4, #4]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 8007878:	60a5      	str	r5, [r4, #8]
  htim6.Init.Period = 816;
 800787a:	f44f 734c 	mov.w	r3, #816	; 0x330
 800787e:	60e3      	str	r3, [r4, #12]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007880:	61a5      	str	r5, [r4, #24]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 8007882:	4620      	mov	r0, r4
 8007884:	f7fb fd38 	bl	80032f8 <HAL_TIM_Base_Init>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007888:	9500      	str	r5, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800788a:	9501      	str	r5, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 800788c:	4669      	mov	r1, sp
 800788e:	4620      	mov	r0, r4
 8007890:	f7fb fd4b 	bl	800332a <HAL_TIMEx_MasterConfigSynchronization>
}
 8007894:	b003      	add	sp, #12
 8007896:	bd30      	pop	{r4, r5, pc}
 8007898:	2000cd14 	.word	0x2000cd14
 800789c:	40001000 	.word	0x40001000

080078a0 <SystemClock_Config>:
{
 80078a0:	b530      	push	{r4, r5, lr}
 80078a2:	b097      	sub	sp, #92	; 0x5c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80078a4:	2228      	movs	r2, #40	; 0x28
 80078a6:	2100      	movs	r1, #0
 80078a8:	a80c      	add	r0, sp, #48	; 0x30
 80078aa:	f001 fed4 	bl	8009656 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80078ae:	2400      	movs	r4, #0
 80078b0:	9407      	str	r4, [sp, #28]
 80078b2:	9408      	str	r4, [sp, #32]
 80078b4:	9409      	str	r4, [sp, #36]	; 0x24
 80078b6:	940a      	str	r4, [sp, #40]	; 0x28
 80078b8:	940b      	str	r4, [sp, #44]	; 0x2c
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80078ba:	9401      	str	r4, [sp, #4]
 80078bc:	9402      	str	r4, [sp, #8]
 80078be:	9403      	str	r4, [sp, #12]
 80078c0:	9404      	str	r4, [sp, #16]
 80078c2:	9405      	str	r4, [sp, #20]
 80078c4:	9406      	str	r4, [sp, #24]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80078c6:	2201      	movs	r2, #1
 80078c8:	920c      	str	r2, [sp, #48]	; 0x30
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80078ca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80078ce:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80078d0:	9210      	str	r2, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80078d2:	2502      	movs	r5, #2
 80078d4:	9513      	str	r5, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80078d6:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 80078d8:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
 80078dc:	9315      	str	r3, [sp, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80078de:	a80c      	add	r0, sp, #48	; 0x30
 80078e0:	f7f9 fef6 	bl	80016d0 <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80078e4:	230f      	movs	r3, #15
 80078e6:	9307      	str	r3, [sp, #28]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80078e8:	9508      	str	r5, [sp, #32]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80078ea:	9409      	str	r4, [sp, #36]	; 0x24
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80078ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80078f0:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80078f2:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 80078f4:	4629      	mov	r1, r5
 80078f6:	a807      	add	r0, sp, #28
 80078f8:	f7fa f928 	bl	8001b4c <HAL_RCC_ClockConfig>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 80078fc:	2310      	movs	r3, #16
 80078fe:	9301      	str	r3, [sp, #4]
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
 8007900:	9406      	str	r4, [sp, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8007902:	a801      	add	r0, sp, #4
 8007904:	f7fa f9ec 	bl	8001ce0 <HAL_RCCEx_PeriphCLKConfig>
}
 8007908:	b017      	add	sp, #92	; 0x5c
 800790a:	bd30      	pop	{r4, r5, pc}

0800790c <HAL_TIM_PeriodElapsedCallback>:

/* USER CODE BEGIN 4 */
// ((((72000000/2) / (1 / (1 / 44100)) + 0,5) - 1)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Instance == TIM6)	// Ha rkezik timer megszakts
 800790c:	6802      	ldr	r2, [r0, #0]
 800790e:	4b14      	ldr	r3, [pc, #80]	; (8007960 <HAL_TIM_PeriodElapsedCallback+0x54>)
 8007910:	429a      	cmp	r2, r3
 8007912:	d000      	beq.n	8007916 <HAL_TIM_PeriodElapsedCallback+0xa>
 8007914:	4770      	bx	lr
{
 8007916:	b510      	push	{r4, lr}
	{
		if(waitSamples>0)
 8007918:	4b12      	ldr	r3, [pc, #72]	; (8007964 <HAL_TIM_PeriodElapsedCallback+0x58>)
 800791a:	681b      	ldr	r3, [r3, #0]
 800791c:	b11b      	cbz	r3, 8007926 <HAL_TIM_PeriodElapsedCallback+0x1a>
			waitSamples--;
 800791e:	4a11      	ldr	r2, [pc, #68]	; (8007964 <HAL_TIM_PeriodElapsedCallback+0x58>)
 8007920:	6813      	ldr	r3, [r2, #0]
 8007922:	3b01      	subs	r3, #1
 8007924:	6013      	str	r3, [r2, #0]

		if(waitSamples==0 && SampleNext == 1)
 8007926:	4b0f      	ldr	r3, [pc, #60]	; (8007964 <HAL_TIM_PeriodElapsedCallback+0x58>)
 8007928:	681b      	ldr	r3, [r3, #0]
 800792a:	b923      	cbnz	r3, 8007936 <HAL_TIM_PeriodElapsedCallback+0x2a>
 800792c:	4b0e      	ldr	r3, [pc, #56]	; (8007968 <HAL_TIM_PeriodElapsedCallback+0x5c>)
 800792e:	781b      	ldrb	r3, [r3, #0]
 8007930:	b2db      	uxtb	r3, r3
 8007932:	2b01      	cmp	r3, #1
 8007934:	d005      	beq.n	8007942 <HAL_TIM_PeriodElapsedCallback+0x36>
			waitSamples = WaveSampleIf();
			//HAL_TIM_Base_Start_IT(&htim6);

			SampleNext=1;
		}
		HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);
 8007936:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800793a:	480c      	ldr	r0, [pc, #48]	; (800796c <HAL_TIM_PeriodElapsedCallback+0x60>)
 800793c:	f7f8 fe46 	bl	80005cc <HAL_GPIO_TogglePin>
 8007940:	bd10      	pop	{r4, pc}
			SampleNext=0;
 8007942:	4c09      	ldr	r4, [pc, #36]	; (8007968 <HAL_TIM_PeriodElapsedCallback+0x5c>)
 8007944:	2300      	movs	r3, #0
 8007946:	7023      	strb	r3, [r4, #0]
			MemCim.value++;
 8007948:	4a09      	ldr	r2, [pc, #36]	; (8007970 <HAL_TIM_PeriodElapsedCallback+0x64>)
 800794a:	6813      	ldr	r3, [r2, #0]
 800794c:	3301      	adds	r3, #1
 800794e:	6013      	str	r3, [r2, #0]
			waitSamples = WaveSampleIf();
 8007950:	f001 fcde 	bl	8009310 <WaveSampleIf>
 8007954:	4b03      	ldr	r3, [pc, #12]	; (8007964 <HAL_TIM_PeriodElapsedCallback+0x58>)
 8007956:	6018      	str	r0, [r3, #0]
			SampleNext=1;
 8007958:	2301      	movs	r3, #1
 800795a:	7023      	strb	r3, [r4, #0]
 800795c:	e7eb      	b.n	8007936 <HAL_TIM_PeriodElapsedCallback+0x2a>
 800795e:	bf00      	nop
 8007960:	40001000 	.word	0x40001000
 8007964:	2000054c 	.word	0x2000054c
 8007968:	20000120 	.word	0x20000120
 800796c:	40010800 	.word	0x40010800
 8007970:	2000e6e0 	.word	0x2000e6e0

08007974 <SystemClock_Config_128MHz>:
	}
}

// USB not working
void SystemClock_Config_128MHz(void)
{
 8007974:	b530      	push	{r4, r5, lr}
 8007976:	b097      	sub	sp, #92	; 0x5c
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8007978:	2228      	movs	r2, #40	; 0x28
 800797a:	2100      	movs	r1, #0
 800797c:	a80c      	add	r0, sp, #48	; 0x30
 800797e:	f001 fe6a 	bl	8009656 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8007982:	2400      	movs	r4, #0
 8007984:	9407      	str	r4, [sp, #28]
 8007986:	9408      	str	r4, [sp, #32]
 8007988:	9409      	str	r4, [sp, #36]	; 0x24
 800798a:	940a      	str	r4, [sp, #40]	; 0x28
 800798c:	940b      	str	r4, [sp, #44]	; 0x2c
	RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800798e:	9401      	str	r4, [sp, #4]
 8007990:	9402      	str	r4, [sp, #8]
 8007992:	9403      	str	r4, [sp, #12]
 8007994:	9404      	str	r4, [sp, #16]
 8007996:	9405      	str	r4, [sp, #20]
 8007998:	9406      	str	r4, [sp, #24]

	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800799a:	2201      	movs	r2, #1
 800799c:	920c      	str	r2, [sp, #48]	; 0x30
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800799e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80079a2:	930d      	str	r3, [sp, #52]	; 0x34
	RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80079a4:	9210      	str	r2, [sp, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80079a6:	2502      	movs	r5, #2
 80079a8:	9513      	str	r5, [sp, #76]	; 0x4c
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80079aa:	9314      	str	r3, [sp, #80]	; 0x50
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
 80079ac:	f44f 1360 	mov.w	r3, #3670016	; 0x380000
 80079b0:	9315      	str	r3, [sp, #84]	; 0x54
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80079b2:	a80c      	add	r0, sp, #48	; 0x30
 80079b4:	f7f9 fe8c 	bl	80016d0 <HAL_RCC_OscConfig>
	{
		Error_Handler();
	}
	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80079b8:	230f      	movs	r3, #15
 80079ba:	9307      	str	r3, [sp, #28]
								|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80079bc:	9508      	str	r5, [sp, #32]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80079be:	9409      	str	r4, [sp, #36]	; 0x24
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80079c0:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 80079c4:	930a      	str	r3, [sp, #40]	; 0x28
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80079c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80079ca:	930b      	str	r3, [sp, #44]	; 0x2c

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 80079cc:	4629      	mov	r1, r5
 80079ce:	a807      	add	r0, sp, #28
 80079d0:	f7fa f8bc 	bl	8001b4c <HAL_RCC_ClockConfig>
	{
		Error_Handler();
	}
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 80079d4:	2310      	movs	r3, #16
 80079d6:	9301      	str	r3, [sp, #4]
	PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
 80079d8:	9406      	str	r4, [sp, #24]
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80079da:	a801      	add	r0, sp, #4
 80079dc:	f7fa f980 	bl	8001ce0 <HAL_RCCEx_PeriphCLKConfig>
	{
		Error_Handler();
	}
}
 80079e0:	b017      	add	sp, #92	; 0x5c
 80079e2:	bd30      	pop	{r4, r5, pc}

080079e4 <main>:
{
 80079e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80079e8:	f5ad 5d0a 	sub.w	sp, sp, #8832	; 0x2280
 80079ec:	b081      	sub	sp, #4
	PCMLoad = 0;
 80079ee:	2400      	movs	r4, #0
 80079f0:	4baa      	ldr	r3, [pc, #680]	; (8007c9c <main+0x2b8>)
 80079f2:	701c      	strb	r4, [r3, #0]
	uint8_t StrTemp[19] = {0};
 80079f4:	f50d 5309 	add.w	r3, sp, #8768	; 0x2240
 80079f8:	3328      	adds	r3, #40	; 0x28
 80079fa:	601c      	str	r4, [r3, #0]
 80079fc:	605c      	str	r4, [r3, #4]
 80079fe:	609c      	str	r4, [r3, #8]
 8007a00:	60dc      	str	r4, [r3, #12]
 8007a02:	f8c3 400f 	str.w	r4, [r3, #15]
  HAL_Init();
 8007a06:	f7f8 fc3b 	bl	8000280 <HAL_Init>
  SystemClock_Config();
 8007a0a:	f7ff ff49 	bl	80078a0 <SystemClock_Config>
  MX_GPIO_Init();
 8007a0e:	f7ff fe77 	bl	8007700 <MX_GPIO_Init>
  MX_SPI1_Init();
 8007a12:	f7ff feef 	bl	80077f4 <MX_SPI1_Init>
  MX_USB_DEVICE_Init();
 8007a16:	f000 ff8b 	bl	8008930 <MX_USB_DEVICE_Init>
  MX_I2C2_Init();
 8007a1a:	f7ff ff09 	bl	8007830 <MX_I2C2_Init>
  MX_SDIO_SD_Init();
 8007a1e:	f7ff fe5f 	bl	80076e0 <MX_SDIO_SD_Init>
  MX_TIM6_Init();
 8007a22:	f7ff ff1f 	bl	8007864 <MX_TIM6_Init>
  MX_FATFS_Init();
 8007a26:	f7ff fe4b 	bl	80076c0 <MX_FATFS_Init>
  DWT_Delay_Init();
 8007a2a:	f7ff fe27 	bl	800767c <DWT_Delay_Init>
  SSD1306_Init();
 8007a2e:	f000 fd95 	bl	800855c <SSD1306_Init>
  PSG_Silence();
 8007a32:	f001 fb97 	bl	8009164 <PSG_Silence>
  	SSD1306_GotoXY (0,0);
 8007a36:	4621      	mov	r1, r4
 8007a38:	4620      	mov	r0, r4
 8007a3a:	f000 fcd3 	bl	80083e4 <SSD1306_GotoXY>
	SSD1306_Puts ("DPTP System - 2023 ", &Font_7x10, 1);
 8007a3e:	4d98      	ldr	r5, [pc, #608]	; (8007ca0 <main+0x2bc>)
 8007a40:	2201      	movs	r2, #1
 8007a42:	4629      	mov	r1, r5
 8007a44:	4897      	ldr	r0, [pc, #604]	; (8007ca4 <main+0x2c0>)
 8007a46:	f000 fd23 	bl	8008490 <SSD1306_Puts>
	SSD1306_GotoXY (0,9);
 8007a4a:	2109      	movs	r1, #9
 8007a4c:	4620      	mov	r0, r4
 8007a4e:	f000 fcc9 	bl	80083e4 <SSD1306_GotoXY>
	SSD1306_Puts ("VGM Player v3.0 ", &Font_7x10, 1);
 8007a52:	2201      	movs	r2, #1
 8007a54:	4629      	mov	r1, r5
 8007a56:	4894      	ldr	r0, [pc, #592]	; (8007ca8 <main+0x2c4>)
 8007a58:	f000 fd1a 	bl	8008490 <SSD1306_Puts>
	SSD1306_GotoXY (0,20);
 8007a5c:	2114      	movs	r1, #20
 8007a5e:	4620      	mov	r0, r4
 8007a60:	f000 fcc0 	bl	80083e4 <SSD1306_GotoXY>
	SSD1306_Puts ("System Ready ", &Font_7x10, 1);
 8007a64:	2201      	movs	r2, #1
 8007a66:	4629      	mov	r1, r5
 8007a68:	4890      	ldr	r0, [pc, #576]	; (8007cac <main+0x2c8>)
 8007a6a:	f000 fd11 	bl	8008490 <SSD1306_Puts>
	SSD1306_UpdateScreen();
 8007a6e:	f000 fd51 	bl	8008514 <SSD1306_UpdateScreen>
	HAL_Delay(2000);
 8007a72:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8007a76:	f7f8 fc27 	bl	80002c8 <HAL_Delay>
	BYTE FileName[200][32] = {0};
 8007a7a:	f44f 52c8 	mov.w	r2, #6400	; 0x1900
 8007a7e:	4621      	mov	r1, r4
 8007a80:	f60d 1068 	addw	r0, sp, #2408	; 0x968
 8007a84:	f001 fde7 	bl	8009656 <memset>
	BYTE FileSortName[200][12] = {0};
 8007a88:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8007a8c:	4621      	mov	r1, r4
 8007a8e:	a802      	add	r0, sp, #8
 8007a90:	f001 fde1 	bl	8009656 <memset>
		finfo.lfname = lfn;
 8007a94:	4b86      	ldr	r3, [pc, #536]	; (8007cb0 <main+0x2cc>)
 8007a96:	4a87      	ldr	r2, [pc, #540]	; (8007cb4 <main+0x2d0>)
 8007a98:	619a      	str	r2, [r3, #24]
		finfo.lfsize = sizeof lfn;
 8007a9a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007a9e:	61da      	str	r2, [r3, #28]
	if (f_mount(&FatFs,"/",(BYTE)1) == FR_OK)
 8007aa0:	2201      	movs	r2, #1
 8007aa2:	4985      	ldr	r1, [pc, #532]	; (8007cb8 <main+0x2d4>)
 8007aa4:	4885      	ldr	r0, [pc, #532]	; (8007cbc <main+0x2d8>)
 8007aa6:	f7ff f989 	bl	8006dbc <f_mount>
 8007aaa:	2800      	cmp	r0, #0
 8007aac:	f040 808f 	bne.w	8007bce <main+0x1ea>
	   if (f_opendir(&dirs, path) == FR_OK)
 8007ab0:	4983      	ldr	r1, [pc, #524]	; (8007cc0 <main+0x2dc>)
 8007ab2:	4884      	ldr	r0, [pc, #528]	; (8007cc4 <main+0x2e0>)
 8007ab4:	f7ff fc94 	bl	80073e0 <f_opendir>
 8007ab8:	2800      	cmp	r0, #0
 8007aba:	f000 8086 	beq.w	8007bca <main+0x1e6>
	MemCim.value = 8;
 8007abe:	4d82      	ldr	r5, [pc, #520]	; (8007cc8 <main+0x2e4>)
 8007ac0:	2308      	movs	r3, #8
 8007ac2:	602b      	str	r3, [r5, #0]
	VGMVersion = MemRead(MemCim);
 8007ac4:	6828      	ldr	r0, [r5, #0]
 8007ac6:	f001 fa0d 	bl	8008ee4 <MemRead>
 8007aca:	b280      	uxth	r0, r0
 8007acc:	4e7f      	ldr	r6, [pc, #508]	; (8007ccc <main+0x2e8>)
 8007ace:	8030      	strh	r0, [r6, #0]
	MemCim.value++;
 8007ad0:	682b      	ldr	r3, [r5, #0]
 8007ad2:	3301      	adds	r3, #1
 8007ad4:	602b      	str	r3, [r5, #0]
	VGMVersion |= ((uint16_t)MemRead(MemCim))<<8;
 8007ad6:	6828      	ldr	r0, [r5, #0]
 8007ad8:	f001 fa04 	bl	8008ee4 <MemRead>
 8007adc:	8833      	ldrh	r3, [r6, #0]
 8007ade:	b29b      	uxth	r3, r3
 8007ae0:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007ae4:	b29b      	uxth	r3, r3
 8007ae6:	8033      	strh	r3, [r6, #0]
	if(VGMVersion==0x151)
 8007ae8:	8833      	ldrh	r3, [r6, #0]
 8007aea:	b29b      	uxth	r3, r3
 8007aec:	f240 1251 	movw	r2, #337	; 0x151
 8007af0:	4293      	cmp	r3, r2
 8007af2:	d174      	bne.n	8007bde <main+0x1fa>
	  MemCim.value = 127;
 8007af4:	227f      	movs	r2, #127	; 0x7f
 8007af6:	602a      	str	r2, [r5, #0]
	  HAL_TIM_Base_Start_IT(&htim6);
 8007af8:	4875      	ldr	r0, [pc, #468]	; (8007cd0 <main+0x2ec>)
 8007afa:	f7fb faae 	bl	800305a <HAL_TIM_Base_Start_IT>
	unsigned char FCount = 0, FCount2 = 0;
 8007afe:	f04f 0900 	mov.w	r9, #0
 8007b02:	272c      	movs	r7, #44	; 0x2c
 8007b04:	e152      	b.n	8007dac <main+0x3c8>
		   if (finfo.fattrib & AM_ARC)
 8007b06:	4b6a      	ldr	r3, [pc, #424]	; (8007cb0 <main+0x2cc>)
 8007b08:	7a1b      	ldrb	r3, [r3, #8]
 8007b0a:	f013 0f20 	tst.w	r3, #32
 8007b0e:	d035      	beq.n	8007b7c <main+0x198>
			 if(!finfo.fname[0]) break;
 8007b10:	4b67      	ldr	r3, [pc, #412]	; (8007cb0 <main+0x2cc>)
 8007b12:	7a5b      	ldrb	r3, [r3, #9]
 8007b14:	2b00      	cmp	r3, #0
 8007b16:	d0d2      	beq.n	8007abe <main+0xda>
			 FnameCharCount = strlen(finfo.lfname) > 32 ? 32 : strlen(finfo.lfname);
 8007b18:	4b65      	ldr	r3, [pc, #404]	; (8007cb0 <main+0x2cc>)
 8007b1a:	699e      	ldr	r6, [r3, #24]
 8007b1c:	4630      	mov	r0, r6
 8007b1e:	f7f8 fb81 	bl	8000224 <strlen>
 8007b22:	2820      	cmp	r0, #32
 8007b24:	d831      	bhi.n	8007b8a <main+0x1a6>
 8007b26:	b2c2      	uxtb	r2, r0
			 if(FnameCharCount>1)
 8007b28:	2a01      	cmp	r2, #1
 8007b2a:	d930      	bls.n	8007b8e <main+0x1aa>
				 memcpy(FileName[FCount++], finfo.lfname, FnameCharCount+1);
 8007b2c:	1c65      	adds	r5, r4, #1
 8007b2e:	b2ed      	uxtb	r5, r5
 8007b30:	3201      	adds	r2, #1
 8007b32:	4631      	mov	r1, r6
 8007b34:	f60d 1368 	addw	r3, sp, #2408	; 0x968
 8007b38:	eb03 1044 	add.w	r0, r3, r4, lsl #5
 8007b3c:	f001 fd80 	bl	8009640 <memcpy>
				 memcpy(FileSortName[FCount2++], finfo.fname, strlen(finfo.fname)+1);
 8007b40:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8007b44:	00a3      	lsls	r3, r4, #2
 8007b46:	aa02      	add	r2, sp, #8
 8007b48:	18d4      	adds	r4, r2, r3
 8007b4a:	4e62      	ldr	r6, [pc, #392]	; (8007cd4 <main+0x2f0>)
 8007b4c:	4630      	mov	r0, r6
 8007b4e:	f7f8 fb69 	bl	8000224 <strlen>
 8007b52:	1c42      	adds	r2, r0, #1
 8007b54:	4631      	mov	r1, r6
 8007b56:	4620      	mov	r0, r4
 8007b58:	f001 fd72 	bl	8009640 <memcpy>
				 memcpy(FileName[FCount++], finfo.lfname, FnameCharCount+1);
 8007b5c:	462c      	mov	r4, r5
			 FileName[FCount-1][29] = finfo.fsize>>16;
 8007b5e:	1e63      	subs	r3, r4, #1
 8007b60:	4a53      	ldr	r2, [pc, #332]	; (8007cb0 <main+0x2cc>)
 8007b62:	6812      	ldr	r2, [r2, #0]
 8007b64:	0c11      	lsrs	r1, r2, #16
 8007b66:	f60d 1068 	addw	r0, sp, #2408	; 0x968
 8007b6a:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 8007b6e:	7759      	strb	r1, [r3, #29]
			 FileName[FCount-1][30] = finfo.fsize>>8;
 8007b70:	0a11      	lsrs	r1, r2, #8
 8007b72:	7799      	strb	r1, [r3, #30]
			 FileName[FCount-1][31] = finfo.fsize;
 8007b74:	77da      	strb	r2, [r3, #31]
			 f_close(&MyFile);
 8007b76:	4858      	ldr	r0, [pc, #352]	; (8007cd8 <main+0x2f4>)
 8007b78:	f7ff fc16 	bl	80073a8 <f_close>
		 while (f_readdir(&dirs, &finfo) == FR_OK)
 8007b7c:	494c      	ldr	r1, [pc, #304]	; (8007cb0 <main+0x2cc>)
 8007b7e:	4851      	ldr	r0, [pc, #324]	; (8007cc4 <main+0x2e0>)
 8007b80:	f7ff fc92 	bl	80074a8 <f_readdir>
 8007b84:	2800      	cmp	r0, #0
 8007b86:	d0be      	beq.n	8007b06 <main+0x122>
 8007b88:	e799      	b.n	8007abe <main+0xda>
			 FnameCharCount = strlen(finfo.lfname) > 32 ? 32 : strlen(finfo.lfname);
 8007b8a:	2220      	movs	r2, #32
 8007b8c:	e7cc      	b.n	8007b28 <main+0x144>
				 memcpy(FileName[FCount++], finfo.fname, strlen(finfo.fname)+1);
 8007b8e:	1c66      	adds	r6, r4, #1
 8007b90:	b2f6      	uxtb	r6, r6
 8007b92:	f60d 1368 	addw	r3, sp, #2408	; 0x968
 8007b96:	eb03 1744 	add.w	r7, r3, r4, lsl #5
 8007b9a:	4d4e      	ldr	r5, [pc, #312]	; (8007cd4 <main+0x2f0>)
 8007b9c:	4628      	mov	r0, r5
 8007b9e:	f7f8 fb41 	bl	8000224 <strlen>
 8007ba2:	1c42      	adds	r2, r0, #1
 8007ba4:	4629      	mov	r1, r5
 8007ba6:	4638      	mov	r0, r7
 8007ba8:	f001 fd4a 	bl	8009640 <memcpy>
				 memcpy(FileSortName[FCount2++], finfo.fname, strlen(finfo.fname)+1);
 8007bac:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8007bb0:	00a3      	lsls	r3, r4, #2
 8007bb2:	aa02      	add	r2, sp, #8
 8007bb4:	18d4      	adds	r4, r2, r3
 8007bb6:	4628      	mov	r0, r5
 8007bb8:	f7f8 fb34 	bl	8000224 <strlen>
 8007bbc:	1c42      	adds	r2, r0, #1
 8007bbe:	4629      	mov	r1, r5
 8007bc0:	4620      	mov	r0, r4
 8007bc2:	f001 fd3d 	bl	8009640 <memcpy>
				 memcpy(FileName[FCount++], finfo.fname, strlen(finfo.fname)+1);
 8007bc6:	4634      	mov	r4, r6
 8007bc8:	e7c9      	b.n	8007b5e <main+0x17a>
 8007bca:	2400      	movs	r4, #0
 8007bcc:	e7d6      	b.n	8007b7c <main+0x198>
		HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, SET);
 8007bce:	2201      	movs	r2, #1
 8007bd0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007bd4:	4841      	ldr	r0, [pc, #260]	; (8007cdc <main+0x2f8>)
 8007bd6:	f7f8 fcf3 	bl	80005c0 <HAL_GPIO_WritePin>
	unsigned char FCount = 0, FCount2 = 0;
 8007bda:	2400      	movs	r4, #0
 8007bdc:	e76f      	b.n	8007abe <main+0xda>
	  MemCim.value = 63;
 8007bde:	223f      	movs	r2, #63	; 0x3f
 8007be0:	4b39      	ldr	r3, [pc, #228]	; (8007cc8 <main+0x2e4>)
 8007be2:	601a      	str	r2, [r3, #0]
	  HAL_TIM_Base_Start_IT(&htim6);
 8007be4:	483a      	ldr	r0, [pc, #232]	; (8007cd0 <main+0x2ec>)
 8007be6:	f7fb fa38 	bl	800305a <HAL_TIM_Base_Start_IT>
 8007bea:	e788      	b.n	8007afe <main+0x11a>
				  SSD1306_Puts ("File step..", &Font_7x10, 1);
 8007bec:	2201      	movs	r2, #1
 8007bee:	492c      	ldr	r1, [pc, #176]	; (8007ca0 <main+0x2bc>)
 8007bf0:	483b      	ldr	r0, [pc, #236]	; (8007ce0 <main+0x2fc>)
 8007bf2:	f000 fc4d 	bl	8008490 <SSD1306_Puts>
			  SSD1306_UpdateScreen();
 8007bf6:	f000 fc8d 	bl	8008514 <SSD1306_UpdateScreen>
			  HAL_Delay(100);
 8007bfa:	2064      	movs	r0, #100	; 0x64
 8007bfc:	f7f8 fb64 	bl	80002c8 <HAL_Delay>
			  i++;
 8007c00:	3501      	adds	r5, #1
 8007c02:	b2ad      	uxth	r5, r5
			  if(i>80) i=0;
 8007c04:	2d50      	cmp	r5, #80	; 0x50
 8007c06:	d900      	bls.n	8007c0a <main+0x226>
 8007c08:	2500      	movs	r5, #0
		  while(!(GOMB_Pin_GPIO_Port->IDR & GOMB_Pin_Pin))
 8007c0a:	4b36      	ldr	r3, [pc, #216]	; (8007ce4 <main+0x300>)
 8007c0c:	689b      	ldr	r3, [r3, #8]
 8007c0e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8007c12:	d173      	bne.n	8007cfc <main+0x318>
			  SSD1306_GotoXY (0,0);
 8007c14:	2100      	movs	r1, #0
 8007c16:	4608      	mov	r0, r1
 8007c18:	f000 fbe4 	bl	80083e4 <SSD1306_GotoXY>
			  SSD1306_Puts ("                   ", &Font_7x10, 1);
 8007c1c:	2201      	movs	r2, #1
 8007c1e:	4920      	ldr	r1, [pc, #128]	; (8007ca0 <main+0x2bc>)
 8007c20:	4831      	ldr	r0, [pc, #196]	; (8007ce8 <main+0x304>)
 8007c22:	f000 fc35 	bl	8008490 <SSD1306_Puts>
			  SSD1306_GotoXY (0,0);
 8007c26:	2100      	movs	r1, #0
 8007c28:	4608      	mov	r0, r1
 8007c2a:	f000 fbdb 	bl	80083e4 <SSD1306_GotoXY>
			  if(i<=10)
 8007c2e:	2d0a      	cmp	r5, #10
 8007c30:	d9dc      	bls.n	8007bec <main+0x208>
			  else if(i>10 && i<=30)
 8007c32:	f1a5 030b 	sub.w	r3, r5, #11
 8007c36:	b29b      	uxth	r3, r3
 8007c38:	2b13      	cmp	r3, #19
 8007c3a:	d90c      	bls.n	8007c56 <main+0x272>
			  else if(i>30 && i<=40)
 8007c3c:	f1a5 031f 	sub.w	r3, r5, #31
 8007c40:	b29b      	uxth	r3, r3
 8007c42:	2b09      	cmp	r3, #9
 8007c44:	d916      	bls.n	8007c74 <main+0x290>
			  else if(i>40)
 8007c46:	2d28      	cmp	r5, #40	; 0x28
 8007c48:	d9d5      	bls.n	8007bf6 <main+0x212>
				  SSD1306_Puts ("File upload!", &Font_7x10, 1);
 8007c4a:	2201      	movs	r2, #1
 8007c4c:	4914      	ldr	r1, [pc, #80]	; (8007ca0 <main+0x2bc>)
 8007c4e:	4827      	ldr	r0, [pc, #156]	; (8007cec <main+0x308>)
 8007c50:	f000 fc1e 	bl	8008490 <SSD1306_Puts>
 8007c54:	e7cf      	b.n	8007bf6 <main+0x212>
				  sprintf(StrTemp, "Step KHz: %02iKHz", Khz);
 8007c56:	463a      	mov	r2, r7
 8007c58:	4925      	ldr	r1, [pc, #148]	; (8007cf0 <main+0x30c>)
 8007c5a:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007c5e:	3028      	adds	r0, #40	; 0x28
 8007c60:	f001 fd02 	bl	8009668 <siprintf>
				  SSD1306_Puts (StrTemp, &Font_7x10, 1);
 8007c64:	2201      	movs	r2, #1
 8007c66:	490e      	ldr	r1, [pc, #56]	; (8007ca0 <main+0x2bc>)
 8007c68:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007c6c:	3028      	adds	r0, #40	; 0x28
 8007c6e:	f000 fc0f 	bl	8008490 <SSD1306_Puts>
 8007c72:	e7c0      	b.n	8007bf6 <main+0x212>
				  sprintf(StrTemp, "Step freq. %03iMHz", (uint32_t)HAL_RCC_GetHCLKFreq()/1000000);
 8007c74:	f7fa f81e 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8007c78:	4a1e      	ldr	r2, [pc, #120]	; (8007cf4 <main+0x310>)
 8007c7a:	fba2 3200 	umull	r3, r2, r2, r0
 8007c7e:	0c92      	lsrs	r2, r2, #18
 8007c80:	491d      	ldr	r1, [pc, #116]	; (8007cf8 <main+0x314>)
 8007c82:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007c86:	3028      	adds	r0, #40	; 0x28
 8007c88:	f001 fcee 	bl	8009668 <siprintf>
				  SSD1306_Puts (StrTemp, &Font_7x10, 1);
 8007c8c:	2201      	movs	r2, #1
 8007c8e:	4904      	ldr	r1, [pc, #16]	; (8007ca0 <main+0x2bc>)
 8007c90:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007c94:	3028      	adds	r0, #40	; 0x28
 8007c96:	f000 fbfb 	bl	8008490 <SSD1306_Puts>
 8007c9a:	e7ac      	b.n	8007bf6 <main+0x212>
 8007c9c:	2000e6c0 	.word	0x2000e6c0
 8007ca0:	20000118 	.word	0x20000118
 8007ca4:	0800abb8 	.word	0x0800abb8
 8007ca8:	0800abcc 	.word	0x0800abcc
 8007cac:	0800abe0 	.word	0x0800abe0
 8007cb0:	20004aa0 	.word	0x20004aa0
 8007cb4:	2000043c 	.word	0x2000043c
 8007cb8:	0800abf0 	.word	0x0800abf0
 8007cbc:	20003a18 	.word	0x20003a18
 8007cc0:	2000053c 	.word	0x2000053c
 8007cc4:	200029f0 	.word	0x200029f0
 8007cc8:	2000e6e0 	.word	0x2000e6e0
 8007ccc:	2000cd58 	.word	0x2000cd58
 8007cd0:	2000cd14 	.word	0x2000cd14
 8007cd4:	20004aa9 	.word	0x20004aa9
 8007cd8:	2000d5e0 	.word	0x2000d5e0
 8007cdc:	40010800 	.word	0x40010800
 8007ce0:	0800ac08 	.word	0x0800ac08
 8007ce4:	40010c00 	.word	0x40010c00
 8007ce8:	0800abf4 	.word	0x0800abf4
 8007cec:	0800ac3c 	.word	0x0800ac3c
 8007cf0:	0800ac14 	.word	0x0800ac14
 8007cf4:	431bde83 	.word	0x431bde83
 8007cf8:	0800ac28 	.word	0x0800ac28
			SSD1306_GotoXY (0,0);
 8007cfc:	2100      	movs	r1, #0
 8007cfe:	4608      	mov	r0, r1
 8007d00:	f000 fb70 	bl	80083e4 <SSD1306_GotoXY>
			SSD1306_Puts ("VGM Player v3.0 ", &Font_7x10, 1);
 8007d04:	4ebf      	ldr	r6, [pc, #764]	; (8008004 <main+0x620>)
 8007d06:	2201      	movs	r2, #1
 8007d08:	4631      	mov	r1, r6
 8007d0a:	48bf      	ldr	r0, [pc, #764]	; (8008008 <main+0x624>)
 8007d0c:	f000 fbc0 	bl	8008490 <SSD1306_Puts>
			SSD1306_GotoXY (0,20);
 8007d10:	2114      	movs	r1, #20
 8007d12:	2000      	movs	r0, #0
 8007d14:	f000 fb66 	bl	80083e4 <SSD1306_GotoXY>
			SSD1306_Puts ("System Ready ", &Font_7x10, 1);
 8007d18:	2201      	movs	r2, #1
 8007d1a:	4631      	mov	r1, r6
 8007d1c:	48bb      	ldr	r0, [pc, #748]	; (800800c <main+0x628>)
 8007d1e:	f000 fbb7 	bl	8008490 <SSD1306_Puts>
			SSD1306_UpdateScreen();
 8007d22:	f000 fbf7 	bl	8008514 <SSD1306_UpdateScreen>
		  HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, RESET);
 8007d26:	2200      	movs	r2, #0
 8007d28:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007d2c:	48b8      	ldr	r0, [pc, #736]	; (8008010 <main+0x62c>)
 8007d2e:	f7f8 fc47 	bl	80005c0 <HAL_GPIO_WritePin>
		  if(i>30 && i<=40)	// 3-4s
 8007d32:	f1a5 031f 	sub.w	r3, r5, #31
 8007d36:	b29b      	uxth	r3, r3
 8007d38:	2b09      	cmp	r3, #9
 8007d3a:	d941      	bls.n	8007dc0 <main+0x3dc>
		  else if(i>10 && i<=30) // Ha 2 s 3 msodpercet nyomtuk
 8007d3c:	f1a5 030b 	sub.w	r3, r5, #11
 8007d40:	b29b      	uxth	r3, r3
 8007d42:	2b13      	cmp	r3, #19
 8007d44:	d954      	bls.n	8007df0 <main+0x40c>
		  if(i<=10)
 8007d46:	2d0a      	cmp	r5, #10
 8007d48:	f200 8096 	bhi.w	8007e78 <main+0x494>
			  if(FCount>FCount2) FCount = 0;
 8007d4c:	45a1      	cmp	r9, r4
 8007d4e:	f200 8091 	bhi.w	8007e74 <main+0x490>
 8007d52:	464d      	mov	r5, r9
				SSD1306_GotoXY (0,9);
 8007d54:	2109      	movs	r1, #9
 8007d56:	2000      	movs	r0, #0
 8007d58:	f000 fb44 	bl	80083e4 <SSD1306_GotoXY>
				SSD1306_Puts ("                   ", &Font_7x10, 1);
 8007d5c:	4ea9      	ldr	r6, [pc, #676]	; (8008004 <main+0x620>)
 8007d5e:	2201      	movs	r2, #1
 8007d60:	4631      	mov	r1, r6
 8007d62:	48ac      	ldr	r0, [pc, #688]	; (8008014 <main+0x630>)
 8007d64:	f000 fb94 	bl	8008490 <SSD1306_Puts>
				SSD1306_GotoXY (0,9);
 8007d68:	2109      	movs	r1, #9
 8007d6a:	2000      	movs	r0, #0
 8007d6c:	f000 fb3a 	bl	80083e4 <SSD1306_GotoXY>
				SSD1306_Puts (FileName[FCount++], &Font_7x10, 1);
 8007d70:	f105 0901 	add.w	r9, r5, #1
 8007d74:	fa5f f989 	uxtb.w	r9, r9
 8007d78:	2201      	movs	r2, #1
 8007d7a:	4631      	mov	r1, r6
 8007d7c:	f60d 1368 	addw	r3, sp, #2408	; 0x968
 8007d80:	eb03 1045 	add.w	r0, r3, r5, lsl #5
 8007d84:	f000 fb84 	bl	8008490 <SSD1306_Puts>
				SSD1306_UpdateScreen();
 8007d88:	f000 fbc4 	bl	8008514 <SSD1306_UpdateScreen>
		  HAL_TIM_Base_Start_IT(&htim6);
 8007d8c:	48a2      	ldr	r0, [pc, #648]	; (8008018 <main+0x634>)
 8007d8e:	f7fb f964 	bl	800305a <HAL_TIM_Base_Start_IT>
	  if(BuffRX_a[0] == 'd') {
 8007d92:	4ba2      	ldr	r3, [pc, #648]	; (800801c <main+0x638>)
 8007d94:	781b      	ldrb	r3, [r3, #0]
 8007d96:	2b64      	cmp	r3, #100	; 0x64
 8007d98:	f000 819e 	beq.w	80080d8 <main+0x6f4>
	  HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 8007d9c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007da0:	489b      	ldr	r0, [pc, #620]	; (8008010 <main+0x62c>)
 8007da2:	f7f8 fc13 	bl	80005cc <HAL_GPIO_TogglePin>
	  HAL_Delay(100);
 8007da6:	2064      	movs	r0, #100	; 0x64
 8007da8:	f7f8 fa8e 	bl	80002c8 <HAL_Delay>
	  if(!(GOMB_Pin_GPIO_Port->IDR & GOMB_Pin_Pin))
 8007dac:	4b9c      	ldr	r3, [pc, #624]	; (8008020 <main+0x63c>)
 8007dae:	689b      	ldr	r3, [r3, #8]
 8007db0:	f013 0f80 	tst.w	r3, #128	; 0x80
 8007db4:	d1ed      	bne.n	8007d92 <main+0x3ae>
		  HAL_TIM_Base_Stop_IT(&htim6);
 8007db6:	4898      	ldr	r0, [pc, #608]	; (8008018 <main+0x634>)
 8007db8:	f7fb f960 	bl	800307c <HAL_TIM_Base_Stop_IT>
		  i=0;
 8007dbc:	2500      	movs	r5, #0
		  while(!(GOMB_Pin_GPIO_Port->IDR & GOMB_Pin_Pin))
 8007dbe:	e724      	b.n	8007c0a <main+0x226>
			if((uint32_t)HAL_RCC_GetHCLKFreq() < 128000000)
 8007dc0:	f7f9 ff78 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8007dc4:	4b97      	ldr	r3, [pc, #604]	; (8008024 <main+0x640>)
 8007dc6:	4298      	cmp	r0, r3
 8007dc8:	d80a      	bhi.n	8007de0 <main+0x3fc>
				HAL_RCC_DeInit();
 8007dca:	f7f9 fc07 	bl	80015dc <HAL_RCC_DeInit>
				HAL_Delay(100);
 8007dce:	2064      	movs	r0, #100	; 0x64
 8007dd0:	f7f8 fa7a 	bl	80002c8 <HAL_Delay>
				SystemClock_Config_128MHz();
 8007dd4:	f7ff fdce 	bl	8007974 <SystemClock_Config_128MHz>
			HAL_Delay(100);
 8007dd8:	2064      	movs	r0, #100	; 0x64
 8007dda:	f7f8 fa75 	bl	80002c8 <HAL_Delay>
 8007dde:	e7b2      	b.n	8007d46 <main+0x362>
				HAL_RCC_DeInit();
 8007de0:	f7f9 fbfc 	bl	80015dc <HAL_RCC_DeInit>
				HAL_Delay(100);
 8007de4:	2064      	movs	r0, #100	; 0x64
 8007de6:	f7f8 fa6f 	bl	80002c8 <HAL_Delay>
				SystemClock_Config();
 8007dea:	f7ff fd59 	bl	80078a0 <SystemClock_Config>
 8007dee:	e7f3      	b.n	8007dd8 <main+0x3f4>
			if((uint32_t)HAL_RCC_GetHCLKFreq() > 72000000)
 8007df0:	f7f9 ff60 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8007df4:	4b8c      	ldr	r3, [pc, #560]	; (8008028 <main+0x644>)
 8007df6:	4298      	cmp	r0, r3
 8007df8:	d91f      	bls.n	8007e3a <main+0x456>
				if(htim6.Init.Period!=666)
 8007dfa:	4b87      	ldr	r3, [pc, #540]	; (8008018 <main+0x634>)
 8007dfc:	68da      	ldr	r2, [r3, #12]
 8007dfe:	f240 239a 	movw	r3, #666	; 0x29a
 8007e02:	429a      	cmp	r2, r3
 8007e04:	d00d      	beq.n	8007e22 <main+0x43e>
					htim6.Init.Period = 666;	// 48KHz
 8007e06:	461a      	mov	r2, r3
 8007e08:	4b83      	ldr	r3, [pc, #524]	; (8008018 <main+0x634>)
 8007e0a:	60da      	str	r2, [r3, #12]
					HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, SET);
 8007e0c:	2201      	movs	r2, #1
 8007e0e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007e12:	487f      	ldr	r0, [pc, #508]	; (8008010 <main+0x62c>)
 8007e14:	f7f8 fbd4 	bl	80005c0 <HAL_GPIO_WritePin>
					Khz = 48;
 8007e18:	2730      	movs	r7, #48	; 0x30
			HAL_TIM_Base_Init(&htim6);
 8007e1a:	487f      	ldr	r0, [pc, #508]	; (8008018 <main+0x634>)
 8007e1c:	f7fb fa6c 	bl	80032f8 <HAL_TIM_Base_Init>
 8007e20:	e791      	b.n	8007d46 <main+0x362>
					htim6.Init.Period = 725; // Alaprtelmezett 44.1KHz
 8007e22:	f240 22d5 	movw	r2, #725	; 0x2d5
 8007e26:	4b7c      	ldr	r3, [pc, #496]	; (8008018 <main+0x634>)
 8007e28:	60da      	str	r2, [r3, #12]
					HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, RESET);
 8007e2a:	2200      	movs	r2, #0
 8007e2c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007e30:	4877      	ldr	r0, [pc, #476]	; (8008010 <main+0x62c>)
 8007e32:	f7f8 fbc5 	bl	80005c0 <HAL_GPIO_WritePin>
					Khz = 44;
 8007e36:	272c      	movs	r7, #44	; 0x2c
 8007e38:	e7ef      	b.n	8007e1a <main+0x436>
				if(htim6.Init.Period!=749)
 8007e3a:	4b77      	ldr	r3, [pc, #476]	; (8008018 <main+0x634>)
 8007e3c:	68da      	ldr	r2, [r3, #12]
 8007e3e:	f240 23ed 	movw	r3, #749	; 0x2ed
 8007e42:	429a      	cmp	r2, r3
 8007e44:	d00a      	beq.n	8007e5c <main+0x478>
					htim6.Init.Period = 749;	// 48KHz
 8007e46:	461a      	mov	r2, r3
 8007e48:	4b73      	ldr	r3, [pc, #460]	; (8008018 <main+0x634>)
 8007e4a:	60da      	str	r2, [r3, #12]
					HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, SET);
 8007e4c:	2201      	movs	r2, #1
 8007e4e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007e52:	486f      	ldr	r0, [pc, #444]	; (8008010 <main+0x62c>)
 8007e54:	f7f8 fbb4 	bl	80005c0 <HAL_GPIO_WritePin>
					Khz = 48;
 8007e58:	2730      	movs	r7, #48	; 0x30
 8007e5a:	e7de      	b.n	8007e1a <main+0x436>
					htim6.Init.Period = 816; // Alaprtelmezett 44.1KHz
 8007e5c:	f44f 724c 	mov.w	r2, #816	; 0x330
 8007e60:	4b6d      	ldr	r3, [pc, #436]	; (8008018 <main+0x634>)
 8007e62:	60da      	str	r2, [r3, #12]
					HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, RESET);
 8007e64:	2200      	movs	r2, #0
 8007e66:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007e6a:	4869      	ldr	r0, [pc, #420]	; (8008010 <main+0x62c>)
 8007e6c:	f7f8 fba8 	bl	80005c0 <HAL_GPIO_WritePin>
					Khz = 44;
 8007e70:	272c      	movs	r7, #44	; 0x2c
 8007e72:	e7d2      	b.n	8007e1a <main+0x436>
			  if(FCount>FCount2) FCount = 0;
 8007e74:	2500      	movs	r5, #0
 8007e76:	e76d      	b.n	8007d54 <main+0x370>
		  else if(i>10 && i<=40) // 3-4s
 8007e78:	f1a5 030b 	sub.w	r3, r5, #11
 8007e7c:	b29b      	uxth	r3, r3
 8007e7e:	2b1d      	cmp	r3, #29
 8007e80:	d92e      	bls.n	8007ee0 <main+0x4fc>
		  else if(i>=40)	// -5s
 8007e82:	2d27      	cmp	r5, #39	; 0x27
 8007e84:	d982      	bls.n	8007d8c <main+0x3a8>
			  PSG_Silence();
 8007e86:	f001 f96d 	bl	8009164 <PSG_Silence>
				f_mount(&FatFs,"/",(BYTE)1);
 8007e8a:	2201      	movs	r2, #1
 8007e8c:	4967      	ldr	r1, [pc, #412]	; (800802c <main+0x648>)
 8007e8e:	4868      	ldr	r0, [pc, #416]	; (8008030 <main+0x64c>)
 8007e90:	f7fe ff94 	bl	8006dbc <f_mount>
				res = f_open(&MyFile, FileName[FCount-1], FA_OPEN_EXISTING | FA_READ);
 8007e94:	f109 31ff 	add.w	r1, r9, #4294967295
 8007e98:	4e66      	ldr	r6, [pc, #408]	; (8008034 <main+0x650>)
 8007e9a:	2201      	movs	r2, #1
 8007e9c:	f60d 1368 	addw	r3, sp, #2408	; 0x968
 8007ea0:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8007ea4:	4630      	mov	r0, r6
 8007ea6:	f7fe ffbb 	bl	8006e20 <f_open>
 8007eaa:	4605      	mov	r5, r0
 8007eac:	4b62      	ldr	r3, [pc, #392]	; (8008038 <main+0x654>)
 8007eae:	7018      	strb	r0, [r3, #0]
				memset(buffer, '\0', sizeof(buffer));
 8007eb0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8007eb4:	2100      	movs	r1, #0
 8007eb6:	4861      	ldr	r0, [pc, #388]	; (800803c <main+0x658>)
 8007eb8:	f001 fbcd 	bl	8009656 <memset>
				FSize = MyFile.fsize;
 8007ebc:	f241 030c 	movw	r3, #4108	; 0x100c
 8007ec0:	58f6      	ldr	r6, [r6, r3]
				if(res==FR_OK){
 8007ec2:	2d00      	cmp	r5, #0
 8007ec4:	f040 8093 	bne.w	8007fee <main+0x60a>
					EraseBlock = (FSize/0xFFFF)>0 ? ((FSize/0xFFFF)+1) : 1;
 8007ec8:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8007ecc:	429e      	cmp	r6, r3
 8007ece:	d922      	bls.n	8007f16 <main+0x532>
 8007ed0:	4d5b      	ldr	r5, [pc, #364]	; (8008040 <main+0x65c>)
 8007ed2:	fba5 3506 	umull	r3, r5, r5, r6
 8007ed6:	f3c5 35c7 	ubfx	r5, r5, #15, #8
 8007eda:	3501      	adds	r5, #1
 8007edc:	b2ed      	uxtb	r5, r5
 8007ede:	e01b      	b.n	8007f18 <main+0x534>
			SSD1306_GotoXY (0,0);
 8007ee0:	2100      	movs	r1, #0
 8007ee2:	4608      	mov	r0, r1
 8007ee4:	f000 fa7e 	bl	80083e4 <SSD1306_GotoXY>
			sprintf(StrTemp, "CP: %03iMHz F: %02iKHz", (uint32_t)HAL_RCC_GetHCLKFreq()/1000000, Khz);
 8007ee8:	f7f9 fee4 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8007eec:	4a55      	ldr	r2, [pc, #340]	; (8008044 <main+0x660>)
 8007eee:	fba2 3200 	umull	r3, r2, r2, r0
 8007ef2:	463b      	mov	r3, r7
 8007ef4:	0c92      	lsrs	r2, r2, #18
 8007ef6:	4954      	ldr	r1, [pc, #336]	; (8008048 <main+0x664>)
 8007ef8:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007efc:	3028      	adds	r0, #40	; 0x28
 8007efe:	f001 fbb3 	bl	8009668 <siprintf>
			SSD1306_Puts (StrTemp, &Font_7x10, 1);
 8007f02:	2201      	movs	r2, #1
 8007f04:	493f      	ldr	r1, [pc, #252]	; (8008004 <main+0x620>)
 8007f06:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007f0a:	3028      	adds	r0, #40	; 0x28
 8007f0c:	f000 fac0 	bl	8008490 <SSD1306_Puts>
			SSD1306_UpdateScreen();
 8007f10:	f000 fb00 	bl	8008514 <SSD1306_UpdateScreen>
 8007f14:	e73a      	b.n	8007d8c <main+0x3a8>
					EraseBlock = (FSize/0xFFFF)>0 ? ((FSize/0xFFFF)+1) : 1;
 8007f16:	2501      	movs	r5, #1
					MemCim.value = 0;
 8007f18:	2300      	movs	r3, #0
 8007f1a:	4a4c      	ldr	r2, [pc, #304]	; (800804c <main+0x668>)
 8007f1c:	6013      	str	r3, [r2, #0]
					for(i=0; i<=EraseBlock; ++i)
 8007f1e:	4698      	mov	r8, r3
 8007f20:	e010      	b.n	8007f44 <main+0x560>
						MemBlockErase64Kb(MemCim);
 8007f22:	f8df a128 	ldr.w	sl, [pc, #296]	; 800804c <main+0x668>
 8007f26:	f8da 0000 	ldr.w	r0, [sl]
 8007f2a:	f001 f809 	bl	8008f40 <MemBlockErase64Kb>
						MemCim.value += 0xFFFF;
 8007f2e:	f8da 3000 	ldr.w	r3, [sl]
 8007f32:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
 8007f36:	33ff      	adds	r3, #255	; 0xff
 8007f38:	f8ca 3000 	str.w	r3, [sl]
					for(i=0; i<=EraseBlock; ++i)
 8007f3c:	f108 0801 	add.w	r8, r8, #1
 8007f40:	fa1f f888 	uxth.w	r8, r8
 8007f44:	b2ab      	uxth	r3, r5
 8007f46:	4598      	cmp	r8, r3
 8007f48:	d9eb      	bls.n	8007f22 <main+0x53e>
					MemCim.value = 0;
 8007f4a:	2200      	movs	r2, #0
 8007f4c:	4b3f      	ldr	r3, [pc, #252]	; (800804c <main+0x668>)
 8007f4e:	601a      	str	r2, [r3, #0]
 8007f50:	e04d      	b.n	8007fee <main+0x60a>
					  for(int s=0; s<BufferArraySize; s++) BuffRX_a[s] = buffer[(i*BufferArraySize)+s];
 8007f52:	eb03 1285 	add.w	r2, r3, r5, lsl #6
 8007f56:	4939      	ldr	r1, [pc, #228]	; (800803c <main+0x658>)
 8007f58:	5c89      	ldrb	r1, [r1, r2]
 8007f5a:	4a30      	ldr	r2, [pc, #192]	; (800801c <main+0x638>)
 8007f5c:	54d1      	strb	r1, [r2, r3]
 8007f5e:	3301      	adds	r3, #1
 8007f60:	2b3f      	cmp	r3, #63	; 0x3f
 8007f62:	ddf6      	ble.n	8007f52 <main+0x56e>
					  memWriteW25Qxx(MemCim, BuffRX_a);
 8007f64:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 800801c <main+0x638>
 8007f68:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 800804c <main+0x668>
 8007f6c:	4651      	mov	r1, sl
 8007f6e:	f8d8 0000 	ldr.w	r0, [r8]
 8007f72:	f001 f81f 	bl	8008fb4 <memWriteW25Qxx>
					  memset(BuffRX_a, '\0', sizeof(BuffRX_a));
 8007f76:	2240      	movs	r2, #64	; 0x40
 8007f78:	2100      	movs	r1, #0
 8007f7a:	4650      	mov	r0, sl
 8007f7c:	f001 fb6b 	bl	8009656 <memset>
					  MemCim.value+=64;
 8007f80:	f8d8 3000 	ldr.w	r3, [r8]
 8007f84:	3340      	adds	r3, #64	; 0x40
 8007f86:	f8c8 3000 	str.w	r3, [r8]
				  for(i=0; i<(br/BufferArraySize); i++){
 8007f8a:	3501      	adds	r5, #1
 8007f8c:	b2ad      	uxth	r5, r5
 8007f8e:	4b30      	ldr	r3, [pc, #192]	; (8008050 <main+0x66c>)
 8007f90:	681b      	ldr	r3, [r3, #0]
 8007f92:	ebb5 1f93 	cmp.w	r5, r3, lsr #6
 8007f96:	d201      	bcs.n	8007f9c <main+0x5b8>
 8007f98:	2300      	movs	r3, #0
 8007f9a:	e7e1      	b.n	8007f60 <main+0x57c>
				  FSize -= br;
 8007f9c:	1af6      	subs	r6, r6, r3
					SSD1306_GotoXY (0,20);
 8007f9e:	2114      	movs	r1, #20
 8007fa0:	2000      	movs	r0, #0
 8007fa2:	f000 fa1f 	bl	80083e4 <SSD1306_GotoXY>
					SSD1306_Puts ("                   ", &Font_7x10, 1);
 8007fa6:	4d17      	ldr	r5, [pc, #92]	; (8008004 <main+0x620>)
 8007fa8:	2201      	movs	r2, #1
 8007faa:	4629      	mov	r1, r5
 8007fac:	4819      	ldr	r0, [pc, #100]	; (8008014 <main+0x630>)
 8007fae:	f000 fa6f 	bl	8008490 <SSD1306_Puts>
					SSD1306_GotoXY (0,20);
 8007fb2:	2114      	movs	r1, #20
 8007fb4:	2000      	movs	r0, #0
 8007fb6:	f000 fa15 	bl	80083e4 <SSD1306_GotoXY>
					sprintf(StrTemp, "FSize:%06ibyte", FSize);
 8007fba:	4632      	mov	r2, r6
 8007fbc:	4925      	ldr	r1, [pc, #148]	; (8008054 <main+0x670>)
 8007fbe:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007fc2:	3028      	adds	r0, #40	; 0x28
 8007fc4:	f001 fb50 	bl	8009668 <siprintf>
					SSD1306_Puts (StrTemp, &Font_7x10, 1);
 8007fc8:	2201      	movs	r2, #1
 8007fca:	4629      	mov	r1, r5
 8007fcc:	f50d 5009 	add.w	r0, sp, #8768	; 0x2240
 8007fd0:	3028      	adds	r0, #40	; 0x28
 8007fd2:	f000 fa5d 	bl	8008490 <SSD1306_Puts>
					SSD1306_UpdateScreen();
 8007fd6:	f000 fa9d 	bl	8008514 <SSD1306_UpdateScreen>
				  HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 8007fda:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007fde:	480c      	ldr	r0, [pc, #48]	; (8008010 <main+0x62c>)
 8007fe0:	f7f8 faf4 	bl	80005cc <HAL_GPIO_TogglePin>
				}while(FSize && res == FR_OK);
 8007fe4:	2e00      	cmp	r6, #0
 8007fe6:	d037      	beq.n	8008058 <main+0x674>
 8007fe8:	4b13      	ldr	r3, [pc, #76]	; (8008038 <main+0x654>)
 8007fea:	781b      	ldrb	r3, [r3, #0]
 8007fec:	bba3      	cbnz	r3, 8008058 <main+0x674>
				  res = f_read(&MyFile, buffer, sizeof(buffer), &br);
 8007fee:	4b18      	ldr	r3, [pc, #96]	; (8008050 <main+0x66c>)
 8007ff0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8007ff4:	4911      	ldr	r1, [pc, #68]	; (800803c <main+0x658>)
 8007ff6:	480f      	ldr	r0, [pc, #60]	; (8008034 <main+0x650>)
 8007ff8:	f7ff f826 	bl	8007048 <f_read>
 8007ffc:	4b0e      	ldr	r3, [pc, #56]	; (8008038 <main+0x654>)
 8007ffe:	7018      	strb	r0, [r3, #0]
				  for(i=0; i<(br/BufferArraySize); i++){
 8008000:	2500      	movs	r5, #0
 8008002:	e7c4      	b.n	8007f8e <main+0x5aa>
 8008004:	20000118 	.word	0x20000118
 8008008:	0800abcc 	.word	0x0800abcc
 800800c:	0800abe0 	.word	0x0800abe0
 8008010:	40010800 	.word	0x40010800
 8008014:	0800abf4 	.word	0x0800abf4
 8008018:	2000cd14 	.word	0x2000cd14
 800801c:	2000e61c 	.word	0x2000e61c
 8008020:	40010c00 	.word	0x40010c00
 8008024:	07a11fff 	.word	0x07a11fff
 8008028:	044aa200 	.word	0x044aa200
 800802c:	0800abf0 	.word	0x0800abf0
 8008030:	20003a18 	.word	0x20003a18
 8008034:	2000d5e0 	.word	0x2000d5e0
 8008038:	2000e6b8 	.word	0x2000e6b8
 800803c:	2000cac8 	.word	0x2000cac8
 8008040:	80008001 	.word	0x80008001
 8008044:	431bde83 	.word	0x431bde83
 8008048:	0800ac4c 	.word	0x0800ac4c
 800804c:	2000e6e0 	.word	0x2000e6e0
 8008050:	20004ac0 	.word	0x20004ac0
 8008054:	0800ac64 	.word	0x0800ac64
				f_close(&MyFile);
 8008058:	4899      	ldr	r0, [pc, #612]	; (80082c0 <main+0x8dc>)
 800805a:	f7ff f9a5 	bl	80073a8 <f_close>
				HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, RESET);
 800805e:	2200      	movs	r2, #0
 8008060:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008064:	4897      	ldr	r0, [pc, #604]	; (80082c4 <main+0x8e0>)
 8008066:	f7f8 faab 	bl	80005c0 <HAL_GPIO_WritePin>
				MemCim.value = 8;
 800806a:	4e97      	ldr	r6, [pc, #604]	; (80082c8 <main+0x8e4>)
 800806c:	2308      	movs	r3, #8
 800806e:	6033      	str	r3, [r6, #0]
				VGMVersion = MemRead(MemCim);
 8008070:	6830      	ldr	r0, [r6, #0]
 8008072:	f000 ff37 	bl	8008ee4 <MemRead>
 8008076:	b280      	uxth	r0, r0
 8008078:	4d94      	ldr	r5, [pc, #592]	; (80082cc <main+0x8e8>)
 800807a:	8028      	strh	r0, [r5, #0]
				MemCim.value++;
 800807c:	6833      	ldr	r3, [r6, #0]
 800807e:	3301      	adds	r3, #1
 8008080:	6033      	str	r3, [r6, #0]
				VGMVersion |= ((uint16_t)MemRead(MemCim))<<8;
 8008082:	6830      	ldr	r0, [r6, #0]
 8008084:	f000 ff2e 	bl	8008ee4 <MemRead>
 8008088:	882b      	ldrh	r3, [r5, #0]
 800808a:	b29b      	uxth	r3, r3
 800808c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008090:	b29b      	uxth	r3, r3
 8008092:	802b      	strh	r3, [r5, #0]
				if(VGMVersion==0x151) MemCim.value = 127;
 8008094:	882b      	ldrh	r3, [r5, #0]
 8008096:	b29b      	uxth	r3, r3
 8008098:	f240 1251 	movw	r2, #337	; 0x151
 800809c:	4293      	cmp	r3, r2
 800809e:	d018      	beq.n	80080d2 <main+0x6ee>
				else MemCim.value = 63;
 80080a0:	223f      	movs	r2, #63	; 0x3f
 80080a2:	4b89      	ldr	r3, [pc, #548]	; (80082c8 <main+0x8e4>)
 80080a4:	601a      	str	r2, [r3, #0]
				SSD1306_GotoXY (0,20);
 80080a6:	2114      	movs	r1, #20
 80080a8:	2000      	movs	r0, #0
 80080aa:	f000 f99b 	bl	80083e4 <SSD1306_GotoXY>
				SSD1306_Puts ("                   ", &Font_7x10, 1);
 80080ae:	4d88      	ldr	r5, [pc, #544]	; (80082d0 <main+0x8ec>)
 80080b0:	2201      	movs	r2, #1
 80080b2:	4629      	mov	r1, r5
 80080b4:	4887      	ldr	r0, [pc, #540]	; (80082d4 <main+0x8f0>)
 80080b6:	f000 f9eb 	bl	8008490 <SSD1306_Puts>
				SSD1306_GotoXY (0,20);
 80080ba:	2114      	movs	r1, #20
 80080bc:	2000      	movs	r0, #0
 80080be:	f000 f991 	bl	80083e4 <SSD1306_GotoXY>
				SSD1306_Puts ("Upload success!", &Font_7x10, 1);
 80080c2:	2201      	movs	r2, #1
 80080c4:	4629      	mov	r1, r5
 80080c6:	4884      	ldr	r0, [pc, #528]	; (80082d8 <main+0x8f4>)
 80080c8:	f000 f9e2 	bl	8008490 <SSD1306_Puts>
				SSD1306_UpdateScreen();
 80080cc:	f000 fa22 	bl	8008514 <SSD1306_UpdateScreen>
 80080d0:	e65c      	b.n	8007d8c <main+0x3a8>
				if(VGMVersion==0x151) MemCim.value = 127;
 80080d2:	227f      	movs	r2, #127	; 0x7f
 80080d4:	6032      	str	r2, [r6, #0]
 80080d6:	e7e6      	b.n	80080a6 <main+0x6c2>
		HAL_TIM_Base_Stop_IT(&htim6);
 80080d8:	4880      	ldr	r0, [pc, #512]	; (80082dc <main+0x8f8>)
 80080da:	f7fa ffcf 	bl	800307c <HAL_TIM_Base_Stop_IT>
		BuffRX_a[0] = '\0';
 80080de:	2500      	movs	r5, #0
 80080e0:	4b7f      	ldr	r3, [pc, #508]	; (80082e0 <main+0x8fc>)
 80080e2:	701d      	strb	r5, [r3, #0]
		PSG_Silence();
 80080e4:	f001 f83e 	bl	8009164 <PSG_Silence>
		DataSize = 0;
 80080e8:	4b7e      	ldr	r3, [pc, #504]	; (80082e4 <main+0x900>)
 80080ea:	601d      	str	r5, [r3, #0]
		BufferSize = 0;
 80080ec:	4b7e      	ldr	r3, [pc, #504]	; (80082e8 <main+0x904>)
 80080ee:	801d      	strh	r5, [r3, #0]
		BufferI=0;
 80080f0:	4b7e      	ldr	r3, [pc, #504]	; (80082ec <main+0x908>)
 80080f2:	801d      	strh	r5, [r3, #0]
		HAL_Delay(1);
 80080f4:	2001      	movs	r0, #1
 80080f6:	f7f8 f8e7 	bl	80002c8 <HAL_Delay>
		CMDTX[0] = 0x10;
 80080fa:	f50d 500a 	add.w	r0, sp, #8832	; 0x2280
 80080fe:	2310      	movs	r3, #16
 8008100:	f800 3d04 	strb.w	r3, [r0, #-4]!
		CDC_Transmit_FS((uint8_t *)CMDTX, 1);	// Kikldjk az OK visszajelzst az upload kdot
 8008104:	2101      	movs	r1, #1
 8008106:	f000 fc8f 	bl	8008a28 <CDC_Transmit_FS>
		while(DataSize<3);	// Amig nem jn meg a 3 adat
 800810a:	4b76      	ldr	r3, [pc, #472]	; (80082e4 <main+0x900>)
 800810c:	681b      	ldr	r3, [r3, #0]
 800810e:	2b02      	cmp	r3, #2
 8008110:	d9fb      	bls.n	800810a <main+0x726>
		DataSizePC = BuffRX_a[2];
 8008112:	4873      	ldr	r0, [pc, #460]	; (80082e0 <main+0x8fc>)
 8008114:	f890 8002 	ldrb.w	r8, [r0, #2]
		DataSizePC = DataSizePC<<8 | BuffRX_a[1];
 8008118:	7843      	ldrb	r3, [r0, #1]
 800811a:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
		DataSizePC = DataSizePC<<8 | BuffRX_a[0];
 800811e:	f890 8000 	ldrb.w	r8, [r0]
 8008122:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
		Maradek = DataSizePC%BufferArraySize;	// Hossz vge, ha nem pontosan egyel BufferArraySize
 8008126:	f008 0b3f 	and.w	fp, r8, #63	; 0x3f
		Pack = DataSizePC/BufferArraySize;		// Adat csomagok szma
 800812a:	f3c8 1a8f 	ubfx	sl, r8, #6, #16
		memset(BuffRX_a, '\0', sizeof(BuffRX_a));	//Trljk a buffer tartalmt
 800812e:	2540      	movs	r5, #64	; 0x40
 8008130:	462a      	mov	r2, r5
 8008132:	2100      	movs	r1, #0
 8008134:	f001 fa8f 	bl	8009656 <memset>
		memset(BuffRX_b, '\0', sizeof(BuffRX_b));	//Trljk a buffer tartalmt
 8008138:	462a      	mov	r2, r5
 800813a:	2100      	movs	r1, #0
 800813c:	486c      	ldr	r0, [pc, #432]	; (80082f0 <main+0x90c>)
 800813e:	f001 fa8a 	bl	8009656 <memset>
		bUffEr=1;
 8008142:	2201      	movs	r2, #1
 8008144:	4b6b      	ldr	r3, [pc, #428]	; (80082f4 <main+0x910>)
 8008146:	701a      	strb	r2, [r3, #0]
		DataSize = 0;
 8008148:	2300      	movs	r3, #0
 800814a:	4a66      	ldr	r2, [pc, #408]	; (80082e4 <main+0x900>)
 800814c:	6013      	str	r3, [r2, #0]
		BufferSize = 0;
 800814e:	4a66      	ldr	r2, [pc, #408]	; (80082e8 <main+0x904>)
 8008150:	8013      	strh	r3, [r2, #0]
		BufferI=0;
 8008152:	4a66      	ldr	r2, [pc, #408]	; (80082ec <main+0x908>)
 8008154:	8013      	strh	r3, [r2, #0]
		PackCount=0;
 8008156:	4a68      	ldr	r2, [pc, #416]	; (80082f8 <main+0x914>)
 8008158:	8013      	strh	r3, [r2, #0]
		MemCim.value = 0;
 800815a:	4a5b      	ldr	r2, [pc, #364]	; (80082c8 <main+0x8e4>)
 800815c:	6013      	str	r3, [r2, #0]
		EraseBlock = (DataSizePC/0xFFFF)>0 ? ((DataSizePC/0xFFFF)+1) : 1;
 800815e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008162:	4598      	cmp	r8, r3
 8008164:	d909      	bls.n	800817a <main+0x796>
 8008166:	4b65      	ldr	r3, [pc, #404]	; (80082fc <main+0x918>)
 8008168:	fba3 2308 	umull	r2, r3, r3, r8
 800816c:	f3c3 33c7 	ubfx	r3, r3, #15, #8
 8008170:	3301      	adds	r3, #1
 8008172:	b2db      	uxtb	r3, r3
 8008174:	9301      	str	r3, [sp, #4]
		for(i=0; i<=EraseBlock; ++i)
 8008176:	2500      	movs	r5, #0
 8008178:	e00d      	b.n	8008196 <main+0x7b2>
		EraseBlock = (DataSizePC/0xFFFF)>0 ? ((DataSizePC/0xFFFF)+1) : 1;
 800817a:	2301      	movs	r3, #1
 800817c:	9301      	str	r3, [sp, #4]
 800817e:	e7fa      	b.n	8008176 <main+0x792>
			MemBlockErase64Kb(MemCim);
 8008180:	4e51      	ldr	r6, [pc, #324]	; (80082c8 <main+0x8e4>)
 8008182:	6830      	ldr	r0, [r6, #0]
 8008184:	f000 fedc 	bl	8008f40 <MemBlockErase64Kb>
			MemCim.value += 0xFFFF;
 8008188:	6833      	ldr	r3, [r6, #0]
 800818a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
 800818e:	33ff      	adds	r3, #255	; 0xff
 8008190:	6033      	str	r3, [r6, #0]
		for(i=0; i<=EraseBlock; ++i)
 8008192:	3501      	adds	r5, #1
 8008194:	b2ad      	uxth	r5, r5
 8008196:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800819a:	429d      	cmp	r5, r3
 800819c:	d9f0      	bls.n	8008180 <main+0x79c>
		MemCim.value = 0;
 800819e:	2500      	movs	r5, #0
 80081a0:	4b49      	ldr	r3, [pc, #292]	; (80082c8 <main+0x8e4>)
 80081a2:	601d      	str	r5, [r3, #0]
		CMDTX[0] = 0xF0;
 80081a4:	f50d 500a 	add.w	r0, sp, #8832	; 0x2280
 80081a8:	23f0      	movs	r3, #240	; 0xf0
 80081aa:	f800 3d04 	strb.w	r3, [r0, #-4]!
		CDC_Transmit_FS((uint8_t *)CMDTX, 1);
 80081ae:	2101      	movs	r1, #1
 80081b0:	f000 fc3a 	bl	8008a28 <CDC_Transmit_FS>
		DataSize = 0;
 80081b4:	4b4b      	ldr	r3, [pc, #300]	; (80082e4 <main+0x900>)
 80081b6:	601d      	str	r5, [r3, #0]
		Upload=1;
 80081b8:	2501      	movs	r5, #1
		while(Upload){
 80081ba:	e031      	b.n	8008220 <main+0x83c>
				if((PackCount == Pack && Maradek == BufferSize))
 80081bc:	4b4e      	ldr	r3, [pc, #312]	; (80082f8 <main+0x914>)
 80081be:	881b      	ldrh	r3, [r3, #0]
 80081c0:	b29b      	uxth	r3, r3
 80081c2:	459a      	cmp	sl, r3
 80081c4:	d03e      	beq.n	8008244 <main+0x860>
					temp = BufferArraySize;
 80081c6:	2640      	movs	r6, #64	; 0x40
				bUffEr = !bUffEr;
 80081c8:	4a4a      	ldr	r2, [pc, #296]	; (80082f4 <main+0x910>)
 80081ca:	7813      	ldrb	r3, [r2, #0]
 80081cc:	fab3 f383 	clz	r3, r3
 80081d0:	095b      	lsrs	r3, r3, #5
 80081d2:	7013      	strb	r3, [r2, #0]
				BufferSize=0;
 80081d4:	2300      	movs	r3, #0
 80081d6:	4a44      	ldr	r2, [pc, #272]	; (80082e8 <main+0x904>)
 80081d8:	8013      	strh	r3, [r2, #0]
				BufferI=0;
 80081da:	4a44      	ldr	r2, [pc, #272]	; (80082ec <main+0x908>)
 80081dc:	8013      	strh	r3, [r2, #0]
				if(PackCount<=Pack){
 80081de:	4b46      	ldr	r3, [pc, #280]	; (80082f8 <main+0x914>)
 80081e0:	881b      	ldrh	r3, [r3, #0]
 80081e2:	b29b      	uxth	r3, r3
 80081e4:	459a      	cmp	sl, r3
 80081e6:	d23a      	bcs.n	800825e <main+0x87a>
				PackCount++;
 80081e8:	4a43      	ldr	r2, [pc, #268]	; (80082f8 <main+0x914>)
 80081ea:	8813      	ldrh	r3, [r2, #0]
 80081ec:	b29b      	uxth	r3, r3
 80081ee:	3301      	adds	r3, #1
 80081f0:	b29b      	uxth	r3, r3
 80081f2:	8013      	strh	r3, [r2, #0]
				if(!bUffEr){
 80081f4:	4b3f      	ldr	r3, [pc, #252]	; (80082f4 <main+0x910>)
 80081f6:	781b      	ldrb	r3, [r3, #0]
 80081f8:	2b00      	cmp	r3, #0
 80081fa:	d139      	bne.n	8008270 <main+0x88c>
					memWriteW25Qxx(MemCim, BuffRX_a);
 80081fc:	4938      	ldr	r1, [pc, #224]	; (80082e0 <main+0x8fc>)
 80081fe:	4b32      	ldr	r3, [pc, #200]	; (80082c8 <main+0x8e4>)
 8008200:	6818      	ldr	r0, [r3, #0]
 8008202:	f000 fed7 	bl	8008fb4 <memWriteW25Qxx>
				MemCim.value += temp;
 8008206:	4b30      	ldr	r3, [pc, #192]	; (80082c8 <main+0x8e4>)
 8008208:	681a      	ldr	r2, [r3, #0]
 800820a:	4416      	add	r6, r2
 800820c:	601e      	str	r6, [r3, #0]
				if(DataSizePC == DataSize && PackCount >= Pack)
 800820e:	4b35      	ldr	r3, [pc, #212]	; (80082e4 <main+0x900>)
 8008210:	681b      	ldr	r3, [r3, #0]
 8008212:	4598      	cmp	r8, r3
 8008214:	d032      	beq.n	800827c <main+0x898>
				HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);
 8008216:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800821a:	482a      	ldr	r0, [pc, #168]	; (80082c4 <main+0x8e0>)
 800821c:	f7f8 f9d6 	bl	80005cc <HAL_GPIO_TogglePin>
		while(Upload){
 8008220:	2d00      	cmp	r5, #0
 8008222:	d06d      	beq.n	8008300 <main+0x91c>
			if(BufferSize==BufferArraySize || (PackCount == Pack && Maradek == BufferSize)){		// Ha minden rendben van
 8008224:	4b30      	ldr	r3, [pc, #192]	; (80082e8 <main+0x904>)
 8008226:	881b      	ldrh	r3, [r3, #0]
 8008228:	b29b      	uxth	r3, r3
 800822a:	2b40      	cmp	r3, #64	; 0x40
 800822c:	d0c6      	beq.n	80081bc <main+0x7d8>
 800822e:	4b32      	ldr	r3, [pc, #200]	; (80082f8 <main+0x914>)
 8008230:	881b      	ldrh	r3, [r3, #0]
 8008232:	b29b      	uxth	r3, r3
 8008234:	459a      	cmp	sl, r3
 8008236:	d1f3      	bne.n	8008220 <main+0x83c>
 8008238:	4b2b      	ldr	r3, [pc, #172]	; (80082e8 <main+0x904>)
 800823a:	881b      	ldrh	r3, [r3, #0]
 800823c:	b29b      	uxth	r3, r3
 800823e:	459b      	cmp	fp, r3
 8008240:	d1ee      	bne.n	8008220 <main+0x83c>
 8008242:	e7bb      	b.n	80081bc <main+0x7d8>
				if((PackCount == Pack && Maradek == BufferSize))
 8008244:	4b28      	ldr	r3, [pc, #160]	; (80082e8 <main+0x904>)
 8008246:	881b      	ldrh	r3, [r3, #0]
 8008248:	b29b      	uxth	r3, r3
 800824a:	459b      	cmp	fp, r3
 800824c:	d001      	beq.n	8008252 <main+0x86e>
					temp = BufferArraySize;
 800824e:	2640      	movs	r6, #64	; 0x40
 8008250:	e7ba      	b.n	80081c8 <main+0x7e4>
					DataSize -= BufferArraySize;
 8008252:	4a24      	ldr	r2, [pc, #144]	; (80082e4 <main+0x900>)
 8008254:	6813      	ldr	r3, [r2, #0]
 8008256:	3b40      	subs	r3, #64	; 0x40
 8008258:	6013      	str	r3, [r2, #0]
					temp = Maradek;
 800825a:	465e      	mov	r6, fp
					DataSize -= BufferArraySize;
 800825c:	e7b4      	b.n	80081c8 <main+0x7e4>
					CMDTX[0] = 0x02;
 800825e:	f50d 500a 	add.w	r0, sp, #8832	; 0x2280
 8008262:	2302      	movs	r3, #2
 8008264:	f800 3d04 	strb.w	r3, [r0, #-4]!
					CDC_Transmit_FS((uint8_t *)CMDTX, 1); //strlen(CMDTX)-1);	// kikldjk a tovbb kdot
 8008268:	2101      	movs	r1, #1
 800826a:	f000 fbdd 	bl	8008a28 <CDC_Transmit_FS>
 800826e:	e7bb      	b.n	80081e8 <main+0x804>
					memWriteW25Qxx(MemCim, BuffRX_b);
 8008270:	491f      	ldr	r1, [pc, #124]	; (80082f0 <main+0x90c>)
 8008272:	4b15      	ldr	r3, [pc, #84]	; (80082c8 <main+0x8e4>)
 8008274:	6818      	ldr	r0, [r3, #0]
 8008276:	f000 fe9d 	bl	8008fb4 <memWriteW25Qxx>
 800827a:	e7c4      	b.n	8008206 <main+0x822>
				if(DataSizePC == DataSize && PackCount >= Pack)
 800827c:	4b1e      	ldr	r3, [pc, #120]	; (80082f8 <main+0x914>)
 800827e:	881b      	ldrh	r3, [r3, #0]
 8008280:	b29b      	uxth	r3, r3
 8008282:	459a      	cmp	sl, r3
 8008284:	d8c7      	bhi.n	8008216 <main+0x832>
					bUffEr = 1; 				// Alaprtelmezett buffer hasznlata
 8008286:	2101      	movs	r1, #1
 8008288:	4b1a      	ldr	r3, [pc, #104]	; (80082f4 <main+0x910>)
 800828a:	7019      	strb	r1, [r3, #0]
					BufferSize=0;
 800828c:	2500      	movs	r5, #0
 800828e:	4b16      	ldr	r3, [pc, #88]	; (80082e8 <main+0x904>)
 8008290:	801d      	strh	r5, [r3, #0]
					BufferI=0;
 8008292:	4b16      	ldr	r3, [pc, #88]	; (80082ec <main+0x908>)
 8008294:	801d      	strh	r5, [r3, #0]
					CMDTX[0] = 0x02;
 8008296:	f50d 500a 	add.w	r0, sp, #8832	; 0x2280
 800829a:	2302      	movs	r3, #2
 800829c:	f800 3d04 	strb.w	r3, [r0, #-4]!
					CDC_Transmit_FS((uint8_t *)CMDTX, 1);//strlen(CMDTX)-1);	// kikldjuk a tovbb kdot
 80082a0:	f000 fbc2 	bl	8008a28 <CDC_Transmit_FS>
					MemCim.value = 0;
 80082a4:	4b08      	ldr	r3, [pc, #32]	; (80082c8 <main+0x8e4>)
 80082a6:	601d      	str	r5, [r3, #0]
					memset(BuffRX_a, '\0', sizeof(BuffRX_a));	//Trljk a buffer tartalmt
 80082a8:	2640      	movs	r6, #64	; 0x40
 80082aa:	4632      	mov	r2, r6
 80082ac:	4629      	mov	r1, r5
 80082ae:	480c      	ldr	r0, [pc, #48]	; (80082e0 <main+0x8fc>)
 80082b0:	f001 f9d1 	bl	8009656 <memset>
					memset(BuffRX_b, '\0', sizeof(BuffRX_b));	//Trljk a buffer tartalmt
 80082b4:	4632      	mov	r2, r6
 80082b6:	4629      	mov	r1, r5
 80082b8:	480d      	ldr	r0, [pc, #52]	; (80082f0 <main+0x90c>)
 80082ba:	f001 f9cc 	bl	8009656 <memset>
 80082be:	e7aa      	b.n	8008216 <main+0x832>
 80082c0:	2000d5e0 	.word	0x2000d5e0
 80082c4:	40010800 	.word	0x40010800
 80082c8:	2000e6e0 	.word	0x2000e6e0
 80082cc:	2000cd58 	.word	0x2000cd58
 80082d0:	20000118 	.word	0x20000118
 80082d4:	0800abf4 	.word	0x0800abf4
 80082d8:	0800ac74 	.word	0x0800ac74
 80082dc:	2000cd14 	.word	0x2000cd14
 80082e0:	2000e61c 	.word	0x2000e61c
 80082e4:	2000e614 	.word	0x2000e614
 80082e8:	200029ec 	.word	0x200029ec
 80082ec:	2000e65c 	.word	0x2000e65c
 80082f0:	2000ccd0 	.word	0x2000ccd0
 80082f4:	20000121 	.word	0x20000121
 80082f8:	20000438 	.word	0x20000438
 80082fc:	80008001 	.word	0x80008001
		MemCim.value = 8;
 8008300:	4e16      	ldr	r6, [pc, #88]	; (800835c <main+0x978>)
 8008302:	2308      	movs	r3, #8
 8008304:	6033      	str	r3, [r6, #0]
		VGMVersion = MemRead(MemCim);
 8008306:	6830      	ldr	r0, [r6, #0]
 8008308:	f000 fdec 	bl	8008ee4 <MemRead>
 800830c:	b280      	uxth	r0, r0
 800830e:	4d14      	ldr	r5, [pc, #80]	; (8008360 <main+0x97c>)
 8008310:	8028      	strh	r0, [r5, #0]
		MemCim.value++;
 8008312:	6833      	ldr	r3, [r6, #0]
 8008314:	3301      	adds	r3, #1
 8008316:	6033      	str	r3, [r6, #0]
		VGMVersion |= ((uint16_t)MemRead(MemCim))<<8;
 8008318:	6830      	ldr	r0, [r6, #0]
 800831a:	f000 fde3 	bl	8008ee4 <MemRead>
 800831e:	882b      	ldrh	r3, [r5, #0]
 8008320:	b29b      	uxth	r3, r3
 8008322:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008326:	b29b      	uxth	r3, r3
 8008328:	802b      	strh	r3, [r5, #0]
		if(VGMVersion==0x151) MemCim.value = 127;
 800832a:	882b      	ldrh	r3, [r5, #0]
 800832c:	b29b      	uxth	r3, r3
 800832e:	f240 1251 	movw	r2, #337	; 0x151
 8008332:	4293      	cmp	r3, r2
 8008334:	d00e      	beq.n	8008354 <main+0x970>
		else MemCim.value = 63;
 8008336:	223f      	movs	r2, #63	; 0x3f
 8008338:	4b08      	ldr	r3, [pc, #32]	; (800835c <main+0x978>)
 800833a:	601a      	str	r2, [r3, #0]
		PCMLoad = 0;
 800833c:	2200      	movs	r2, #0
 800833e:	4b09      	ldr	r3, [pc, #36]	; (8008364 <main+0x980>)
 8008340:	701a      	strb	r2, [r3, #0]
		HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, RESET);
 8008342:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008346:	4808      	ldr	r0, [pc, #32]	; (8008368 <main+0x984>)
 8008348:	f7f8 f93a 	bl	80005c0 <HAL_GPIO_WritePin>
		HAL_TIM_Base_Start_IT(&htim6);
 800834c:	4807      	ldr	r0, [pc, #28]	; (800836c <main+0x988>)
 800834e:	f7fa fe84 	bl	800305a <HAL_TIM_Base_Start_IT>
 8008352:	e523      	b.n	8007d9c <main+0x3b8>
		if(VGMVersion==0x151) MemCim.value = 127;
 8008354:	227f      	movs	r2, #127	; 0x7f
 8008356:	6032      	str	r2, [r6, #0]
 8008358:	e7f0      	b.n	800833c <main+0x958>
 800835a:	bf00      	nop
 800835c:	2000e6e0 	.word	0x2000e6e0
 8008360:	2000cd58 	.word	0x2000cd58
 8008364:	2000e6c0 	.word	0x2000e6c0
 8008368:	40010800 	.word	0x40010800
 800836c:	2000cd14 	.word	0x2000cd14

08008370 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8008370:	4770      	bx	lr
	...

08008374 <SSD1306_Fill>:
	for (i = 0; i < sizeof(SSD1306_Buffer); i++) {
		SSD1306_Buffer[i] = ~SSD1306_Buffer[i];
	}
}

void SSD1306_Fill(SSD1306_COLOR_t color) {
 8008374:	b508      	push	{r3, lr}
	/* Set memory */
	memset(SSD1306_Buffer, (color == SSD1306_COLOR_BLACK) ? 0x00 : 0xFF, sizeof(SSD1306_Buffer));
 8008376:	b130      	cbz	r0, 8008386 <SSD1306_Fill+0x12>
 8008378:	21ff      	movs	r1, #255	; 0xff
 800837a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800837e:	4803      	ldr	r0, [pc, #12]	; (800838c <SSD1306_Fill+0x18>)
 8008380:	f001 f969 	bl	8009656 <memset>
 8008384:	bd08      	pop	{r3, pc}
 8008386:	2100      	movs	r1, #0
 8008388:	e7f7      	b.n	800837a <SSD1306_Fill+0x6>
 800838a:	bf00      	nop
 800838c:	20000558 	.word	0x20000558

08008390 <SSD1306_DrawPixel>:
}

void SSD1306_DrawPixel(uint16_t x, uint16_t y, SSD1306_COLOR_t color) {
	if (
 8008390:	287f      	cmp	r0, #127	; 0x7f
 8008392:	d815      	bhi.n	80083c0 <SSD1306_DrawPixel+0x30>
		x >= SSD1306_WIDTH ||
 8008394:	291f      	cmp	r1, #31
 8008396:	d813      	bhi.n	80083c0 <SSD1306_DrawPixel+0x30>
		/* Error */
		return;
	}
	
	/* Check if pixels are inverted */
	if (SSD1306.Inverted) {
 8008398:	4b10      	ldr	r3, [pc, #64]	; (80083dc <SSD1306_DrawPixel+0x4c>)
 800839a:	791b      	ldrb	r3, [r3, #4]
 800839c:	b113      	cbz	r3, 80083a4 <SSD1306_DrawPixel+0x14>
		color = (SSD1306_COLOR_t)!color;
 800839e:	fab2 f282 	clz	r2, r2
 80083a2:	0952      	lsrs	r2, r2, #5
	}
	
	/* Set color */
	if (color == SSD1306_COLOR_WHITE) {
 80083a4:	2a01      	cmp	r2, #1
 80083a6:	d00c      	beq.n	80083c2 <SSD1306_DrawPixel+0x32>
		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
	} else {
		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));
 80083a8:	08cb      	lsrs	r3, r1, #3
 80083aa:	eb00 10c3 	add.w	r0, r0, r3, lsl #7
 80083ae:	f001 0107 	and.w	r1, r1, #7
 80083b2:	2301      	movs	r3, #1
 80083b4:	408b      	lsls	r3, r1
 80083b6:	4a0a      	ldr	r2, [pc, #40]	; (80083e0 <SSD1306_DrawPixel+0x50>)
 80083b8:	5c11      	ldrb	r1, [r2, r0]
 80083ba:	ea21 0103 	bic.w	r1, r1, r3
 80083be:	5411      	strb	r1, [r2, r0]
 80083c0:	4770      	bx	lr
		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
 80083c2:	08cb      	lsrs	r3, r1, #3
 80083c4:	eb00 10c3 	add.w	r0, r0, r3, lsl #7
 80083c8:	f001 0107 	and.w	r1, r1, #7
 80083cc:	2301      	movs	r3, #1
 80083ce:	408b      	lsls	r3, r1
 80083d0:	4a03      	ldr	r2, [pc, #12]	; (80083e0 <SSD1306_DrawPixel+0x50>)
 80083d2:	5c11      	ldrb	r1, [r2, r0]
 80083d4:	4319      	orrs	r1, r3
 80083d6:	5411      	strb	r1, [r2, r0]
 80083d8:	4770      	bx	lr
 80083da:	bf00      	nop
 80083dc:	20000550 	.word	0x20000550
 80083e0:	20000558 	.word	0x20000558

080083e4 <SSD1306_GotoXY>:
	}
}

void SSD1306_GotoXY(uint16_t x, uint16_t y) {
	/* Set write pointers */
	SSD1306.CurrentX = x;
 80083e4:	4b01      	ldr	r3, [pc, #4]	; (80083ec <SSD1306_GotoXY+0x8>)
 80083e6:	8018      	strh	r0, [r3, #0]
	SSD1306.CurrentY = y;
 80083e8:	8059      	strh	r1, [r3, #2]
 80083ea:	4770      	bx	lr
 80083ec:	20000550 	.word	0x20000550

080083f0 <SSD1306_Putc>:
}

char SSD1306_Putc(char ch, FontDef_t* Font, SSD1306_COLOR_t color) {
 80083f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t i, b, j;
	
	/* Check available space in LCD */
	if (
		SSD1306_WIDTH <= (SSD1306.CurrentX + Font->FontWidth) ||
 80083f4:	4b25      	ldr	r3, [pc, #148]	; (800848c <SSD1306_Putc+0x9c>)
 80083f6:	881b      	ldrh	r3, [r3, #0]
 80083f8:	780c      	ldrb	r4, [r1, #0]
 80083fa:	4423      	add	r3, r4
	if (
 80083fc:	2b7f      	cmp	r3, #127	; 0x7f
 80083fe:	dc3f      	bgt.n	8008480 <SSD1306_Putc+0x90>
		SSD1306_HEIGHT <= (SSD1306.CurrentY + Font->FontHeight)
 8008400:	4b22      	ldr	r3, [pc, #136]	; (800848c <SSD1306_Putc+0x9c>)
 8008402:	885b      	ldrh	r3, [r3, #2]
 8008404:	784c      	ldrb	r4, [r1, #1]
 8008406:	4423      	add	r3, r4
		SSD1306_WIDTH <= (SSD1306.CurrentX + Font->FontWidth) ||
 8008408:	2b1f      	cmp	r3, #31
 800840a:	dc3c      	bgt.n	8008486 <SSD1306_Putc+0x96>
 800840c:	4690      	mov	r8, r2
 800840e:	460e      	mov	r6, r1
 8008410:	4681      	mov	r9, r0
 8008412:	2500      	movs	r5, #0
 8008414:	e020      	b.n	8008458 <SSD1306_Putc+0x68>
		b = Font->data[(ch - 32) * Font->FontHeight + i];
		for (j = 0; j < Font->FontWidth; j++) {
			if ((b << j) & 0x8000) {
				SSD1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR_t) color);
			} else {
				SSD1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR_t)!color);
 8008416:	4b1d      	ldr	r3, [pc, #116]	; (800848c <SSD1306_Putc+0x9c>)
 8008418:	8818      	ldrh	r0, [r3, #0]
 800841a:	8859      	ldrh	r1, [r3, #2]
 800841c:	4429      	add	r1, r5
 800841e:	4420      	add	r0, r4
 8008420:	fab8 f288 	clz	r2, r8
 8008424:	0952      	lsrs	r2, r2, #5
 8008426:	b289      	uxth	r1, r1
 8008428:	b280      	uxth	r0, r0
 800842a:	f7ff ffb1 	bl	8008390 <SSD1306_DrawPixel>
		for (j = 0; j < Font->FontWidth; j++) {
 800842e:	3401      	adds	r4, #1
 8008430:	7833      	ldrb	r3, [r6, #0]
 8008432:	429c      	cmp	r4, r3
 8008434:	d20f      	bcs.n	8008456 <SSD1306_Putc+0x66>
			if ((b << j) & 0x8000) {
 8008436:	fa07 f304 	lsl.w	r3, r7, r4
 800843a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800843e:	d0ea      	beq.n	8008416 <SSD1306_Putc+0x26>
				SSD1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR_t) color);
 8008440:	4b12      	ldr	r3, [pc, #72]	; (800848c <SSD1306_Putc+0x9c>)
 8008442:	8818      	ldrh	r0, [r3, #0]
 8008444:	8859      	ldrh	r1, [r3, #2]
 8008446:	4429      	add	r1, r5
 8008448:	4420      	add	r0, r4
 800844a:	4642      	mov	r2, r8
 800844c:	b289      	uxth	r1, r1
 800844e:	b280      	uxth	r0, r0
 8008450:	f7ff ff9e 	bl	8008390 <SSD1306_DrawPixel>
 8008454:	e7eb      	b.n	800842e <SSD1306_Putc+0x3e>
	for (i = 0; i < Font->FontHeight; i++) {
 8008456:	3501      	adds	r5, #1
 8008458:	7872      	ldrb	r2, [r6, #1]
 800845a:	4295      	cmp	r5, r2
 800845c:	d208      	bcs.n	8008470 <SSD1306_Putc+0x80>
		b = Font->data[(ch - 32) * Font->FontHeight + i];
 800845e:	6871      	ldr	r1, [r6, #4]
 8008460:	f1a9 0320 	sub.w	r3, r9, #32
 8008464:	fb02 5303 	mla	r3, r2, r3, r5
 8008468:	f831 7013 	ldrh.w	r7, [r1, r3, lsl #1]
		for (j = 0; j < Font->FontWidth; j++) {
 800846c:	2400      	movs	r4, #0
 800846e:	e7df      	b.n	8008430 <SSD1306_Putc+0x40>
			}
		}
	}
	
	/* Increase pointer */
	SSD1306.CurrentX += Font->FontWidth;
 8008470:	7833      	ldrb	r3, [r6, #0]
 8008472:	4a06      	ldr	r2, [pc, #24]	; (800848c <SSD1306_Putc+0x9c>)
 8008474:	8811      	ldrh	r1, [r2, #0]
 8008476:	440b      	add	r3, r1
 8008478:	8013      	strh	r3, [r2, #0]
	
	/* Return character written */
	return ch;
 800847a:	4648      	mov	r0, r9
 800847c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return 0;
 8008480:	2000      	movs	r0, #0
 8008482:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008486:	2000      	movs	r0, #0
}
 8008488:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800848c:	20000550 	.word	0x20000550

08008490 <SSD1306_Puts>:

char SSD1306_Puts(char* str, FontDef_t* Font, SSD1306_COLOR_t color) {
 8008490:	b570      	push	{r4, r5, r6, lr}
 8008492:	4604      	mov	r4, r0
 8008494:	460e      	mov	r6, r1
 8008496:	4615      	mov	r5, r2
	/* Write characters */
	while (*str) {
 8008498:	7823      	ldrb	r3, [r4, #0]
 800849a:	b14b      	cbz	r3, 80084b0 <SSD1306_Puts+0x20>
		/* Write character by character */
		if (SSD1306_Putc(*str, Font, color) != *str) {
 800849c:	462a      	mov	r2, r5
 800849e:	4631      	mov	r1, r6
 80084a0:	4618      	mov	r0, r3
 80084a2:	f7ff ffa5 	bl	80083f0 <SSD1306_Putc>
 80084a6:	7823      	ldrb	r3, [r4, #0]
 80084a8:	4298      	cmp	r0, r3
 80084aa:	d101      	bne.n	80084b0 <SSD1306_Puts+0x20>
			/* Return error */
			return *str;
		}
		
		/* Increase string pointer */
		str++;
 80084ac:	3401      	adds	r4, #1
 80084ae:	e7f3      	b.n	8008498 <SSD1306_Puts+0x8>
	}
	
	/* Everything OK, zero should be returned */
	return *str;
}
 80084b0:	4618      	mov	r0, r3
 80084b2:	bd70      	pop	{r4, r5, r6, pc}

080084b4 <ssd1306_I2C_WriteMulti>:
	//while(p>0)
	//	p--;
	//MX_I2C1_Init();
}

void ssd1306_I2C_WriteMulti(uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {
 80084b4:	b530      	push	{r4, r5, lr}
 80084b6:	b0c3      	sub	sp, #268	; 0x10c
	uint8_t dt[256];
	dt[0] = reg;
 80084b8:	f88d 1008 	strb.w	r1, [sp, #8]
	uint8_t i;
	for(i = 0; i < count; i++)
 80084bc:	2100      	movs	r1, #0
 80084be:	e004      	b.n	80084ca <ssd1306_I2C_WriteMulti+0x16>
	dt[i+1] = data[i];
 80084c0:	1c4c      	adds	r4, r1, #1
 80084c2:	5c55      	ldrb	r5, [r2, r1]
 80084c4:	a902      	add	r1, sp, #8
 80084c6:	550d      	strb	r5, [r1, r4]
	for(i = 0; i < count; i++)
 80084c8:	b2e1      	uxtb	r1, r4
 80084ca:	b28c      	uxth	r4, r1
 80084cc:	429c      	cmp	r4, r3
 80084ce:	d3f7      	bcc.n	80084c0 <ssd1306_I2C_WriteMulti+0xc>
	HAL_I2C_Master_Transmit(&hi2c2, address, dt, count+1, 10);
 80084d0:	3301      	adds	r3, #1
 80084d2:	220a      	movs	r2, #10
 80084d4:	9200      	str	r2, [sp, #0]
 80084d6:	b29b      	uxth	r3, r3
 80084d8:	aa02      	add	r2, sp, #8
 80084da:	4601      	mov	r1, r0
 80084dc:	4802      	ldr	r0, [pc, #8]	; (80084e8 <ssd1306_I2C_WriteMulti+0x34>)
 80084de:	f7f8 fa97 	bl	8000a10 <HAL_I2C_Master_Transmit>
}
 80084e2:	b043      	add	sp, #268	; 0x10c
 80084e4:	bd30      	pop	{r4, r5, pc}
 80084e6:	bf00      	nop
 80084e8:	20004a48 	.word	0x20004a48

080084ec <ssd1306_I2C_Write>:


void ssd1306_I2C_Write(uint8_t address, uint8_t reg, uint8_t data) {
 80084ec:	b500      	push	{lr}
 80084ee:	b085      	sub	sp, #20
	uint8_t dt[2];
	dt[0] = reg;
 80084f0:	f88d 100c 	strb.w	r1, [sp, #12]
	dt[1] = data;
 80084f4:	f88d 200d 	strb.w	r2, [sp, #13]
	HAL_I2C_Master_Transmit(&hi2c2, address, dt, 2, 10);
 80084f8:	230a      	movs	r3, #10
 80084fa:	9300      	str	r3, [sp, #0]
 80084fc:	2302      	movs	r3, #2
 80084fe:	aa03      	add	r2, sp, #12
 8008500:	4601      	mov	r1, r0
 8008502:	4803      	ldr	r0, [pc, #12]	; (8008510 <ssd1306_I2C_Write+0x24>)
 8008504:	f7f8 fa84 	bl	8000a10 <HAL_I2C_Master_Transmit>
}
 8008508:	b005      	add	sp, #20
 800850a:	f85d fb04 	ldr.w	pc, [sp], #4
 800850e:	bf00      	nop
 8008510:	20004a48 	.word	0x20004a48

08008514 <SSD1306_UpdateScreen>:
void SSD1306_UpdateScreen(void) {
 8008514:	b510      	push	{r4, lr}
	for (m = 0; m < 8; m++) {
 8008516:	2400      	movs	r4, #0
 8008518:	e01a      	b.n	8008550 <SSD1306_UpdateScreen+0x3c>
		SSD1306_WRITECOMMAND(0xB0 + m);
 800851a:	f1a4 0250 	sub.w	r2, r4, #80	; 0x50
 800851e:	b2d2      	uxtb	r2, r2
 8008520:	2100      	movs	r1, #0
 8008522:	2078      	movs	r0, #120	; 0x78
 8008524:	f7ff ffe2 	bl	80084ec <ssd1306_I2C_Write>
		SSD1306_WRITECOMMAND(0x00);
 8008528:	2200      	movs	r2, #0
 800852a:	4611      	mov	r1, r2
 800852c:	2078      	movs	r0, #120	; 0x78
 800852e:	f7ff ffdd 	bl	80084ec <ssd1306_I2C_Write>
		SSD1306_WRITECOMMAND(0x10);
 8008532:	2210      	movs	r2, #16
 8008534:	2100      	movs	r1, #0
 8008536:	2078      	movs	r0, #120	; 0x78
 8008538:	f7ff ffd8 	bl	80084ec <ssd1306_I2C_Write>
		ssd1306_I2C_WriteMulti(SSD1306_I2C_ADDR, 0x40, &SSD1306_Buffer[SSD1306_WIDTH * m], SSD1306_WIDTH);
 800853c:	2380      	movs	r3, #128	; 0x80
 800853e:	4a06      	ldr	r2, [pc, #24]	; (8008558 <SSD1306_UpdateScreen+0x44>)
 8008540:	eb02 12c4 	add.w	r2, r2, r4, lsl #7
 8008544:	2140      	movs	r1, #64	; 0x40
 8008546:	2078      	movs	r0, #120	; 0x78
 8008548:	f7ff ffb4 	bl	80084b4 <ssd1306_I2C_WriteMulti>
	for (m = 0; m < 8; m++) {
 800854c:	3401      	adds	r4, #1
 800854e:	b2e4      	uxtb	r4, r4
 8008550:	2c07      	cmp	r4, #7
 8008552:	d9e2      	bls.n	800851a <SSD1306_UpdateScreen+0x6>
}
 8008554:	bd10      	pop	{r4, pc}
 8008556:	bf00      	nop
 8008558:	20000558 	.word	0x20000558

0800855c <SSD1306_Init>:
uint8_t SSD1306_Init(void) {
 800855c:	b508      	push	{r3, lr}
	while(HAL_I2C_IsDeviceReady(&hi2c2, SSD1306_I2C_ADDR, 1, 20000) != HAL_OK);
 800855e:	f644 6320 	movw	r3, #20000	; 0x4e20
 8008562:	2201      	movs	r2, #1
 8008564:	2178      	movs	r1, #120	; 0x78
 8008566:	4842      	ldr	r0, [pc, #264]	; (8008670 <SSD1306_Init+0x114>)
 8008568:	f7f8 fb0c 	bl	8000b84 <HAL_I2C_IsDeviceReady>
 800856c:	2800      	cmp	r0, #0
 800856e:	d1f6      	bne.n	800855e <SSD1306_Init+0x2>
 8008570:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8008574:	e000      	b.n	8008578 <SSD1306_Init+0x1c>
		p--;
 8008576:	3b01      	subs	r3, #1
	while(p>0)
 8008578:	2b00      	cmp	r3, #0
 800857a:	d1fc      	bne.n	8008576 <SSD1306_Init+0x1a>
	SSD1306_WRITECOMMAND(0xAE); //display off
 800857c:	22ae      	movs	r2, #174	; 0xae
 800857e:	2100      	movs	r1, #0
 8008580:	2078      	movs	r0, #120	; 0x78
 8008582:	f7ff ffb3 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xA8);
 8008586:	22a8      	movs	r2, #168	; 0xa8
 8008588:	2100      	movs	r1, #0
 800858a:	2078      	movs	r0, #120	; 0x78
 800858c:	f7ff ffae 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x3f);
 8008590:	223f      	movs	r2, #63	; 0x3f
 8008592:	2100      	movs	r1, #0
 8008594:	2078      	movs	r0, #120	; 0x78
 8008596:	f7ff ffa9 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xd3);
 800859a:	22d3      	movs	r2, #211	; 0xd3
 800859c:	2100      	movs	r1, #0
 800859e:	2078      	movs	r0, #120	; 0x78
 80085a0:	f7ff ffa4 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x00);
 80085a4:	2200      	movs	r2, #0
 80085a6:	4611      	mov	r1, r2
 80085a8:	2078      	movs	r0, #120	; 0x78
 80085aa:	f7ff ff9f 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x40);
 80085ae:	2240      	movs	r2, #64	; 0x40
 80085b0:	2100      	movs	r1, #0
 80085b2:	2078      	movs	r0, #120	; 0x78
 80085b4:	f7ff ff9a 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xa1);
 80085b8:	22a1      	movs	r2, #161	; 0xa1
 80085ba:	2100      	movs	r1, #0
 80085bc:	2078      	movs	r0, #120	; 0x78
 80085be:	f7ff ff95 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xc8);
 80085c2:	22c8      	movs	r2, #200	; 0xc8
 80085c4:	2100      	movs	r1, #0
 80085c6:	2078      	movs	r0, #120	; 0x78
 80085c8:	f7ff ff90 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xda);
 80085cc:	22da      	movs	r2, #218	; 0xda
 80085ce:	2100      	movs	r1, #0
 80085d0:	2078      	movs	r0, #120	; 0x78
 80085d2:	f7ff ff8b 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x20);
 80085d6:	2220      	movs	r2, #32
 80085d8:	2100      	movs	r1, #0
 80085da:	2078      	movs	r0, #120	; 0x78
 80085dc:	f7ff ff86 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x81);
 80085e0:	2281      	movs	r2, #129	; 0x81
 80085e2:	2100      	movs	r1, #0
 80085e4:	2078      	movs	r0, #120	; 0x78
 80085e6:	f7ff ff81 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x7f);
 80085ea:	227f      	movs	r2, #127	; 0x7f
 80085ec:	2100      	movs	r1, #0
 80085ee:	2078      	movs	r0, #120	; 0x78
 80085f0:	f7ff ff7c 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xa4);
 80085f4:	22a4      	movs	r2, #164	; 0xa4
 80085f6:	2100      	movs	r1, #0
 80085f8:	2078      	movs	r0, #120	; 0x78
 80085fa:	f7ff ff77 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xa6);
 80085fe:	22a6      	movs	r2, #166	; 0xa6
 8008600:	2100      	movs	r1, #0
 8008602:	2078      	movs	r0, #120	; 0x78
 8008604:	f7ff ff72 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xd5);
 8008608:	22d5      	movs	r2, #213	; 0xd5
 800860a:	2100      	movs	r1, #0
 800860c:	2078      	movs	r0, #120	; 0x78
 800860e:	f7ff ff6d 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x80);
 8008612:	2280      	movs	r2, #128	; 0x80
 8008614:	2100      	movs	r1, #0
 8008616:	2078      	movs	r0, #120	; 0x78
 8008618:	f7ff ff68 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x8d);
 800861c:	228d      	movs	r2, #141	; 0x8d
 800861e:	2100      	movs	r1, #0
 8008620:	2078      	movs	r0, #120	; 0x78
 8008622:	f7ff ff63 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x14);
 8008626:	2214      	movs	r2, #20
 8008628:	2100      	movs	r1, #0
 800862a:	2078      	movs	r0, #120	; 0x78
 800862c:	f7ff ff5e 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0xaf);
 8008630:	22af      	movs	r2, #175	; 0xaf
 8008632:	2100      	movs	r1, #0
 8008634:	2078      	movs	r0, #120	; 0x78
 8008636:	f7ff ff59 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x20);
 800863a:	2220      	movs	r2, #32
 800863c:	2100      	movs	r1, #0
 800863e:	2078      	movs	r0, #120	; 0x78
 8008640:	f7ff ff54 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(0x10);
 8008644:	2210      	movs	r2, #16
 8008646:	2100      	movs	r1, #0
 8008648:	2078      	movs	r0, #120	; 0x78
 800864a:	f7ff ff4f 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_WRITECOMMAND(SSD1306_DEACTIVATE_SCROLL);
 800864e:	222e      	movs	r2, #46	; 0x2e
 8008650:	2100      	movs	r1, #0
 8008652:	2078      	movs	r0, #120	; 0x78
 8008654:	f7ff ff4a 	bl	80084ec <ssd1306_I2C_Write>
	SSD1306_Fill(SSD1306_COLOR_BLACK);
 8008658:	2000      	movs	r0, #0
 800865a:	f7ff fe8b 	bl	8008374 <SSD1306_Fill>
	SSD1306_UpdateScreen();
 800865e:	f7ff ff59 	bl	8008514 <SSD1306_UpdateScreen>
	SSD1306.CurrentX = 0;
 8008662:	4b04      	ldr	r3, [pc, #16]	; (8008674 <SSD1306_Init+0x118>)
 8008664:	2200      	movs	r2, #0
 8008666:	801a      	strh	r2, [r3, #0]
	SSD1306.CurrentY = 0;
 8008668:	805a      	strh	r2, [r3, #2]
	SSD1306.Initialized = 1;
 800866a:	2001      	movs	r0, #1
 800866c:	7158      	strb	r0, [r3, #5]
}
 800866e:	bd08      	pop	{r3, pc}
 8008670:	20004a48 	.word	0x20004a48
 8008674:	20000550 	.word	0x20000550

08008678 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8008678:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 800867a:	4b0e      	ldr	r3, [pc, #56]	; (80086b4 <HAL_MspInit+0x3c>)
 800867c:	699a      	ldr	r2, [r3, #24]
 800867e:	f042 0201 	orr.w	r2, r2, #1
 8008682:	619a      	str	r2, [r3, #24]
 8008684:	699a      	ldr	r2, [r3, #24]
 8008686:	f002 0201 	and.w	r2, r2, #1
 800868a:	9200      	str	r2, [sp, #0]
 800868c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800868e:	69da      	ldr	r2, [r3, #28]
 8008690:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008694:	61da      	str	r2, [r3, #28]
 8008696:	69db      	ldr	r3, [r3, #28]
 8008698:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800869c:	9301      	str	r3, [sp, #4]
 800869e:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled 
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 80086a0:	4a05      	ldr	r2, [pc, #20]	; (80086b8 <HAL_MspInit+0x40>)
 80086a2:	6853      	ldr	r3, [r2, #4]
 80086a4:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 80086a8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80086ac:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80086ae:	b002      	add	sp, #8
 80086b0:	4770      	bx	lr
 80086b2:	bf00      	nop
 80086b4:	40021000 	.word	0x40021000
 80086b8:	40010000 	.word	0x40010000

080086bc <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 80086bc:	b510      	push	{r4, lr}
 80086be:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80086c0:	2300      	movs	r3, #0
 80086c2:	9302      	str	r3, [sp, #8]
 80086c4:	9303      	str	r3, [sp, #12]
 80086c6:	9304      	str	r3, [sp, #16]
 80086c8:	9305      	str	r3, [sp, #20]
  if(hi2c->Instance==I2C2)
 80086ca:	6802      	ldr	r2, [r0, #0]
 80086cc:	4b11      	ldr	r3, [pc, #68]	; (8008714 <HAL_I2C_MspInit+0x58>)
 80086ce:	429a      	cmp	r2, r3
 80086d0:	d001      	beq.n	80086d6 <HAL_I2C_MspInit+0x1a>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }

}
 80086d2:	b006      	add	sp, #24
 80086d4:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086d6:	4c10      	ldr	r4, [pc, #64]	; (8008718 <HAL_I2C_MspInit+0x5c>)
 80086d8:	69a3      	ldr	r3, [r4, #24]
 80086da:	f043 0308 	orr.w	r3, r3, #8
 80086de:	61a3      	str	r3, [r4, #24]
 80086e0:	69a3      	ldr	r3, [r4, #24]
 80086e2:	f003 0308 	and.w	r3, r3, #8
 80086e6:	9300      	str	r3, [sp, #0]
 80086e8:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80086ea:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80086ee:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80086f0:	2312      	movs	r3, #18
 80086f2:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80086f4:	2303      	movs	r3, #3
 80086f6:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80086f8:	a902      	add	r1, sp, #8
 80086fa:	4808      	ldr	r0, [pc, #32]	; (800871c <HAL_I2C_MspInit+0x60>)
 80086fc:	f7f7 fe60 	bl	80003c0 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 8008700:	69e3      	ldr	r3, [r4, #28]
 8008702:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8008706:	61e3      	str	r3, [r4, #28]
 8008708:	69e3      	ldr	r3, [r4, #28]
 800870a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800870e:	9301      	str	r3, [sp, #4]
 8008710:	9b01      	ldr	r3, [sp, #4]
}
 8008712:	e7de      	b.n	80086d2 <HAL_I2C_MspInit+0x16>
 8008714:	40005800 	.word	0x40005800
 8008718:	40021000 	.word	0x40021000
 800871c:	40010c00 	.word	0x40010c00

08008720 <HAL_SD_MspInit>:
* This function configures the hardware resources used in this example
* @param hsd: SD handle pointer
* @retval None
*/
void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8008720:	b530      	push	{r4, r5, lr}
 8008722:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008724:	2300      	movs	r3, #0
 8008726:	9304      	str	r3, [sp, #16]
 8008728:	9305      	str	r3, [sp, #20]
 800872a:	9306      	str	r3, [sp, #24]
 800872c:	9307      	str	r3, [sp, #28]
  if(hsd->Instance==SDIO)
 800872e:	6802      	ldr	r2, [r0, #0]
 8008730:	4b1a      	ldr	r3, [pc, #104]	; (800879c <HAL_SD_MspInit+0x7c>)
 8008732:	429a      	cmp	r2, r3
 8008734:	d001      	beq.n	800873a <HAL_SD_MspInit+0x1a>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }

}
 8008736:	b009      	add	sp, #36	; 0x24
 8008738:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_SDIO_CLK_ENABLE();
 800873a:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
 800873e:	695a      	ldr	r2, [r3, #20]
 8008740:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8008744:	615a      	str	r2, [r3, #20]
 8008746:	695a      	ldr	r2, [r3, #20]
 8008748:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 800874c:	9201      	str	r2, [sp, #4]
 800874e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8008750:	699a      	ldr	r2, [r3, #24]
 8008752:	f042 0210 	orr.w	r2, r2, #16
 8008756:	619a      	str	r2, [r3, #24]
 8008758:	699a      	ldr	r2, [r3, #24]
 800875a:	f002 0210 	and.w	r2, r2, #16
 800875e:	9202      	str	r2, [sp, #8]
 8008760:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008762:	699a      	ldr	r2, [r3, #24]
 8008764:	f042 0220 	orr.w	r2, r2, #32
 8008768:	619a      	str	r2, [r3, #24]
 800876a:	699b      	ldr	r3, [r3, #24]
 800876c:	f003 0320 	and.w	r3, r3, #32
 8008770:	9303      	str	r3, [sp, #12]
 8008772:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 8008774:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
 8008778:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800877a:	2502      	movs	r5, #2
 800877c:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800877e:	2403      	movs	r4, #3
 8008780:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8008782:	a904      	add	r1, sp, #16
 8008784:	4806      	ldr	r0, [pc, #24]	; (80087a0 <HAL_SD_MspInit+0x80>)
 8008786:	f7f7 fe1b 	bl	80003c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800878a:	2304      	movs	r3, #4
 800878c:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800878e:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008790:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008792:	a904      	add	r1, sp, #16
 8008794:	4803      	ldr	r0, [pc, #12]	; (80087a4 <HAL_SD_MspInit+0x84>)
 8008796:	f7f7 fe13 	bl	80003c0 <HAL_GPIO_Init>
}
 800879a:	e7cc      	b.n	8008736 <HAL_SD_MspInit+0x16>
 800879c:	40018000 	.word	0x40018000
 80087a0:	40011000 	.word	0x40011000
 80087a4:	40011400 	.word	0x40011400

080087a8 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80087a8:	b510      	push	{r4, lr}
 80087aa:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80087ac:	2300      	movs	r3, #0
 80087ae:	9302      	str	r3, [sp, #8]
 80087b0:	9303      	str	r3, [sp, #12]
 80087b2:	9304      	str	r3, [sp, #16]
 80087b4:	9305      	str	r3, [sp, #20]
  if(hspi->Instance==SPI1)
 80087b6:	6802      	ldr	r2, [r0, #0]
 80087b8:	4b1a      	ldr	r3, [pc, #104]	; (8008824 <HAL_SPI_MspInit+0x7c>)
 80087ba:	429a      	cmp	r2, r3
 80087bc:	d001      	beq.n	80087c2 <HAL_SPI_MspInit+0x1a>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 80087be:	b006      	add	sp, #24
 80087c0:	bd10      	pop	{r4, pc}
    __HAL_RCC_SPI1_CLK_ENABLE();
 80087c2:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
 80087c6:	699a      	ldr	r2, [r3, #24]
 80087c8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80087cc:	619a      	str	r2, [r3, #24]
 80087ce:	699a      	ldr	r2, [r3, #24]
 80087d0:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 80087d4:	9200      	str	r2, [sp, #0]
 80087d6:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80087d8:	699a      	ldr	r2, [r3, #24]
 80087da:	f042 0208 	orr.w	r2, r2, #8
 80087de:	619a      	str	r2, [r3, #24]
 80087e0:	699b      	ldr	r3, [r3, #24]
 80087e2:	f003 0308 	and.w	r3, r3, #8
 80087e6:	9301      	str	r3, [sp, #4]
 80087e8:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
 80087ea:	2328      	movs	r3, #40	; 0x28
 80087ec:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80087ee:	2302      	movs	r3, #2
 80087f0:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80087f2:	2303      	movs	r3, #3
 80087f4:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80087f6:	4c0c      	ldr	r4, [pc, #48]	; (8008828 <HAL_SPI_MspInit+0x80>)
 80087f8:	a902      	add	r1, sp, #8
 80087fa:	4620      	mov	r0, r4
 80087fc:	f7f7 fde0 	bl	80003c0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8008800:	2310      	movs	r3, #16
 8008802:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8008804:	2300      	movs	r3, #0
 8008806:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008808:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800880a:	a902      	add	r1, sp, #8
 800880c:	4620      	mov	r0, r4
 800880e:	f7f7 fdd7 	bl	80003c0 <HAL_GPIO_Init>
    __HAL_AFIO_REMAP_SPI1_ENABLE();
 8008812:	4a06      	ldr	r2, [pc, #24]	; (800882c <HAL_SPI_MspInit+0x84>)
 8008814:	6853      	ldr	r3, [r2, #4]
 8008816:	f043 63e0 	orr.w	r3, r3, #117440512	; 0x7000000
 800881a:	f043 0301 	orr.w	r3, r3, #1
 800881e:	6053      	str	r3, [r2, #4]
}
 8008820:	e7cd      	b.n	80087be <HAL_SPI_MspInit+0x16>
 8008822:	bf00      	nop
 8008824:	40013000 	.word	0x40013000
 8008828:	40010c00 	.word	0x40010c00
 800882c:	40010000 	.word	0x40010000

08008830 <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM6)
 8008830:	6802      	ldr	r2, [r0, #0]
 8008832:	4b0e      	ldr	r3, [pc, #56]	; (800886c <HAL_TIM_Base_MspInit+0x3c>)
 8008834:	429a      	cmp	r2, r3
 8008836:	d000      	beq.n	800883a <HAL_TIM_Base_MspInit+0xa>
 8008838:	4770      	bx	lr
{
 800883a:	b500      	push	{lr}
 800883c:	b083      	sub	sp, #12
  {
  /* USER CODE BEGIN TIM6_MspInit 0 */

  /* USER CODE END TIM6_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
 800883e:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8008842:	69da      	ldr	r2, [r3, #28]
 8008844:	f042 0210 	orr.w	r2, r2, #16
 8008848:	61da      	str	r2, [r3, #28]
 800884a:	69db      	ldr	r3, [r3, #28]
 800884c:	f003 0310 	and.w	r3, r3, #16
 8008850:	9301      	str	r3, [sp, #4]
 8008852:	9b01      	ldr	r3, [sp, #4]
    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_IRQn, 0, 0);
 8008854:	2200      	movs	r2, #0
 8008856:	4611      	mov	r1, r2
 8008858:	2036      	movs	r0, #54	; 0x36
 800885a:	f7f7 fd5b 	bl	8000314 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_IRQn);
 800885e:	2036      	movs	r0, #54	; 0x36
 8008860:	f7f7 fd8a 	bl	8000378 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }

}
 8008864:	b003      	add	sp, #12
 8008866:	f85d fb04 	ldr.w	pc, [sp], #4
 800886a:	bf00      	nop
 800886c:	40001000 	.word	0x40001000

08008870 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8008870:	4770      	bx	lr

08008872 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8008872:	e7fe      	b.n	8008872 <HardFault_Handler>

08008874 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8008874:	e7fe      	b.n	8008874 <MemManage_Handler>

08008876 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8008876:	e7fe      	b.n	8008876 <BusFault_Handler>

08008878 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8008878:	e7fe      	b.n	8008878 <UsageFault_Handler>

0800887a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800887a:	4770      	bx	lr

0800887c <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800887c:	4770      	bx	lr

0800887e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800887e:	4770      	bx	lr

08008880 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8008880:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8008882:	f7f7 fd0f 	bl	80002a4 <HAL_IncTick>
 8008886:	bd08      	pop	{r3, pc}

08008888 <USB_LP_CAN1_RX0_IRQHandler>:

/**
  * @brief This function handles USB low priority or CAN RX0 interrupts.
  */
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 8008888:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 800888a:	4802      	ldr	r0, [pc, #8]	; (8008894 <USB_LP_CAN1_RX0_IRQHandler+0xc>)
 800888c:	f7f8 fd4f 	bl	800132e <HAL_PCD_IRQHandler>
 8008890:	bd08      	pop	{r3, pc}
 8008892:	bf00      	nop
 8008894:	2000f1a8 	.word	0x2000f1a8

08008898 <TIM6_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt.
  */
void TIM6_IRQHandler(void)
{
 8008898:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM6_IRQn 0 */

  /* USER CODE END TIM6_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 800889a:	4802      	ldr	r0, [pc, #8]	; (80088a4 <TIM6_IRQHandler+0xc>)
 800889c:	f7fa fc08 	bl	80030b0 <HAL_TIM_IRQHandler>
 80088a0:	bd08      	pop	{r3, pc}
 80088a2:	bf00      	nop
 80088a4:	2000cd14 	.word	0x2000cd14

080088a8 <_sbrk>:
	}
	return len;
}

caddr_t _sbrk(int incr)
{
 80088a8:	b508      	push	{r3, lr}
 80088aa:	4603      	mov	r3, r0
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 80088ac:	4a0b      	ldr	r2, [pc, #44]	; (80088dc <_sbrk+0x34>)
 80088ae:	6812      	ldr	r2, [r2, #0]
 80088b0:	b142      	cbz	r2, 80088c4 <_sbrk+0x1c>
		heap_end = &end;

	prev_heap_end = heap_end;
 80088b2:	4a0a      	ldr	r2, [pc, #40]	; (80088dc <_sbrk+0x34>)
 80088b4:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 80088b6:	4403      	add	r3, r0
 80088b8:	466a      	mov	r2, sp
 80088ba:	4293      	cmp	r3, r2
 80088bc:	d806      	bhi.n	80088cc <_sbrk+0x24>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 80088be:	4a07      	ldr	r2, [pc, #28]	; (80088dc <_sbrk+0x34>)
 80088c0:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 80088c2:	bd08      	pop	{r3, pc}
		heap_end = &end;
 80088c4:	4906      	ldr	r1, [pc, #24]	; (80088e0 <_sbrk+0x38>)
 80088c6:	4a05      	ldr	r2, [pc, #20]	; (80088dc <_sbrk+0x34>)
 80088c8:	6011      	str	r1, [r2, #0]
 80088ca:	e7f2      	b.n	80088b2 <_sbrk+0xa>
		errno = ENOMEM;
 80088cc:	f000 fe8e 	bl	80095ec <__errno>
 80088d0:	230c      	movs	r3, #12
 80088d2:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 80088d4:	f04f 30ff 	mov.w	r0, #4294967295
 80088d8:	bd08      	pop	{r3, pc}
 80088da:	bf00      	nop
 80088dc:	20000758 	.word	0x20000758
 80088e0:	2000f618 	.word	0x2000f618

080088e4 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;
 80088e4:	4b0f      	ldr	r3, [pc, #60]	; (8008924 <SystemInit+0x40>)
 80088e6:	681a      	ldr	r2, [r3, #0]
 80088e8:	f042 0201 	orr.w	r2, r2, #1
 80088ec:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= 0xF8FF0000U;
 80088ee:	6859      	ldr	r1, [r3, #4]
 80088f0:	4a0d      	ldr	r2, [pc, #52]	; (8008928 <SystemInit+0x44>)
 80088f2:	400a      	ands	r2, r1
 80088f4:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= 0xF0FF0000U;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;
 80088f6:	681a      	ldr	r2, [r3, #0]
 80088f8:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80088fc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008900:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8008902:	681a      	ldr	r2, [r3, #0]
 8008904:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008908:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;
 800890a:	685a      	ldr	r2, [r3, #4]
 800890c:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8008910:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;
 8008912:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8008916:	609a      	str	r2, [r3, #8]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8008918:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800891c:	4b03      	ldr	r3, [pc, #12]	; (800892c <SystemInit+0x48>)
 800891e:	609a      	str	r2, [r3, #8]
 8008920:	4770      	bx	lr
 8008922:	bf00      	nop
 8008924:	40021000 	.word	0x40021000
 8008928:	f8ff0000 	.word	0xf8ff0000
 800892c:	e000ed00 	.word	0xe000ed00

08008930 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8008930:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 8008932:	2200      	movs	r2, #0
 8008934:	490f      	ldr	r1, [pc, #60]	; (8008974 <MX_USB_DEVICE_Init+0x44>)
 8008936:	4810      	ldr	r0, [pc, #64]	; (8008978 <MX_USB_DEVICE_Init+0x48>)
 8008938:	f7fb ff78 	bl	800482c <USBD_Init>
 800893c:	b970      	cbnz	r0, 800895c <MX_USB_DEVICE_Init+0x2c>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 800893e:	490f      	ldr	r1, [pc, #60]	; (800897c <MX_USB_DEVICE_Init+0x4c>)
 8008940:	480d      	ldr	r0, [pc, #52]	; (8008978 <MX_USB_DEVICE_Init+0x48>)
 8008942:	f7fb ff8a 	bl	800485a <USBD_RegisterClass>
 8008946:	b960      	cbnz	r0, 8008962 <MX_USB_DEVICE_Init+0x32>
  {
    Error_Handler();
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 8008948:	490d      	ldr	r1, [pc, #52]	; (8008980 <MX_USB_DEVICE_Init+0x50>)
 800894a:	480b      	ldr	r0, [pc, #44]	; (8008978 <MX_USB_DEVICE_Init+0x48>)
 800894c:	f7fb ff26 	bl	800479c <USBD_CDC_RegisterInterface>
 8008950:	b950      	cbnz	r0, 8008968 <MX_USB_DEVICE_Init+0x38>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8008952:	4809      	ldr	r0, [pc, #36]	; (8008978 <MX_USB_DEVICE_Init+0x48>)
 8008954:	f7fb ff88 	bl	8004868 <USBD_Start>
 8008958:	b948      	cbnz	r0, 800896e <MX_USB_DEVICE_Init+0x3e>
 800895a:	bd08      	pop	{r3, pc}
    Error_Handler();
 800895c:	f7ff fd08 	bl	8008370 <Error_Handler>
 8008960:	e7ed      	b.n	800893e <MX_USB_DEVICE_Init+0xe>
    Error_Handler();
 8008962:	f7ff fd05 	bl	8008370 <Error_Handler>
 8008966:	e7ef      	b.n	8008948 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 8008968:	f7ff fd02 	bl	8008370 <Error_Handler>
 800896c:	e7f1      	b.n	8008952 <MX_USB_DEVICE_Init+0x22>
  {
    Error_Handler();
 800896e:	f7ff fcff 	bl	8008370 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8008972:	e7f2      	b.n	800895a <MX_USB_DEVICE_Init+0x2a>
 8008974:	20000138 	.word	0x20000138
 8008978:	2000e6e4 	.word	0x2000e6e4
 800897c:	20000008 	.word	0x20000008
 8008980:	20000128 	.word	0x20000128

08008984 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 8008984:	2000      	movs	r0, #0
 8008986:	4770      	bx	lr

08008988 <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 8008988:	2000      	movs	r0, #0
 800898a:	4770      	bx	lr

0800898c <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 800898c:	b538      	push	{r3, r4, r5, lr}
 800898e:	460c      	mov	r4, r1
  /* USER CODE BEGIN 6 */
	//USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);

	if(bUffEr)
 8008990:	4b14      	ldr	r3, [pc, #80]	; (80089e4 <CDC_Receive_FS+0x58>)
 8008992:	781b      	ldrb	r3, [r3, #0]
 8008994:	b9e3      	cbnz	r3, 80089d0 <CDC_Receive_FS+0x44>
		memcpy((char*)BuffRX_a, (char*)Buf,*Len);
		BuffRX_a[*Len] = '\0';
	}
	else
	{
		memcpy((char*)BuffRX_b, (char*)Buf,*Len);
 8008996:	4d14      	ldr	r5, [pc, #80]	; (80089e8 <CDC_Receive_FS+0x5c>)
 8008998:	680a      	ldr	r2, [r1, #0]
 800899a:	4601      	mov	r1, r0
 800899c:	4628      	mov	r0, r5
 800899e:	f000 fe4f 	bl	8009640 <memcpy>
		BuffRX_b[*Len] = '\0';
 80089a2:	6823      	ldr	r3, [r4, #0]
 80089a4:	2200      	movs	r2, #0
 80089a6:	54ea      	strb	r2, [r5, r3]
	}
	BufferI += *Len;
 80089a8:	6821      	ldr	r1, [r4, #0]
 80089aa:	4a10      	ldr	r2, [pc, #64]	; (80089ec <CDC_Receive_FS+0x60>)
 80089ac:	8813      	ldrh	r3, [r2, #0]
 80089ae:	b29b      	uxth	r3, r3
 80089b0:	440b      	add	r3, r1
 80089b2:	b29b      	uxth	r3, r3
 80089b4:	8013      	strh	r3, [r2, #0]
	BufferSize = *Len;
 80089b6:	8822      	ldrh	r2, [r4, #0]
 80089b8:	4b0d      	ldr	r3, [pc, #52]	; (80089f0 <CDC_Receive_FS+0x64>)
 80089ba:	801a      	strh	r2, [r3, #0]
	DataSize += *Len;	// Adat forgalom szmolsa
 80089bc:	6823      	ldr	r3, [r4, #0]
 80089be:	4a0d      	ldr	r2, [pc, #52]	; (80089f4 <CDC_Receive_FS+0x68>)
 80089c0:	6811      	ldr	r1, [r2, #0]
 80089c2:	440b      	add	r3, r1
 80089c4:	6013      	str	r3, [r2, #0]

	USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 80089c6:	480c      	ldr	r0, [pc, #48]	; (80089f8 <CDC_Receive_FS+0x6c>)
 80089c8:	f7fb ff17 	bl	80047fa <USBD_CDC_ReceivePacket>
	return (USBD_OK);
  /* USER CODE END 6 */
}
 80089cc:	2000      	movs	r0, #0
 80089ce:	bd38      	pop	{r3, r4, r5, pc}
		memcpy((char*)BuffRX_a, (char*)Buf,*Len);
 80089d0:	4d0a      	ldr	r5, [pc, #40]	; (80089fc <CDC_Receive_FS+0x70>)
 80089d2:	680a      	ldr	r2, [r1, #0]
 80089d4:	4601      	mov	r1, r0
 80089d6:	4628      	mov	r0, r5
 80089d8:	f000 fe32 	bl	8009640 <memcpy>
		BuffRX_a[*Len] = '\0';
 80089dc:	6823      	ldr	r3, [r4, #0]
 80089de:	2200      	movs	r2, #0
 80089e0:	54ea      	strb	r2, [r5, r3]
 80089e2:	e7e1      	b.n	80089a8 <CDC_Receive_FS+0x1c>
 80089e4:	20000121 	.word	0x20000121
 80089e8:	2000ccd0 	.word	0x2000ccd0
 80089ec:	2000e65c 	.word	0x2000e65c
 80089f0:	200029ec 	.word	0x200029ec
 80089f4:	2000e614 	.word	0x2000e614
 80089f8:	2000e6e4 	.word	0x2000e6e4
 80089fc:	2000e61c 	.word	0x2000e61c

08008a00 <CDC_Init_FS>:
{
 8008a00:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8008a02:	4c06      	ldr	r4, [pc, #24]	; (8008a1c <CDC_Init_FS+0x1c>)
 8008a04:	2200      	movs	r2, #0
 8008a06:	4906      	ldr	r1, [pc, #24]	; (8008a20 <CDC_Init_FS+0x20>)
 8008a08:	4620      	mov	r0, r4
 8008a0a:	f7fb fece 	bl	80047aa <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8008a0e:	4905      	ldr	r1, [pc, #20]	; (8008a24 <CDC_Init_FS+0x24>)
 8008a10:	4620      	mov	r0, r4
 8008a12:	f7fb fed2 	bl	80047ba <USBD_CDC_SetRxBuffer>
}
 8008a16:	2000      	movs	r0, #0
 8008a18:	bd10      	pop	{r4, pc}
 8008a1a:	bf00      	nop
 8008a1c:	2000e6e4 	.word	0x2000e6e4
 8008a20:	2000eda8 	.word	0x2000eda8
 8008a24:	2000e9a8 	.word	0x2000e9a8

08008a28 <CDC_Transmit_FS>:
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8008a28:	4b09      	ldr	r3, [pc, #36]	; (8008a50 <CDC_Transmit_FS+0x28>)
 8008a2a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
  if (hcdc->TxState != 0){
 8008a2e:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8008a32:	b10b      	cbz	r3, 8008a38 <CDC_Transmit_FS+0x10>
    return USBD_BUSY;
 8008a34:	2001      	movs	r0, #1
 8008a36:	4770      	bx	lr
{
 8008a38:	b510      	push	{r4, lr}
 8008a3a:	460a      	mov	r2, r1
 8008a3c:	4601      	mov	r1, r0
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8008a3e:	4c04      	ldr	r4, [pc, #16]	; (8008a50 <CDC_Transmit_FS+0x28>)
 8008a40:	4620      	mov	r0, r4
 8008a42:	f7fb feb2 	bl	80047aa <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8008a46:	4620      	mov	r0, r4
 8008a48:	f7fb febd 	bl	80047c6 <USBD_CDC_TransmitPacket>
  /* USER CODE END 7 */
  return result;
 8008a4c:	bd10      	pop	{r4, pc}
 8008a4e:	bf00      	nop
 8008a50:	2000e6e4 	.word	0x2000e6e4

08008a54 <USBD_Get_USB_Status>:
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 8008a54:	b118      	cbz	r0, 8008a5e <USBD_Get_USB_Status+0xa>
 8008a56:	2802      	cmp	r0, #2
 8008a58:	d003      	beq.n	8008a62 <USBD_Get_USB_Status+0xe>
  {
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8008a5a:	2002      	movs	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8008a5c:	4770      	bx	lr
      usb_status = USBD_OK;
 8008a5e:	2000      	movs	r0, #0
 8008a60:	4770      	bx	lr
      usb_status = USBD_BUSY;
 8008a62:	2001      	movs	r0, #1
    break;
 8008a64:	4770      	bx	lr
	...

08008a68 <HAL_PCD_MspInit>:
  if(pcdHandle->Instance==USB)
 8008a68:	6802      	ldr	r2, [r0, #0]
 8008a6a:	4b0e      	ldr	r3, [pc, #56]	; (8008aa4 <HAL_PCD_MspInit+0x3c>)
 8008a6c:	429a      	cmp	r2, r3
 8008a6e:	d000      	beq.n	8008a72 <HAL_PCD_MspInit+0xa>
 8008a70:	4770      	bx	lr
{
 8008a72:	b500      	push	{lr}
 8008a74:	b083      	sub	sp, #12
    __HAL_RCC_USB_CLK_ENABLE();
 8008a76:	f503 33da 	add.w	r3, r3, #111616	; 0x1b400
 8008a7a:	69da      	ldr	r2, [r3, #28]
 8008a7c:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8008a80:	61da      	str	r2, [r3, #28]
 8008a82:	69db      	ldr	r3, [r3, #28]
 8008a84:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8008a88:	9301      	str	r3, [sp, #4]
 8008a8a:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 8008a8c:	2200      	movs	r2, #0
 8008a8e:	4611      	mov	r1, r2
 8008a90:	2014      	movs	r0, #20
 8008a92:	f7f7 fc3f 	bl	8000314 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 8008a96:	2014      	movs	r0, #20
 8008a98:	f7f7 fc6e 	bl	8000378 <HAL_NVIC_EnableIRQ>
}
 8008a9c:	b003      	add	sp, #12
 8008a9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008aa2:	bf00      	nop
 8008aa4:	40005c00 	.word	0x40005c00

08008aa8 <HAL_PCD_SetupStageCallback>:
{
 8008aa8:	b508      	push	{r3, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8008aaa:	f500 710c 	add.w	r1, r0, #560	; 0x230
 8008aae:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008ab2:	f7fb fef2 	bl	800489a <USBD_LL_SetupStage>
 8008ab6:	bd08      	pop	{r3, pc}

08008ab8 <HAL_PCD_DataOutStageCallback>:
{
 8008ab8:	b508      	push	{r3, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8008aba:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8008abe:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
 8008ac2:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008ac6:	f7fb ff15 	bl	80048f4 <USBD_LL_DataOutStage>
 8008aca:	bd08      	pop	{r3, pc}

08008acc <HAL_PCD_DataInStageCallback>:
{
 8008acc:	b508      	push	{r3, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8008ace:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8008ad2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8008ad4:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008ad8:	f7fb ff56 	bl	8004988 <USBD_LL_DataInStage>
 8008adc:	bd08      	pop	{r3, pc}

08008ade <HAL_PCD_SOFCallback>:
{
 8008ade:	b508      	push	{r3, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8008ae0:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008ae4:	f7fb fff9 	bl	8004ada <USBD_LL_SOF>
 8008ae8:	bd08      	pop	{r3, pc}

08008aea <HAL_PCD_ResetCallback>:
{ 
 8008aea:	b510      	push	{r4, lr}
 8008aec:	4604      	mov	r4, r0
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8008aee:	6883      	ldr	r3, [r0, #8]
 8008af0:	2b02      	cmp	r3, #2
 8008af2:	d001      	beq.n	8008af8 <HAL_PCD_ResetCallback+0xe>
    Error_Handler();
 8008af4:	f7ff fc3c 	bl	8008370 <Error_Handler>
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8008af8:	2101      	movs	r1, #1
 8008afa:	f8d4 0268 	ldr.w	r0, [r4, #616]	; 0x268
 8008afe:	f7fb ffd5 	bl	8004aac <USBD_LL_SetSpeed>
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8008b02:	f8d4 0268 	ldr.w	r0, [r4, #616]	; 0x268
 8008b06:	f7fb ffa9 	bl	8004a5c <USBD_LL_Reset>
 8008b0a:	bd10      	pop	{r4, pc}

08008b0c <HAL_PCD_SuspendCallback>:
{
 8008b0c:	b510      	push	{r4, lr}
 8008b0e:	4604      	mov	r4, r0
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8008b10:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008b14:	f7fb ffcd 	bl	8004ab2 <USBD_LL_Suspend>
  if (hpcd->Init.low_power_enable)
 8008b18:	69a3      	ldr	r3, [r4, #24]
 8008b1a:	b123      	cbz	r3, 8008b26 <HAL_PCD_SuspendCallback+0x1a>
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8008b1c:	4a02      	ldr	r2, [pc, #8]	; (8008b28 <HAL_PCD_SuspendCallback+0x1c>)
 8008b1e:	6913      	ldr	r3, [r2, #16]
 8008b20:	f043 0306 	orr.w	r3, r3, #6
 8008b24:	6113      	str	r3, [r2, #16]
 8008b26:	bd10      	pop	{r4, pc}
 8008b28:	e000ed00 	.word	0xe000ed00

08008b2c <HAL_PCD_ResumeCallback>:
{
 8008b2c:	b508      	push	{r3, lr}
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8008b2e:	f8d0 0268 	ldr.w	r0, [r0, #616]	; 0x268
 8008b32:	f7fb ffc7 	bl	8004ac4 <USBD_LL_Resume>
 8008b36:	bd08      	pop	{r3, pc}

08008b38 <USBD_LL_Init>:
{
 8008b38:	b510      	push	{r4, lr}
 8008b3a:	4604      	mov	r4, r0
  hpcd_USB_FS.pData = pdev;
 8008b3c:	481d      	ldr	r0, [pc, #116]	; (8008bb4 <USBD_LL_Init+0x7c>)
 8008b3e:	f8c0 4268 	str.w	r4, [r0, #616]	; 0x268
  pdev->pData = &hpcd_USB_FS;
 8008b42:	f8c4 02c0 	str.w	r0, [r4, #704]	; 0x2c0
  hpcd_USB_FS.Instance = USB;
 8008b46:	4b1c      	ldr	r3, [pc, #112]	; (8008bb8 <USBD_LL_Init+0x80>)
 8008b48:	6003      	str	r3, [r0, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8008b4a:	2308      	movs	r3, #8
 8008b4c:	6043      	str	r3, [r0, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8008b4e:	2302      	movs	r3, #2
 8008b50:	6083      	str	r3, [r0, #8]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8008b52:	2300      	movs	r3, #0
 8008b54:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8008b56:	61c3      	str	r3, [r0, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8008b58:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8008b5a:	f7f8 f8d5 	bl	8000d08 <HAL_PCD_Init>
 8008b5e:	bb30      	cbnz	r0, 8008bae <USBD_LL_Init+0x76>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8008b60:	2318      	movs	r3, #24
 8008b62:	2200      	movs	r2, #0
 8008b64:	4611      	mov	r1, r2
 8008b66:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 8008b6a:	f7f8 fd09 	bl	8001580 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8008b6e:	2358      	movs	r3, #88	; 0x58
 8008b70:	2200      	movs	r2, #0
 8008b72:	2180      	movs	r1, #128	; 0x80
 8008b74:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 8008b78:	f7f8 fd02 	bl	8001580 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);
 8008b7c:	23c0      	movs	r3, #192	; 0xc0
 8008b7e:	2200      	movs	r2, #0
 8008b80:	2181      	movs	r1, #129	; 0x81
 8008b82:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 8008b86:	f7f8 fcfb 	bl	8001580 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8008b8a:	f44f 7388 	mov.w	r3, #272	; 0x110
 8008b8e:	2200      	movs	r2, #0
 8008b90:	2101      	movs	r1, #1
 8008b92:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 8008b96:	f7f8 fcf3 	bl	8001580 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);
 8008b9a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008b9e:	2200      	movs	r2, #0
 8008ba0:	2182      	movs	r1, #130	; 0x82
 8008ba2:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
 8008ba6:	f7f8 fceb 	bl	8001580 <HAL_PCDEx_PMAConfig>
}
 8008baa:	2000      	movs	r0, #0
 8008bac:	bd10      	pop	{r4, pc}
    Error_Handler( );
 8008bae:	f7ff fbdf 	bl	8008370 <Error_Handler>
 8008bb2:	e7d5      	b.n	8008b60 <USBD_LL_Init+0x28>
 8008bb4:	2000f1a8 	.word	0x2000f1a8
 8008bb8:	40005c00 	.word	0x40005c00

08008bbc <USBD_LL_Start>:
{
 8008bbc:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 8008bbe:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008bc2:	f7f8 f91b 	bl	8000dfc <HAL_PCD_Start>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008bc6:	f7ff ff45 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008bca:	bd08      	pop	{r3, pc}

08008bcc <USBD_LL_OpenEP>:
{
 8008bcc:	b510      	push	{r4, lr}
 8008bce:	461c      	mov	r4, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8008bd0:	4613      	mov	r3, r2
 8008bd2:	4622      	mov	r2, r4
 8008bd4:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008bd8:	f7f8 f93b 	bl	8000e52 <HAL_PCD_EP_Open>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008bdc:	f7ff ff3a 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008be0:	bd10      	pop	{r4, pc}

08008be2 <USBD_LL_CloseEP>:
{
 8008be2:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8008be4:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008be8:	f7f8 f96b 	bl	8000ec2 <HAL_PCD_EP_Close>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008bec:	f7ff ff32 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008bf0:	bd08      	pop	{r3, pc}

08008bf2 <USBD_LL_StallEP>:
{
 8008bf2:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8008bf4:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008bf8:	f7f8 fc54 	bl	80014a4 <HAL_PCD_EP_SetStall>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008bfc:	f7ff ff2a 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008c00:	bd08      	pop	{r3, pc}

08008c02 <USBD_LL_ClearStallEP>:
{
 8008c02:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8008c04:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008c08:	f7f8 fc83 	bl	8001512 <HAL_PCD_EP_ClrStall>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008c0c:	f7ff ff22 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008c10:	bd08      	pop	{r3, pc}

08008c12 <USBD_LL_IsStallEP>:
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8008c12:	f8d0 22c0 	ldr.w	r2, [r0, #704]	; 0x2c0
  if((ep_addr & 0x80) == 0x80)
 8008c16:	f011 0f80 	tst.w	r1, #128	; 0x80
 8008c1a:	d106      	bne.n	8008c2a <USBD_LL_IsStallEP+0x18>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8008c1c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8008c20:	eb02 1141 	add.w	r1, r2, r1, lsl #5
 8008c24:	f891 012a 	ldrb.w	r0, [r1, #298]	; 0x12a
}
 8008c28:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8008c2a:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8008c2e:	eb02 1143 	add.w	r1, r2, r3, lsl #5
 8008c32:	f891 002a 	ldrb.w	r0, [r1, #42]	; 0x2a
 8008c36:	4770      	bx	lr

08008c38 <USBD_LL_SetUSBAddress>:
{
 8008c38:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8008c3a:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008c3e:	f7f8 f8f4 	bl	8000e2a <HAL_PCD_SetAddress>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008c42:	f7ff ff07 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008c46:	bd08      	pop	{r3, pc}

08008c48 <USBD_LL_Transmit>:
{
 8008c48:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8008c4a:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008c4e:	f7f8 f98c 	bl	8000f6a <HAL_PCD_EP_Transmit>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008c52:	f7ff feff 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008c56:	bd08      	pop	{r3, pc}

08008c58 <USBD_LL_PrepareReceive>:
{
 8008c58:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8008c5a:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008c5e:	f7f8 f95e 	bl	8000f1e <HAL_PCD_EP_Receive>
  usb_status =  USBD_Get_USB_Status(hal_status);
 8008c62:	f7ff fef7 	bl	8008a54 <USBD_Get_USB_Status>
}
 8008c66:	bd08      	pop	{r3, pc}

08008c68 <USBD_LL_GetRxDataSize>:
{
 8008c68:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8008c6a:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8008c6e:	f7f8 f975 	bl	8000f5c <HAL_PCD_EP_GetRxCount>
}
 8008c72:	bd08      	pop	{r3, pc}

08008c74 <USBD_static_malloc>:
}
 8008c74:	4800      	ldr	r0, [pc, #0]	; (8008c78 <USBD_static_malloc+0x4>)
 8008c76:	4770      	bx	lr
 8008c78:	2000075c 	.word	0x2000075c

08008c7c <USBD_static_free>:
{
 8008c7c:	4770      	bx	lr

08008c7e <HAL_PCDEx_SetConnectionState>:
{
 8008c7e:	4770      	bx	lr

08008c80 <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 8008c80:	2312      	movs	r3, #18
 8008c82:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8008c84:	4800      	ldr	r0, [pc, #0]	; (8008c88 <USBD_FS_DeviceDescriptor+0x8>)
 8008c86:	4770      	bx	lr
 8008c88:	20000154 	.word	0x20000154

08008c8c <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8008c8c:	2304      	movs	r3, #4
 8008c8e:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8008c90:	4800      	ldr	r0, [pc, #0]	; (8008c94 <USBD_FS_LangIDStrDescriptor+0x8>)
 8008c92:	4770      	bx	lr
 8008c94:	20000168 	.word	0x20000168

08008c98 <IntToUnicode>:
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
  uint8_t idx = 0;

  for (idx = 0; idx < len; idx++)
 8008c98:	2300      	movs	r3, #0
 8008c9a:	4293      	cmp	r3, r2
 8008c9c:	d216      	bcs.n	8008ccc <IntToUnicode+0x34>
{
 8008c9e:	b430      	push	{r4, r5}
 8008ca0:	e00b      	b.n	8008cba <IntToUnicode+0x22>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ca2:	3437      	adds	r4, #55	; 0x37
 8008ca4:	f801 4013 	strb.w	r4, [r1, r3, lsl #1]
    }

    value = value << 4;
 8008ca8:	0100      	lsls	r0, r0, #4

    pbuf[2 * idx + 1] = 0;
 8008caa:	005c      	lsls	r4, r3, #1
 8008cac:	3401      	adds	r4, #1
 8008cae:	2500      	movs	r5, #0
 8008cb0:	550d      	strb	r5, [r1, r4]
  for (idx = 0; idx < len; idx++)
 8008cb2:	3301      	adds	r3, #1
 8008cb4:	b2db      	uxtb	r3, r3
 8008cb6:	4293      	cmp	r3, r2
 8008cb8:	d206      	bcs.n	8008cc8 <IntToUnicode+0x30>
    if (((value >> 28)) < 0xA)
 8008cba:	0f04      	lsrs	r4, r0, #28
 8008cbc:	2c09      	cmp	r4, #9
 8008cbe:	d8f0      	bhi.n	8008ca2 <IntToUnicode+0xa>
      pbuf[2 * idx] = (value >> 28) + '0';
 8008cc0:	3430      	adds	r4, #48	; 0x30
 8008cc2:	f801 4013 	strb.w	r4, [r1, r3, lsl #1]
 8008cc6:	e7ef      	b.n	8008ca8 <IntToUnicode+0x10>
  }
}
 8008cc8:	bc30      	pop	{r4, r5}
 8008cca:	4770      	bx	lr
 8008ccc:	4770      	bx	lr
	...

08008cd0 <Get_SerialNum>:
{
 8008cd0:	b538      	push	{r3, r4, r5, lr}
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8008cd2:	4b0a      	ldr	r3, [pc, #40]	; (8008cfc <Get_SerialNum+0x2c>)
 8008cd4:	6818      	ldr	r0, [r3, #0]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8008cd6:	3304      	adds	r3, #4
 8008cd8:	681c      	ldr	r4, [r3, #0]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8008cda:	3304      	adds	r3, #4
 8008cdc:	681b      	ldr	r3, [r3, #0]
  if (deviceserial0 != 0)
 8008cde:	18c0      	adds	r0, r0, r3
 8008ce0:	d100      	bne.n	8008ce4 <Get_SerialNum+0x14>
 8008ce2:	bd38      	pop	{r3, r4, r5, pc}
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8008ce4:	4d06      	ldr	r5, [pc, #24]	; (8008d00 <Get_SerialNum+0x30>)
 8008ce6:	2208      	movs	r2, #8
 8008ce8:	1ca9      	adds	r1, r5, #2
 8008cea:	f7ff ffd5 	bl	8008c98 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 8008cee:	2204      	movs	r2, #4
 8008cf0:	f105 0112 	add.w	r1, r5, #18
 8008cf4:	4620      	mov	r0, r4
 8008cf6:	f7ff ffcf 	bl	8008c98 <IntToUnicode>
}
 8008cfa:	e7f2      	b.n	8008ce2 <Get_SerialNum+0x12>
 8008cfc:	1ffff7e8 	.word	0x1ffff7e8
 8008d00:	2000016c 	.word	0x2000016c

08008d04 <USBD_FS_SerialStrDescriptor>:
{
 8008d04:	b508      	push	{r3, lr}
  *length = USB_SIZ_STRING_SERIAL;
 8008d06:	231a      	movs	r3, #26
 8008d08:	800b      	strh	r3, [r1, #0]
  Get_SerialNum();
 8008d0a:	f7ff ffe1 	bl	8008cd0 <Get_SerialNum>
}
 8008d0e:	4801      	ldr	r0, [pc, #4]	; (8008d14 <USBD_FS_SerialStrDescriptor+0x10>)
 8008d10:	bd08      	pop	{r3, pc}
 8008d12:	bf00      	nop
 8008d14:	2000016c 	.word	0x2000016c

08008d18 <USBD_FS_ProductStrDescriptor>:
{
 8008d18:	b508      	push	{r3, lr}
 8008d1a:	460a      	mov	r2, r1
  if(speed == 0)
 8008d1c:	b128      	cbz	r0, 8008d2a <USBD_FS_ProductStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8008d1e:	4905      	ldr	r1, [pc, #20]	; (8008d34 <USBD_FS_ProductStrDescriptor+0x1c>)
 8008d20:	4805      	ldr	r0, [pc, #20]	; (8008d38 <USBD_FS_ProductStrDescriptor+0x20>)
 8008d22:	f7fc fa35 	bl	8005190 <USBD_GetString>
}
 8008d26:	4803      	ldr	r0, [pc, #12]	; (8008d34 <USBD_FS_ProductStrDescriptor+0x1c>)
 8008d28:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8008d2a:	4902      	ldr	r1, [pc, #8]	; (8008d34 <USBD_FS_ProductStrDescriptor+0x1c>)
 8008d2c:	4802      	ldr	r0, [pc, #8]	; (8008d38 <USBD_FS_ProductStrDescriptor+0x20>)
 8008d2e:	f7fc fa2f 	bl	8005190 <USBD_GetString>
 8008d32:	e7f8      	b.n	8008d26 <USBD_FS_ProductStrDescriptor+0xe>
 8008d34:	2000f414 	.word	0x2000f414
 8008d38:	0800accc 	.word	0x0800accc

08008d3c <USBD_FS_ManufacturerStrDescriptor>:
{
 8008d3c:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8008d3e:	4c04      	ldr	r4, [pc, #16]	; (8008d50 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8008d40:	460a      	mov	r2, r1
 8008d42:	4621      	mov	r1, r4
 8008d44:	4803      	ldr	r0, [pc, #12]	; (8008d54 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8008d46:	f7fc fa23 	bl	8005190 <USBD_GetString>
}
 8008d4a:	4620      	mov	r0, r4
 8008d4c:	bd10      	pop	{r4, pc}
 8008d4e:	bf00      	nop
 8008d50:	2000f414 	.word	0x2000f414
 8008d54:	0800acb8 	.word	0x0800acb8

08008d58 <USBD_FS_ConfigStrDescriptor>:
{
 8008d58:	b508      	push	{r3, lr}
 8008d5a:	460a      	mov	r2, r1
  if(speed == USBD_SPEED_HIGH)
 8008d5c:	b128      	cbz	r0, 8008d6a <USBD_FS_ConfigStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8008d5e:	4905      	ldr	r1, [pc, #20]	; (8008d74 <USBD_FS_ConfigStrDescriptor+0x1c>)
 8008d60:	4805      	ldr	r0, [pc, #20]	; (8008d78 <USBD_FS_ConfigStrDescriptor+0x20>)
 8008d62:	f7fc fa15 	bl	8005190 <USBD_GetString>
}
 8008d66:	4803      	ldr	r0, [pc, #12]	; (8008d74 <USBD_FS_ConfigStrDescriptor+0x1c>)
 8008d68:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8008d6a:	4902      	ldr	r1, [pc, #8]	; (8008d74 <USBD_FS_ConfigStrDescriptor+0x1c>)
 8008d6c:	4802      	ldr	r0, [pc, #8]	; (8008d78 <USBD_FS_ConfigStrDescriptor+0x20>)
 8008d6e:	f7fc fa0f 	bl	8005190 <USBD_GetString>
 8008d72:	e7f8      	b.n	8008d66 <USBD_FS_ConfigStrDescriptor+0xe>
 8008d74:	2000f414 	.word	0x2000f414
 8008d78:	0800ac9c 	.word	0x0800ac9c

08008d7c <USBD_FS_InterfaceStrDescriptor>:
{
 8008d7c:	b508      	push	{r3, lr}
 8008d7e:	460a      	mov	r2, r1
  if(speed == 0)
 8008d80:	b128      	cbz	r0, 8008d8e <USBD_FS_InterfaceStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8008d82:	4905      	ldr	r1, [pc, #20]	; (8008d98 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 8008d84:	4805      	ldr	r0, [pc, #20]	; (8008d9c <USBD_FS_InterfaceStrDescriptor+0x20>)
 8008d86:	f7fc fa03 	bl	8005190 <USBD_GetString>
}
 8008d8a:	4803      	ldr	r0, [pc, #12]	; (8008d98 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 8008d8c:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8008d8e:	4902      	ldr	r1, [pc, #8]	; (8008d98 <USBD_FS_InterfaceStrDescriptor+0x1c>)
 8008d90:	4802      	ldr	r0, [pc, #8]	; (8008d9c <USBD_FS_InterfaceStrDescriptor+0x20>)
 8008d92:	f7fc f9fd 	bl	8005190 <USBD_GetString>
 8008d96:	e7f8      	b.n	8008d8a <USBD_FS_InterfaceStrDescriptor+0xe>
 8008d98:	2000f414 	.word	0x2000f414
 8008d9c:	0800aca8 	.word	0x0800aca8

08008da0 <SPI_Transmit>:
	2. Write the data to the Data Register
	3. After the data has been transmitted, wait for the BSY bit to reset in Status Register
	4. Clear the Overrun flag by reading DR and SR
	************************************************/
	uint8_t temp;
	int i=0;
 8008da0:	2200      	movs	r2, #0
	while (i<size)
 8008da2:	428a      	cmp	r2, r1
 8008da4:	da1a      	bge.n	8008ddc <SPI_Transmit+0x3c>
{
 8008da6:	b410      	push	{r4}
	{
	   while (!((SPI1->SR)&(1<<1))) {};  // wait for TXE bit to set -> This will indicate that the buffer is empty
 8008da8:	4b13      	ldr	r3, [pc, #76]	; (8008df8 <SPI_Transmit+0x58>)
 8008daa:	689b      	ldr	r3, [r3, #8]
 8008dac:	f013 0f02 	tst.w	r3, #2
 8008db0:	d0fa      	beq.n	8008da8 <SPI_Transmit+0x8>
	   SPI1->DR = data[i];  // load the data into the Data Register
 8008db2:	5c84      	ldrb	r4, [r0, r2]
 8008db4:	4b10      	ldr	r3, [pc, #64]	; (8008df8 <SPI_Transmit+0x58>)
 8008db6:	60dc      	str	r4, [r3, #12]
	   i++;
 8008db8:	3201      	adds	r2, #1
	while (i<size)
 8008dba:	428a      	cmp	r2, r1
 8008dbc:	dbf4      	blt.n	8008da8 <SPI_Transmit+0x8>
	/*During discontinuous communications, there is a 2 APB clock period delay between the
	write operation to the SPI_DR register and BSY bit setting. As a consequence it is
	mandatory to wait first until TXE is set and then until BSY is cleared after writing the last
	data.
	*/
	while (!((SPI1->SR)&(1<<1))) {};  // wait for TXE bit to set -> This will indicate that the buffer is empty
 8008dbe:	4b0e      	ldr	r3, [pc, #56]	; (8008df8 <SPI_Transmit+0x58>)
 8008dc0:	689b      	ldr	r3, [r3, #8]
 8008dc2:	f013 0f02 	tst.w	r3, #2
 8008dc6:	d0fa      	beq.n	8008dbe <SPI_Transmit+0x1e>
	while (((SPI1->SR)&(1<<7))) {};  // wait for BSY bit to Reset -> This will indicate that SPI is not busy in communication
 8008dc8:	4b0b      	ldr	r3, [pc, #44]	; (8008df8 <SPI_Transmit+0x58>)
 8008dca:	689b      	ldr	r3, [r3, #8]
 8008dcc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008dd0:	d1fa      	bne.n	8008dc8 <SPI_Transmit+0x28>

	//  Clear the Overrun flag by reading DR and SR
	temp = SPI1->DR;
 8008dd2:	4b09      	ldr	r3, [pc, #36]	; (8008df8 <SPI_Transmit+0x58>)
 8008dd4:	68da      	ldr	r2, [r3, #12]
	temp = SPI1->SR;
 8008dd6:	689b      	ldr	r3, [r3, #8]

}
 8008dd8:	bc10      	pop	{r4}
 8008dda:	4770      	bx	lr
	while (!((SPI1->SR)&(1<<1))) {};  // wait for TXE bit to set -> This will indicate that the buffer is empty
 8008ddc:	4b06      	ldr	r3, [pc, #24]	; (8008df8 <SPI_Transmit+0x58>)
 8008dde:	689b      	ldr	r3, [r3, #8]
 8008de0:	f013 0f02 	tst.w	r3, #2
 8008de4:	d0fa      	beq.n	8008ddc <SPI_Transmit+0x3c>
	while (((SPI1->SR)&(1<<7))) {};  // wait for BSY bit to Reset -> This will indicate that SPI is not busy in communication
 8008de6:	4b04      	ldr	r3, [pc, #16]	; (8008df8 <SPI_Transmit+0x58>)
 8008de8:	689b      	ldr	r3, [r3, #8]
 8008dea:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008dee:	d1fa      	bne.n	8008de6 <SPI_Transmit+0x46>
	temp = SPI1->DR;
 8008df0:	4b01      	ldr	r3, [pc, #4]	; (8008df8 <SPI_Transmit+0x58>)
 8008df2:	68da      	ldr	r2, [r3, #12]
	temp = SPI1->SR;
 8008df4:	689b      	ldr	r3, [r3, #8]
 8008df6:	4770      	bx	lr
 8008df8:	40013000 	.word	0x40013000

08008dfc <SPI_Receive>:
	2. Send some Dummy data before reading the DATA
	3. Wait for the RXNE bit to Set in the status Register
	4. Read data from Data Register
	************************************************/

	while (size)
 8008dfc:	e011      	b.n	8008e22 <SPI_Receive+0x26>
	{
		while (((SPI1->SR)&(1<<7))) {};  // wait for BSY bit to Reset -> This will indicate that SPI is not busy in communication
 8008dfe:	4b0a      	ldr	r3, [pc, #40]	; (8008e28 <SPI_Receive+0x2c>)
 8008e00:	689b      	ldr	r3, [r3, #8]
 8008e02:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008e06:	d1fa      	bne.n	8008dfe <SPI_Receive+0x2>
		SPI1->DR = 0;  // send dummy data
 8008e08:	2200      	movs	r2, #0
 8008e0a:	4b07      	ldr	r3, [pc, #28]	; (8008e28 <SPI_Receive+0x2c>)
 8008e0c:	60da      	str	r2, [r3, #12]
		while (!((SPI1->SR) &(1<<0))){};  // Wait for RXNE to set -> This will indicate that the Rx buffer is not empty
 8008e0e:	4b06      	ldr	r3, [pc, #24]	; (8008e28 <SPI_Receive+0x2c>)
 8008e10:	689b      	ldr	r3, [r3, #8]
 8008e12:	f013 0f01 	tst.w	r3, #1
 8008e16:	d0fa      	beq.n	8008e0e <SPI_Receive+0x12>
		*data++ = (SPI1->DR);
 8008e18:	4b03      	ldr	r3, [pc, #12]	; (8008e28 <SPI_Receive+0x2c>)
 8008e1a:	68db      	ldr	r3, [r3, #12]
 8008e1c:	7003      	strb	r3, [r0, #0]
		size--;
 8008e1e:	3901      	subs	r1, #1
		*data++ = (SPI1->DR);
 8008e20:	3001      	adds	r0, #1
	while (size)
 8008e22:	2900      	cmp	r1, #0
 8008e24:	d1eb      	bne.n	8008dfe <SPI_Receive+0x2>
	}
}
 8008e26:	4770      	bx	lr
 8008e28:	40013000 	.word	0x40013000

08008e2c <SPI_Send>:

void SPI_Send(unsigned char adat)
{
 8008e2c:	b508      	push	{r3, lr}
	spi_tx[0] = adat;
 8008e2e:	4904      	ldr	r1, [pc, #16]	; (8008e40 <SPI_Send+0x14>)
 8008e30:	7008      	strb	r0, [r1, #0]
	HAL_SPI_Transmit(&hspi1, spi_tx, 1, 1000);
 8008e32:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008e36:	2201      	movs	r2, #1
 8008e38:	4802      	ldr	r0, [pc, #8]	; (8008e44 <SPI_Send+0x18>)
 8008e3a:	f7f9 fe70 	bl	8002b1e <HAL_SPI_Transmit>
 8008e3e:	bd08      	pop	{r3, pc}
 8008e40:	2000e60c 	.word	0x2000e60c
 8008e44:	2000e660 	.word	0x2000e660

08008e48 <SPI_Get>:
}

unsigned char SPI_Get(void)
{
 8008e48:	b510      	push	{r4, lr}
	HAL_SPI_Receive(&hspi1, spi_rx, 1, 1000);
 8008e4a:	4c05      	ldr	r4, [pc, #20]	; (8008e60 <SPI_Get+0x18>)
 8008e4c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008e50:	2201      	movs	r2, #1
 8008e52:	4621      	mov	r1, r4
 8008e54:	4803      	ldr	r0, [pc, #12]	; (8008e64 <SPI_Get+0x1c>)
 8008e56:	f7fa f84e 	bl	8002ef6 <HAL_SPI_Receive>
	return spi_rx[0];
}
 8008e5a:	7820      	ldrb	r0, [r4, #0]
 8008e5c:	bd10      	pop	{r4, pc}
 8008e5e:	bf00      	nop
 8008e60:	2000cd10 	.word	0x2000cd10
 8008e64:	2000e660 	.word	0x2000e660

08008e68 <waitForW25Qxx>:

void waitForW25Qxx(void)
{
 8008e68:	b538      	push	{r3, r4, r5, lr}
	unsigned int flag;
	do {
		ChipSelect(GPIO_PIN_RESET);                      	 //kiadjuk a Chip Enable jelet
 8008e6a:	4c0a      	ldr	r4, [pc, #40]	; (8008e94 <waitForW25Qxx+0x2c>)
 8008e6c:	2200      	movs	r2, #0
 8008e6e:	2140      	movs	r1, #64	; 0x40
 8008e70:	4620      	mov	r0, r4
 8008e72:	f7f7 fba5 	bl	80005c0 <HAL_GPIO_WritePin>
		SPI_Send(CMD_RDSR);                       //Sttuszregiszter olvassa parancs
 8008e76:	2005      	movs	r0, #5
 8008e78:	f7ff ffd8 	bl	8008e2c <SPI_Send>
		flag = SPI_Get();                    //Olvasunk, de valamit akkor is kldeni kell!
 8008e7c:	f7ff ffe4 	bl	8008e48 <SPI_Get>
 8008e80:	4605      	mov	r5, r0
		ChipSelect(GPIO_PIN_SET);                   		 //megszntetjk a Chip Enable jelet
 8008e82:	2201      	movs	r2, #1
 8008e84:	2140      	movs	r1, #64	; 0x40
 8008e86:	4620      	mov	r0, r4
 8008e88:	f7f7 fb9a 	bl	80005c0 <HAL_GPIO_WritePin>
	} while (flag & 0x01);
 8008e8c:	f015 0f01 	tst.w	r5, #1
 8008e90:	d1eb      	bne.n	8008e6a <waitForW25Qxx+0x2>
}
 8008e92:	bd38      	pop	{r3, r4, r5, pc}
 8008e94:	40010c00 	.word	0x40010c00

08008e98 <MemReadFast>:
	ChipSelect(GPIO_PIN_SET);
	return temp;
}

unsigned char MemReadFast(union16 MemCim)
{
 8008e98:	b530      	push	{r4, r5, lr}
 8008e9a:	b083      	sub	sp, #12
 8008e9c:	9001      	str	r0, [sp, #4]
		//ChipSelect(GPIO_PIN_RESET);
		GPIOB->BSRR = (uint32_t)GPIO_PIN_6 << 16u;
 8008e9e:	4d0e      	ldr	r5, [pc, #56]	; (8008ed8 <MemReadFast+0x40>)
 8008ea0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8008ea4:	612b      	str	r3, [r5, #16]

		spi_tx[0] = CMD_READ;
 8008ea6:	480d      	ldr	r0, [pc, #52]	; (8008edc <MemReadFast+0x44>)
 8008ea8:	2303      	movs	r3, #3
 8008eaa:	7003      	strb	r3, [r0, #0]
		spi_tx[1] = MemCim.low;
 8008eac:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008eb0:	7043      	strb	r3, [r0, #1]
		spi_tx[2] = MemCim.high;
 8008eb2:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8008eb6:	7083      	strb	r3, [r0, #2]
		spi_tx[3] = MemCim.hh;
 8008eb8:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008ebc:	70c3      	strb	r3, [r0, #3]
		//HAL_SPI_Transmit(&hspi1, spi_tx, 4, 1000);
		//HAL_SPI_Receive(&hspi1, spi_rx, 1, 1000);
		SPI_Transmit (spi_tx, 4);
 8008ebe:	2104      	movs	r1, #4
 8008ec0:	f7ff ff6e 	bl	8008da0 <SPI_Transmit>
		SPI_Receive (spi_rx, 1);
 8008ec4:	4c06      	ldr	r4, [pc, #24]	; (8008ee0 <MemReadFast+0x48>)
 8008ec6:	2101      	movs	r1, #1
 8008ec8:	4620      	mov	r0, r4
 8008eca:	f7ff ff97 	bl	8008dfc <SPI_Receive>

		//ChipSelect(GPIO_PIN_SET);
		GPIOB->BSRR = GPIO_PIN_6;
 8008ece:	2340      	movs	r3, #64	; 0x40
 8008ed0:	612b      	str	r3, [r5, #16]

		return spi_rx[0];
}
 8008ed2:	7820      	ldrb	r0, [r4, #0]
 8008ed4:	b003      	add	sp, #12
 8008ed6:	bd30      	pop	{r4, r5, pc}
 8008ed8:	40010c00 	.word	0x40010c00
 8008edc:	2000e60c 	.word	0x2000e60c
 8008ee0:	2000cd10 	.word	0x2000cd10

08008ee4 <MemRead>:
	//ChipSelect(GPIO_PIN_SET);
	GPIOB->BSRR = GPIO_PIN_6;
}

unsigned char MemRead(union16 MemCim)
{
 8008ee4:	b530      	push	{r4, r5, lr}
 8008ee6:	b083      	sub	sp, #12
 8008ee8:	9001      	str	r0, [sp, #4]
	unsigned char temp = 0;
	waitForW25Qxx();
 8008eea:	f7ff ffbd 	bl	8008e68 <waitForW25Qxx>
	ChipSelect(GPIO_PIN_RESET);
 8008eee:	4c11      	ldr	r4, [pc, #68]	; (8008f34 <MemRead+0x50>)
 8008ef0:	2200      	movs	r2, #0
 8008ef2:	2140      	movs	r1, #64	; 0x40
 8008ef4:	4620      	mov	r0, r4
 8008ef6:	f7f7 fb63 	bl	80005c0 <HAL_GPIO_WritePin>
	//DWT_Delay_us(1);
	spi_tx[0] = CMD_READ;
 8008efa:	490f      	ldr	r1, [pc, #60]	; (8008f38 <MemRead+0x54>)
 8008efc:	2303      	movs	r3, #3
 8008efe:	700b      	strb	r3, [r1, #0]
	spi_tx[1] = MemCim.low;
 8008f00:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008f04:	704b      	strb	r3, [r1, #1]
	spi_tx[2] = MemCim.high;
 8008f06:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8008f0a:	708b      	strb	r3, [r1, #2]
	spi_tx[3] = MemCim.hh;
 8008f0c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008f10:	70cb      	strb	r3, [r1, #3]
	HAL_SPI_Transmit(&hspi1, spi_tx, 4, 10000);
 8008f12:	f242 7310 	movw	r3, #10000	; 0x2710
 8008f16:	2204      	movs	r2, #4
 8008f18:	4808      	ldr	r0, [pc, #32]	; (8008f3c <MemRead+0x58>)
 8008f1a:	f7f9 fe00 	bl	8002b1e <HAL_SPI_Transmit>
	temp = SPI_Get();
 8008f1e:	f7ff ff93 	bl	8008e48 <SPI_Get>
 8008f22:	4605      	mov	r5, r0
	ChipSelect(GPIO_PIN_SET);
 8008f24:	2201      	movs	r2, #1
 8008f26:	2140      	movs	r1, #64	; 0x40
 8008f28:	4620      	mov	r0, r4
 8008f2a:	f7f7 fb49 	bl	80005c0 <HAL_GPIO_WritePin>
	return temp;
}
 8008f2e:	4628      	mov	r0, r5
 8008f30:	b003      	add	sp, #12
 8008f32:	bd30      	pop	{r4, r5, pc}
 8008f34:	40010c00 	.word	0x40010c00
 8008f38:	2000e60c 	.word	0x2000e60c
 8008f3c:	2000e660 	.word	0x2000e660

08008f40 <MemBlockErase64Kb>:
	SPI_Send(CMD_Erase);
	ChipSelect(GPIO_PIN_SET);
	waitForW25Qxx();
}
void MemBlockErase64Kb(union16 MemCim)
{
 8008f40:	b510      	push	{r4, lr}
 8008f42:	b082      	sub	sp, #8
 8008f44:	9001      	str	r0, [sp, #4]
	waitForW25Qxx();
 8008f46:	f7ff ff8f 	bl	8008e68 <waitForW25Qxx>
	ChipSelect(GPIO_PIN_RESET);
 8008f4a:	4c17      	ldr	r4, [pc, #92]	; (8008fa8 <MemBlockErase64Kb+0x68>)
 8008f4c:	2200      	movs	r2, #0
 8008f4e:	2140      	movs	r1, #64	; 0x40
 8008f50:	4620      	mov	r0, r4
 8008f52:	f7f7 fb35 	bl	80005c0 <HAL_GPIO_WritePin>
	SPI_Send(CMD_WREN);
 8008f56:	2006      	movs	r0, #6
 8008f58:	f7ff ff68 	bl	8008e2c <SPI_Send>
	ChipSelect(GPIO_PIN_SET);
 8008f5c:	2201      	movs	r2, #1
 8008f5e:	2140      	movs	r1, #64	; 0x40
 8008f60:	4620      	mov	r0, r4
 8008f62:	f7f7 fb2d 	bl	80005c0 <HAL_GPIO_WritePin>
	//HAL_Delay(1);
	ChipSelect(GPIO_PIN_RESET);
 8008f66:	2200      	movs	r2, #0
 8008f68:	2140      	movs	r1, #64	; 0x40
 8008f6a:	4620      	mov	r0, r4
 8008f6c:	f7f7 fb28 	bl	80005c0 <HAL_GPIO_WritePin>
	spi_tx[0] = CMD_BLCK64Kb;
 8008f70:	490e      	ldr	r1, [pc, #56]	; (8008fac <MemBlockErase64Kb+0x6c>)
 8008f72:	23d8      	movs	r3, #216	; 0xd8
 8008f74:	700b      	strb	r3, [r1, #0]
	spi_tx[1] = MemCim.low;
 8008f76:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008f7a:	704b      	strb	r3, [r1, #1]
	spi_tx[2] = MemCim.high;
 8008f7c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8008f80:	708b      	strb	r3, [r1, #2]
	spi_tx[3] = MemCim.hh;
 8008f82:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008f86:	70cb      	strb	r3, [r1, #3]
	HAL_SPI_Transmit(&hspi1, spi_tx, 4, 1000);
 8008f88:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008f8c:	2204      	movs	r2, #4
 8008f8e:	4808      	ldr	r0, [pc, #32]	; (8008fb0 <MemBlockErase64Kb+0x70>)
 8008f90:	f7f9 fdc5 	bl	8002b1e <HAL_SPI_Transmit>
	ChipSelect(GPIO_PIN_SET);
 8008f94:	2201      	movs	r2, #1
 8008f96:	2140      	movs	r1, #64	; 0x40
 8008f98:	4620      	mov	r0, r4
 8008f9a:	f7f7 fb11 	bl	80005c0 <HAL_GPIO_WritePin>
	waitForW25Qxx();
 8008f9e:	f7ff ff63 	bl	8008e68 <waitForW25Qxx>
}
 8008fa2:	b002      	add	sp, #8
 8008fa4:	bd10      	pop	{r4, pc}
 8008fa6:	bf00      	nop
 8008fa8:	40010c00 	.word	0x40010c00
 8008fac:	2000e60c 	.word	0x2000e60c
 8008fb0:	2000e660 	.word	0x2000e660

08008fb4 <memWriteW25Qxx>:

void memWriteW25Qxx(union16 MemCim, unsigned char *pbuf) {
 8008fb4:	b570      	push	{r4, r5, r6, lr}
 8008fb6:	b082      	sub	sp, #8
 8008fb8:	9001      	str	r0, [sp, #4]
 8008fba:	460e      	mov	r6, r1
	waitForW25Qxx();                         //Vrunk, ha az EEPROM elfoglalt
 8008fbc:	f7ff ff54 	bl	8008e68 <waitForW25Qxx>
	ChipSelect(GPIO_PIN_RESET);
 8008fc0:	4c1b      	ldr	r4, [pc, #108]	; (8009030 <memWriteW25Qxx+0x7c>)
 8008fc2:	2200      	movs	r2, #0
 8008fc4:	2140      	movs	r1, #64	; 0x40
 8008fc6:	4620      	mov	r0, r4
 8008fc8:	f7f7 fafa 	bl	80005c0 <HAL_GPIO_WritePin>
	SPI_Send(CMD_WREN);                       //rs jraengedlyezse
 8008fcc:	2006      	movs	r0, #6
 8008fce:	f7ff ff2d 	bl	8008e2c <SPI_Send>
	ChipSelect(GPIO_PIN_SET);
 8008fd2:	2201      	movs	r2, #1
 8008fd4:	2140      	movs	r1, #64	; 0x40
 8008fd6:	4620      	mov	r0, r4
 8008fd8:	f7f7 faf2 	bl	80005c0 <HAL_GPIO_WritePin>
	HAL_Delay(1);
 8008fdc:	2001      	movs	r0, #1
 8008fde:	f7f7 f973 	bl	80002c8 <HAL_Delay>
	ChipSelect(GPIO_PIN_RESET);
 8008fe2:	2200      	movs	r2, #0
 8008fe4:	2140      	movs	r1, #64	; 0x40
 8008fe6:	4620      	mov	r0, r4
 8008fe8:	f7f7 faea 	bl	80005c0 <HAL_GPIO_WritePin>
	spi_tx[0] = CMD_WRITE;
 8008fec:	4911      	ldr	r1, [pc, #68]	; (8009034 <memWriteW25Qxx+0x80>)
 8008fee:	2302      	movs	r3, #2
 8008ff0:	700b      	strb	r3, [r1, #0]
	spi_tx[1] = MemCim.low;
 8008ff2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008ff6:	704b      	strb	r3, [r1, #1]
	spi_tx[2] = MemCim.high;
 8008ff8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8008ffc:	708b      	strb	r3, [r1, #2]
	spi_tx[3] = MemCim.hh;
 8008ffe:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8009002:	70cb      	strb	r3, [r1, #3]
	HAL_SPI_Transmit(&hspi1, spi_tx, 4, 1000);
 8009004:	4d0c      	ldr	r5, [pc, #48]	; (8009038 <memWriteW25Qxx+0x84>)
 8009006:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800900a:	2204      	movs	r2, #4
 800900c:	4628      	mov	r0, r5
 800900e:	f7f9 fd86 	bl	8002b1e <HAL_SPI_Transmit>
	HAL_SPI_Transmit(&hspi1, pbuf, PMEMBLOCK, 1000);
 8009012:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009016:	2240      	movs	r2, #64	; 0x40
 8009018:	4631      	mov	r1, r6
 800901a:	4628      	mov	r0, r5
 800901c:	f7f9 fd7f 	bl	8002b1e <HAL_SPI_Transmit>
	ChipSelect(GPIO_PIN_SET);
 8009020:	2201      	movs	r2, #1
 8009022:	2140      	movs	r1, #64	; 0x40
 8009024:	4620      	mov	r0, r4
 8009026:	f7f7 facb 	bl	80005c0 <HAL_GPIO_WritePin>
}
 800902a:	b002      	add	sp, #8
 800902c:	bd70      	pop	{r4, r5, r6, pc}
 800902e:	bf00      	nop
 8009030:	40010c00 	.word	0x40010c00
 8009034:	2000e60c 	.word	0x2000e60c
 8009038:	2000e660 	.word	0x2000e660

0800903c <SN76489_SendByte>:
#include "ym2612.h"
//#include "sega.h"

void SN76489_SendByte(unsigned char byte)
{
 800903c:	b538      	push	{r3, r4, r5, lr}
	int temp = 0;
	temp = byte>>7;
	temp |= (byte>>6&0x01)<<1;
 800903e:	0983      	lsrs	r3, r0, #6
 8009040:	005b      	lsls	r3, r3, #1
 8009042:	f003 0302 	and.w	r3, r3, #2
 8009046:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
	temp |= (byte>>5&0x01)<<2;
 800904a:	0942      	lsrs	r2, r0, #5
 800904c:	0092      	lsls	r2, r2, #2
 800904e:	f002 0204 	and.w	r2, r2, #4
 8009052:	4313      	orrs	r3, r2
	temp |= (byte>>4&0x01)<<3;
 8009054:	0902      	lsrs	r2, r0, #4
 8009056:	00d2      	lsls	r2, r2, #3
 8009058:	f002 0208 	and.w	r2, r2, #8
 800905c:	4313      	orrs	r3, r2
	temp |= (byte>>3&0x01)<<4;
 800905e:	08c2      	lsrs	r2, r0, #3
 8009060:	0112      	lsls	r2, r2, #4
 8009062:	f002 0210 	and.w	r2, r2, #16
 8009066:	4313      	orrs	r3, r2
	temp |= (byte>>2&0x01)<<5;
 8009068:	0882      	lsrs	r2, r0, #2
 800906a:	0152      	lsls	r2, r2, #5
 800906c:	f002 0220 	and.w	r2, r2, #32
 8009070:	4313      	orrs	r3, r2
	temp |= (byte>>1&0x01)<<6;
 8009072:	0842      	lsrs	r2, r0, #1
 8009074:	0192      	lsls	r2, r2, #6
 8009076:	f002 0240 	and.w	r2, r2, #64	; 0x40
 800907a:	4313      	orrs	r3, r2
	temp |= (byte&0x01)<<7;
 800907c:	01c0      	lsls	r0, r0, #7
 800907e:	b2c0      	uxtb	r0, r0
 8009080:	4303      	orrs	r3, r0
	SN_PORT(temp);
 8009082:	4a0e      	ldr	r2, [pc, #56]	; (80090bc <SN76489_SendByte+0x80>)
 8009084:	60d3      	str	r3, [r2, #12]
	SN_WE(GPIO_PIN_RESET);
 8009086:	2200      	movs	r2, #0
 8009088:	2101      	movs	r1, #1
 800908a:	480d      	ldr	r0, [pc, #52]	; (80090c0 <SN76489_SendByte+0x84>)
 800908c:	f7f7 fa98 	bl	80005c0 <HAL_GPIO_WritePin>
 8009090:	240b      	movs	r4, #11
 * @brief  This function provides a delay (in microseconds)
 * @param  microseconds: delay in microseconds
 */
__STATIC_INLINE void DWT_Delay_us(volatile uint32_t microseconds)
{
  uint32_t clk_cycle_start = DWT->CYCCNT;
 8009092:	4b0c      	ldr	r3, [pc, #48]	; (80090c4 <SN76489_SendByte+0x88>)
 8009094:	685d      	ldr	r5, [r3, #4]

  /* Go to number of cycles for system */
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 8009096:	f7f8 fe0d 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 800909a:	4b0b      	ldr	r3, [pc, #44]	; (80090c8 <SN76489_SendByte+0x8c>)
 800909c:	fba3 3000 	umull	r3, r0, r3, r0
 80090a0:	0c80      	lsrs	r0, r0, #18
 80090a2:	fb04 f400 	mul.w	r4, r4, r0

  /* Delay till end */
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 80090a6:	4b07      	ldr	r3, [pc, #28]	; (80090c4 <SN76489_SendByte+0x88>)
 80090a8:	685b      	ldr	r3, [r3, #4]
 80090aa:	1b5b      	subs	r3, r3, r5
 80090ac:	42a3      	cmp	r3, r4
 80090ae:	d3fa      	bcc.n	80090a6 <SN76489_SendByte+0x6a>
	DWT_Delay_us(11);
	SN_WE(GPIO_PIN_SET);
 80090b0:	2201      	movs	r2, #1
 80090b2:	4611      	mov	r1, r2
 80090b4:	4802      	ldr	r0, [pc, #8]	; (80090c0 <SN76489_SendByte+0x84>)
 80090b6:	f7f7 fa83 	bl	80005c0 <HAL_GPIO_WritePin>
 80090ba:	bd38      	pop	{r3, r4, r5, pc}
 80090bc:	40011000 	.word	0x40011000
 80090c0:	40010c00 	.word	0x40010c00
 80090c4:	e0001000 	.word	0xe0001000
 80090c8:	431bde83 	.word	0x431bde83

080090cc <SN76489_SendByteFast>:
}

void SN76489_SendByteFast(unsigned char byte)
{
 80090cc:	b538      	push	{r3, r4, r5, lr}
	int temp = 0;
	temp = byte>>7;
	temp |= (byte>>6&0x01)<<1;
 80090ce:	0983      	lsrs	r3, r0, #6
 80090d0:	005b      	lsls	r3, r3, #1
 80090d2:	f003 0302 	and.w	r3, r3, #2
 80090d6:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
	temp |= (byte>>5&0x01)<<2;
 80090da:	0942      	lsrs	r2, r0, #5
 80090dc:	0092      	lsls	r2, r2, #2
 80090de:	f002 0204 	and.w	r2, r2, #4
 80090e2:	4313      	orrs	r3, r2
	temp |= (byte>>4&0x01)<<3;
 80090e4:	0902      	lsrs	r2, r0, #4
 80090e6:	00d2      	lsls	r2, r2, #3
 80090e8:	f002 0208 	and.w	r2, r2, #8
 80090ec:	4313      	orrs	r3, r2
	temp |= (byte>>3&0x01)<<4;
 80090ee:	08c2      	lsrs	r2, r0, #3
 80090f0:	0112      	lsls	r2, r2, #4
 80090f2:	f002 0210 	and.w	r2, r2, #16
 80090f6:	4313      	orrs	r3, r2
	temp |= (byte>>2&0x01)<<5;
 80090f8:	0882      	lsrs	r2, r0, #2
 80090fa:	0152      	lsls	r2, r2, #5
 80090fc:	f002 0220 	and.w	r2, r2, #32
 8009100:	4313      	orrs	r3, r2
	temp |= (byte>>1&0x01)<<6;
 8009102:	0842      	lsrs	r2, r0, #1
 8009104:	0192      	lsls	r2, r2, #6
 8009106:	f002 0240 	and.w	r2, r2, #64	; 0x40
 800910a:	4313      	orrs	r3, r2
	temp |= (byte&0x01)<<7;
 800910c:	01c0      	lsls	r0, r0, #7
 800910e:	b2c0      	uxtb	r0, r0
 8009110:	4303      	orrs	r3, r0

	//SN_PORT(temp);
	//GPIOC->ODR = temp;
	GPIOC->ODR = ((GPIOC->ODR & 0xFF00) | temp);	// Csak az al 1byte-ot rja fell
 8009112:	4910      	ldr	r1, [pc, #64]	; (8009154 <SN76489_SendByteFast+0x88>)
 8009114:	68ca      	ldr	r2, [r1, #12]
 8009116:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800911a:	4313      	orrs	r3, r2
 800911c:	60cb      	str	r3, [r1, #12]

	//SN_WE(GPIO_PIN_RESET);
	GPIOB->BSRR = (uint32_t)GPIO_PIN_0 << 16u;
 800911e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8009122:	4b0d      	ldr	r3, [pc, #52]	; (8009158 <SN76489_SendByteFast+0x8c>)
 8009124:	611a      	str	r2, [r3, #16]
 8009126:	240d      	movs	r4, #13
  uint32_t clk_cycle_start = DWT->CYCCNT;
 8009128:	4b0c      	ldr	r3, [pc, #48]	; (800915c <SN76489_SendByteFast+0x90>)
 800912a:	685d      	ldr	r5, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 800912c:	f7f8 fdc2 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8009130:	4b0b      	ldr	r3, [pc, #44]	; (8009160 <SN76489_SendByteFast+0x94>)
 8009132:	fba3 3000 	umull	r3, r0, r3, r0
 8009136:	0c80      	lsrs	r0, r0, #18
 8009138:	fb04 f400 	mul.w	r4, r4, r0
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 800913c:	4b07      	ldr	r3, [pc, #28]	; (800915c <SN76489_SendByteFast+0x90>)
 800913e:	685b      	ldr	r3, [r3, #4]
 8009140:	1b5b      	subs	r3, r3, r5
 8009142:	42a3      	cmp	r3, r4
 8009144:	d3fa      	bcc.n	800913c <SN76489_SendByteFast+0x70>

	DWT_Delay_us(13);

	SN_WE(GPIO_PIN_SET);
 8009146:	2201      	movs	r2, #1
 8009148:	4611      	mov	r1, r2
 800914a:	4803      	ldr	r0, [pc, #12]	; (8009158 <SN76489_SendByteFast+0x8c>)
 800914c:	f7f7 fa38 	bl	80005c0 <HAL_GPIO_WritePin>
 8009150:	bd38      	pop	{r3, r4, r5, pc}
 8009152:	bf00      	nop
 8009154:	40011000 	.word	0x40011000
 8009158:	40010c00 	.word	0x40010c00
 800915c:	e0001000 	.word	0xe0001000
 8009160:	431bde83 	.word	0x431bde83

08009164 <PSG_Silence>:
	//GPIOB->BSRR = GPIO_PIN_0;
}

void PSG_Silence(void)
{
 8009164:	b570      	push	{r4, r5, r6, lr}
	SN76489_SendByte(0b10011111);	// 0 csatonra Hanger nma (0x9F)
 8009166:	209f      	movs	r0, #159	; 0x9f
 8009168:	f7ff ff68 	bl	800903c <SN76489_SendByte>
	SN76489_SendByte(0b10111111);	// 1 csatonra Hanger nma (0xBF)
 800916c:	20bf      	movs	r0, #191	; 0xbf
 800916e:	f7ff ff65 	bl	800903c <SN76489_SendByte>
	SN76489_SendByte(0b11011111);	// 2 csatonra Hanger nma (0xDF)
 8009172:	20df      	movs	r0, #223	; 0xdf
 8009174:	f7ff ff62 	bl	800903c <SN76489_SendByte>
	SN76489_SendByte(0b11111111);	// 3 csatonra Hanger nma (0xFF)
 8009178:	20ff      	movs	r0, #255	; 0xff
 800917a:	f7ff ff5f 	bl	800903c <SN76489_SendByte>
 800917e:	2419      	movs	r4, #25
  uint32_t clk_cycle_start = DWT->CYCCNT;
 8009180:	4b30      	ldr	r3, [pc, #192]	; (8009244 <PSG_Silence+0xe0>)
 8009182:	685d      	ldr	r5, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 8009184:	f7f8 fd96 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8009188:	4b2f      	ldr	r3, [pc, #188]	; (8009248 <PSG_Silence+0xe4>)
 800918a:	fba3 3000 	umull	r3, r0, r3, r0
 800918e:	0c80      	lsrs	r0, r0, #18
 8009190:	fb04 f400 	mul.w	r4, r4, r0
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 8009194:	4b2b      	ldr	r3, [pc, #172]	; (8009244 <PSG_Silence+0xe0>)
 8009196:	685b      	ldr	r3, [r3, #4]
 8009198:	1b5b      	subs	r3, r3, r5
 800919a:	42a3      	cmp	r3, r4
 800919c:	d3fa      	bcc.n	8009194 <PSG_Silence+0x30>
	DWT_Delay_us(25);
	YM_PORT(0x00);
 800919e:	4e2b      	ldr	r6, [pc, #172]	; (800924c <PSG_Silence+0xe8>)
 80091a0:	2500      	movs	r5, #0
 80091a2:	60f5      	str	r5, [r6, #12]
	YM_A0(GPIO_PIN_RESET);
 80091a4:	4c2a      	ldr	r4, [pc, #168]	; (8009250 <PSG_Silence+0xec>)
 80091a6:	462a      	mov	r2, r5
 80091a8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80091ac:	4620      	mov	r0, r4
 80091ae:	f7f7 fa07 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_A1(GPIO_PIN_RESET);
 80091b2:	462a      	mov	r2, r5
 80091b4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80091b8:	4630      	mov	r0, r6
 80091ba:	f7f7 fa01 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_CS(GPIO_PIN_SET);
 80091be:	2201      	movs	r2, #1
 80091c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80091c4:	4620      	mov	r0, r4
 80091c6:	f7f7 f9fb 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_WR(GPIO_PIN_SET);
 80091ca:	2201      	movs	r2, #1
 80091cc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80091d0:	4620      	mov	r0, r4
 80091d2:	f7f7 f9f5 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_RD(GPIO_PIN_SET);
 80091d6:	2201      	movs	r2, #1
 80091d8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80091dc:	4620      	mov	r0, r4
 80091de:	f7f7 f9ef 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_IC(GPIO_PIN_SET);
 80091e2:	2201      	movs	r2, #1
 80091e4:	2104      	movs	r1, #4
 80091e6:	4620      	mov	r0, r4
 80091e8:	f7f7 f9ea 	bl	80005c0 <HAL_GPIO_WritePin>
	YM_IC(GPIO_PIN_RESET);
 80091ec:	462a      	mov	r2, r5
 80091ee:	2104      	movs	r1, #4
 80091f0:	4620      	mov	r0, r4
 80091f2:	f7f7 f9e5 	bl	80005c0 <HAL_GPIO_WritePin>
 80091f6:	2419      	movs	r4, #25
  uint32_t clk_cycle_start = DWT->CYCCNT;
 80091f8:	4b12      	ldr	r3, [pc, #72]	; (8009244 <PSG_Silence+0xe0>)
 80091fa:	685d      	ldr	r5, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 80091fc:	f7f8 fd5a 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 8009200:	4b11      	ldr	r3, [pc, #68]	; (8009248 <PSG_Silence+0xe4>)
 8009202:	fba3 3000 	umull	r3, r0, r3, r0
 8009206:	0c80      	lsrs	r0, r0, #18
 8009208:	fb04 f400 	mul.w	r4, r4, r0
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 800920c:	4b0d      	ldr	r3, [pc, #52]	; (8009244 <PSG_Silence+0xe0>)
 800920e:	685b      	ldr	r3, [r3, #4]
 8009210:	1b5b      	subs	r3, r3, r5
 8009212:	42a3      	cmp	r3, r4
 8009214:	d3fa      	bcc.n	800920c <PSG_Silence+0xa8>
	DWT_Delay_us(25);
	YM_IC(GPIO_PIN_SET);
 8009216:	2201      	movs	r2, #1
 8009218:	2104      	movs	r1, #4
 800921a:	480d      	ldr	r0, [pc, #52]	; (8009250 <PSG_Silence+0xec>)
 800921c:	f7f7 f9d0 	bl	80005c0 <HAL_GPIO_WritePin>
 8009220:	2419      	movs	r4, #25
  uint32_t clk_cycle_start = DWT->CYCCNT;
 8009222:	4b08      	ldr	r3, [pc, #32]	; (8009244 <PSG_Silence+0xe0>)
 8009224:	685d      	ldr	r5, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 8009226:	f7f8 fd45 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 800922a:	4b07      	ldr	r3, [pc, #28]	; (8009248 <PSG_Silence+0xe4>)
 800922c:	fba3 3000 	umull	r3, r0, r3, r0
 8009230:	0c80      	lsrs	r0, r0, #18
 8009232:	fb04 f400 	mul.w	r4, r4, r0
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 8009236:	4b03      	ldr	r3, [pc, #12]	; (8009244 <PSG_Silence+0xe0>)
 8009238:	685b      	ldr	r3, [r3, #4]
 800923a:	1b5b      	subs	r3, r3, r5
 800923c:	42a3      	cmp	r3, r4
 800923e:	d3fa      	bcc.n	8009236 <PSG_Silence+0xd2>
	DWT_Delay_us(25);

}
 8009240:	bd70      	pop	{r4, r5, r6, pc}
 8009242:	bf00      	nop
 8009244:	e0001000 	.word	0xe0001000
 8009248:	431bde83 	.word	0x431bde83
 800924c:	40010800 	.word	0x40010800
 8009250:	40010c00 	.word	0x40010c00

08009254 <YM2612_SendFast>:
void YM2612_SendFast(unsigned char addr, unsigned char data, unsigned char CMD) //0x52 = A1 LOW, 0x53 = A1 HIGH
{
 8009254:	b538      	push	{r3, r4, r5, lr}
 8009256:	460d      	mov	r5, r1
	//YM_A1(GPIO_PIN_RESET);
	GPIOA->BSRR = (uint32_t)GPIO_PIN_8 << 16u;
 8009258:	4929      	ldr	r1, [pc, #164]	; (8009300 <YM2612_SendFast+0xac>)
 800925a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800925e:	610b      	str	r3, [r1, #16]

    //YM_A0(GPIO_PIN_RESET); 						// A0 LOW
	GPIOB->BSRR = (uint32_t)GPIO_PIN_15 << 16u;
 8009260:	4b28      	ldr	r3, [pc, #160]	; (8009304 <YM2612_SendFast+0xb0>)
 8009262:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8009266:	611c      	str	r4, [r3, #16]

    //YM_CS(GPIO_PIN_RESET);						// CS LOW
	GPIOB->BSRR = (uint32_t)GPIO_PIN_12 << 16u;
 8009268:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
 800926c:	611c      	str	r4, [r3, #16]

    //YM_PORT(addr);
	//GPIOA->ODR = addr;
	GPIOA->ODR = ((GPIOA->ODR & 0xFF00) | addr);	// Csak az al 1byte-ot rja fell
 800926e:	68cb      	ldr	r3, [r1, #12]
 8009270:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8009274:	4318      	orrs	r0, r3
 8009276:	60c8      	str	r0, [r1, #12]

    if(CMD==0x53){
 8009278:	2a53      	cmp	r2, #83	; 0x53
 800927a:	d03d      	beq.n	80092f8 <YM2612_SendFast+0xa4>
    	//YM_A1(GPIO_PIN_SET);					// A1 HIGH
    	GPIOA->BSRR = GPIO_PIN_8;
    }
    //DWT_Delay_us(10);
    //YM_WR(GPIO_PIN_RESET);						// WR LOW
    GPIOB->BSRR = (uint32_t)GPIO_PIN_13 << 16u;
 800927c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8009280:	4b20      	ldr	r3, [pc, #128]	; (8009304 <YM2612_SendFast+0xb0>)
 8009282:	611a      	str	r2, [r3, #16]
  uint32_t clk_cycle_start = DWT->CYCCNT;
 8009284:	4b20      	ldr	r3, [pc, #128]	; (8009308 <YM2612_SendFast+0xb4>)
 8009286:	685c      	ldr	r4, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 8009288:	f7f8 fd14 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 800928c:	4a1f      	ldr	r2, [pc, #124]	; (800930c <YM2612_SendFast+0xb8>)
 800928e:	fba2 3200 	umull	r3, r2, r2, r0
 8009292:	0c92      	lsrs	r2, r2, #18
 8009294:	0052      	lsls	r2, r2, #1
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 8009296:	4b1c      	ldr	r3, [pc, #112]	; (8009308 <YM2612_SendFast+0xb4>)
 8009298:	685b      	ldr	r3, [r3, #4]
 800929a:	1b1b      	subs	r3, r3, r4
 800929c:	4293      	cmp	r3, r2
 800929e:	d3fa      	bcc.n	8009296 <YM2612_SendFast+0x42>

    DWT_Delay_us(2);

    //YM_WR(GPIO_PIN_SET);						// WR HIGH
    GPIOB->BSRR = YM_WR_Pin;
 80092a0:	4b18      	ldr	r3, [pc, #96]	; (8009304 <YM2612_SendFast+0xb0>)
 80092a2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80092a6:	611a      	str	r2, [r3, #16]

    //YM_CS(GPIO_PIN_SET);						// CS HIGH
    GPIOB->BSRR = GPIO_PIN_12;
 80092a8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80092ac:	611a      	str	r2, [r3, #16]

    //YM_A0(GPIO_PIN_SET);						// A0 HIGH
    GPIOB->BSRR = GPIO_PIN_15;
 80092ae:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80092b2:	611a      	str	r2, [r3, #16]

    //YM_CS(GPIO_PIN_RESET);						// CS LOW
    GPIOB->BSRR = (uint32_t)GPIO_PIN_12 << 16u;
 80092b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80092b8:	611a      	str	r2, [r3, #16]

    //YM_PORT(data);
    //GPIOA->ODR = data;
    GPIOA->ODR = ((GPIOA->ODR & 0xFF00) | data);	// Csak az al 1byte-ot rja fell
 80092ba:	4911      	ldr	r1, [pc, #68]	; (8009300 <YM2612_SendFast+0xac>)
 80092bc:	68ca      	ldr	r2, [r1, #12]
 80092be:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 80092c2:	4315      	orrs	r5, r2
 80092c4:	60cd      	str	r5, [r1, #12]

    //YM_WR(GPIO_PIN_RESET);						// WR LOW
    GPIOB->BSRR = (uint32_t)GPIO_PIN_13 << 16u;
 80092c6:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 80092ca:	611a      	str	r2, [r3, #16]
  uint32_t clk_cycle_start = DWT->CYCCNT;
 80092cc:	4b0e      	ldr	r3, [pc, #56]	; (8009308 <YM2612_SendFast+0xb4>)
 80092ce:	685c      	ldr	r4, [r3, #4]
  microseconds *= (HAL_RCC_GetHCLKFreq() / 1000000);
 80092d0:	f7f8 fcf0 	bl	8001cb4 <HAL_RCC_GetHCLKFreq>
 80092d4:	4a0d      	ldr	r2, [pc, #52]	; (800930c <YM2612_SendFast+0xb8>)
 80092d6:	fba2 3200 	umull	r3, r2, r2, r0
 80092da:	0c92      	lsrs	r2, r2, #18
 80092dc:	0052      	lsls	r2, r2, #1
  while ((DWT->CYCCNT - clk_cycle_start) < microseconds);
 80092de:	4b0a      	ldr	r3, [pc, #40]	; (8009308 <YM2612_SendFast+0xb4>)
 80092e0:	685b      	ldr	r3, [r3, #4]
 80092e2:	1b1b      	subs	r3, r3, r4
 80092e4:	4293      	cmp	r3, r2
 80092e6:	d3fa      	bcc.n	80092de <YM2612_SendFast+0x8a>

    DWT_Delay_us(2);

    //YM_WR(GPIO_PIN_SET);						// WR HIGH
    GPIOB->BSRR = GPIO_PIN_13;
 80092e8:	4b06      	ldr	r3, [pc, #24]	; (8009304 <YM2612_SendFast+0xb0>)
 80092ea:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80092ee:	611a      	str	r2, [r3, #16]

    //YM_CS(GPIO_PIN_SET);						// CS HIGH
    GPIOB->BSRR = GPIO_PIN_12;
 80092f0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80092f4:	611a      	str	r2, [r3, #16]
 80092f6:	bd38      	pop	{r3, r4, r5, pc}
    	GPIOA->BSRR = GPIO_PIN_8;
 80092f8:	f44f 7280 	mov.w	r2, #256	; 0x100
 80092fc:	610a      	str	r2, [r1, #16]
 80092fe:	e7bd      	b.n	800927c <YM2612_SendFast+0x28>
 8009300:	40010800 	.word	0x40010800
 8009304:	40010c00 	.word	0x40010c00
 8009308:	e0001000 	.word	0xe0001000
 800930c:	431bde83 	.word	0x431bde83

08009310 <WaveSampleIf>:
			return 0;
	}
}

volatile unsigned int WaveSampleIf(void)
{
 8009310:	b570      	push	{r4, r5, r6, lr}
	unsigned char Sample = 0;
	unsigned char YM_address = 0;
	unsigned char YM_data = 0;
	unsigned int i = 0;

	Sample = MemReadFast(MemCim);
 8009312:	4b9a      	ldr	r3, [pc, #616]	; (800957c <WaveSampleIf+0x26c>)
 8009314:	6818      	ldr	r0, [r3, #0]
 8009316:	f7ff fdbf 	bl	8008e98 <MemReadFast>
 800931a:	4604      	mov	r4, r0
	if(Sample == 0x4F || Sample == 0x50)
 800931c:	f1a0 034f 	sub.w	r3, r0, #79	; 0x4f
 8009320:	b2db      	uxtb	r3, r3
 8009322:	2b01      	cmp	r3, #1
 8009324:	d932      	bls.n	800938c <WaveSampleIf+0x7c>
		MemCim.value++;
		if(Sample == 0x4F) SN76489_SendByteFast(0x06);
		SN76489_SendByteFast(MemReadFast(MemCim));
		return  0;
	}
	else if(Sample == 0x52 || Sample == 0x53)
 8009326:	f1a0 0352 	sub.w	r3, r0, #82	; 0x52
 800932a:	b2db      	uxtb	r3, r3
 800932c:	2b01      	cmp	r3, #1
 800932e:	d93f      	bls.n	80093b0 <WaveSampleIf+0xa0>
		YM_address = MemReadFast(MemCim);
		MemCim.value++;
		YM_data = MemReadFast(MemCim);
		YM2610_Send(YM_address, YM_data, Sample);
		return  1;*/
	else if(Sample == 0x61)
 8009330:	2861      	cmp	r0, #97	; 0x61
 8009332:	d061      	beq.n	80093f8 <WaveSampleIf+0xe8>
			}
			VGMStream.PCMStartAdr += PCMMEMADDR.value;
			return  0;
		}*/
	}
	else if(Sample == 0x62)
 8009334:	2862      	cmp	r0, #98	; 0x62
 8009336:	f000 8119 	beq.w	800956c <WaveSampleIf+0x25c>
	{
		return  735;
	}
	else if(Sample == 0x63)
 800933a:	2863      	cmp	r0, #99	; 0x63
 800933c:	f000 8119 	beq.w	8009572 <WaveSampleIf+0x262>
	{
		return  882;
	}
	else if(Sample == 0x67)
 8009340:	2867      	cmp	r0, #103	; 0x67
 8009342:	d05c      	beq.n	80093fe <WaveSampleIf+0xee>
				MemCim.value+=PCMDataCount;
			}
		}
		return  0;
	}
	else if(Sample >= 0x70 && Sample <= 0x7F)
 8009344:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 8009348:	b2db      	uxtb	r3, r3
 800934a:	2b0f      	cmp	r3, #15
 800934c:	f240 80ad 	bls.w	80094aa <WaveSampleIf+0x19a>
	{
		return  (Sample & 0x0F)+1;
	}
	else if(Sample >= 0x80 && Sample <= 0x8F)
 8009350:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
 8009354:	b2db      	uxtb	r3, r3
 8009356:	2b0f      	cmp	r3, #15
 8009358:	f200 80b4 	bhi.w	80094c4 <WaveSampleIf+0x1b4>
	{
		wait = Sample & 0x0F;
 800935c:	f000 050f 	and.w	r5, r0, #15
		YM_address = 0x2A;

		if(PCMLoad)
 8009360:	4b87      	ldr	r3, [pc, #540]	; (8009580 <WaveSampleIf+0x270>)
 8009362:	781b      	ldrb	r3, [r3, #0]
 8009364:	2b00      	cmp	r3, #0
 8009366:	f000 80a4 	beq.w	80094b2 <WaveSampleIf+0x1a2>
		{
			PCMBuffIndex++;
 800936a:	4a86      	ldr	r2, [pc, #536]	; (8009584 <WaveSampleIf+0x274>)
 800936c:	8813      	ldrh	r3, [r2, #0]
 800936e:	b29b      	uxth	r3, r3
 8009370:	3301      	adds	r3, #1
 8009372:	b29b      	uxth	r3, r3
 8009374:	8013      	strh	r3, [r2, #0]
			YM_data = PCMBuff[PCMBuffIndex];
 8009376:	8813      	ldrh	r3, [r2, #0]
 8009378:	b29b      	uxth	r3, r3
 800937a:	4a83      	ldr	r2, [pc, #524]	; (8009588 <WaveSampleIf+0x278>)
 800937c:	5cd1      	ldrb	r1, [r2, r3]
 800937e:	b2c9      	uxtb	r1, r1
		{
			PCMMEMADDR.value++;
			YM_data = MemReadFast(PCMMEMADDR);
		}

		YM2612_SendFast(YM_address, YM_data, Sample);
 8009380:	4622      	mov	r2, r4
 8009382:	202a      	movs	r0, #42	; 0x2a
 8009384:	f7ff ff66 	bl	8009254 <YM2612_SendFast>
		return  wait;
 8009388:	4628      	mov	r0, r5
 800938a:	bd70      	pop	{r4, r5, r6, pc}
		MemCim.value++;
 800938c:	4a7b      	ldr	r2, [pc, #492]	; (800957c <WaveSampleIf+0x26c>)
 800938e:	6813      	ldr	r3, [r2, #0]
 8009390:	3301      	adds	r3, #1
 8009392:	6013      	str	r3, [r2, #0]
		if(Sample == 0x4F) SN76489_SendByteFast(0x06);
 8009394:	284f      	cmp	r0, #79	; 0x4f
 8009396:	d007      	beq.n	80093a8 <WaveSampleIf+0x98>
		SN76489_SendByteFast(MemReadFast(MemCim));
 8009398:	4b78      	ldr	r3, [pc, #480]	; (800957c <WaveSampleIf+0x26c>)
 800939a:	6818      	ldr	r0, [r3, #0]
 800939c:	f7ff fd7c 	bl	8008e98 <MemReadFast>
 80093a0:	f7ff fe94 	bl	80090cc <SN76489_SendByteFast>
		return  0;
 80093a4:	2000      	movs	r0, #0
 80093a6:	bd70      	pop	{r4, r5, r6, pc}
		if(Sample == 0x4F) SN76489_SendByteFast(0x06);
 80093a8:	2006      	movs	r0, #6
 80093aa:	f7ff fe8f 	bl	80090cc <SN76489_SendByteFast>
 80093ae:	e7f3      	b.n	8009398 <WaveSampleIf+0x88>
		MemCim.value++;
 80093b0:	4d72      	ldr	r5, [pc, #456]	; (800957c <WaveSampleIf+0x26c>)
 80093b2:	682b      	ldr	r3, [r5, #0]
 80093b4:	3301      	adds	r3, #1
 80093b6:	602b      	str	r3, [r5, #0]
		YM_address = MemReadFast(MemCim);
 80093b8:	6828      	ldr	r0, [r5, #0]
 80093ba:	f7ff fd6d 	bl	8008e98 <MemReadFast>
 80093be:	4606      	mov	r6, r0
		MemCim.value++;
 80093c0:	682b      	ldr	r3, [r5, #0]
 80093c2:	3301      	adds	r3, #1
 80093c4:	602b      	str	r3, [r5, #0]
		YM_data = MemReadFast(MemCim);
 80093c6:	6828      	ldr	r0, [r5, #0]
 80093c8:	f7ff fd66 	bl	8008e98 <MemReadFast>
		YM2612_SendFast(YM_address, YM_data, Sample);
 80093cc:	4622      	mov	r2, r4
 80093ce:	4601      	mov	r1, r0
 80093d0:	4630      	mov	r0, r6
 80093d2:	f7ff ff3f 	bl	8009254 <YM2612_SendFast>
		return  0;
 80093d6:	2000      	movs	r0, #0
 80093d8:	bd70      	pop	{r4, r5, r6, pc}
			MemCim.value++;
 80093da:	4b68      	ldr	r3, [pc, #416]	; (800957c <WaveSampleIf+0x26c>)
 80093dc:	681a      	ldr	r2, [r3, #0]
 80093de:	3201      	adds	r2, #1
 80093e0:	601a      	str	r2, [r3, #0]
			wait += ( (unsigned int)(MemReadFast(MemCim)) << ( 8 * i ));
 80093e2:	6818      	ldr	r0, [r3, #0]
 80093e4:	f7ff fd58 	bl	8008e98 <MemReadFast>
 80093e8:	00eb      	lsls	r3, r5, #3
 80093ea:	4098      	lsls	r0, r3
 80093ec:	4404      	add	r4, r0
		for ( i = 0; i < 2; i++ )
 80093ee:	3501      	adds	r5, #1
 80093f0:	2d01      	cmp	r5, #1
 80093f2:	d9f2      	bls.n	80093da <WaveSampleIf+0xca>
			return  wait;
 80093f4:	4620      	mov	r0, r4
 80093f6:	bd70      	pop	{r4, r5, r6, pc}
 80093f8:	2500      	movs	r5, #0
 80093fa:	462c      	mov	r4, r5
 80093fc:	e7f8      	b.n	80093f0 <WaveSampleIf+0xe0>
		MemCim.value++;	// Skip 0x66
 80093fe:	4b5f      	ldr	r3, [pc, #380]	; (800957c <WaveSampleIf+0x26c>)
 8009400:	681a      	ldr	r2, [r3, #0]
 8009402:	3201      	adds	r2, #1
 8009404:	601a      	str	r2, [r3, #0]
		MemCim.value++; // Skip data type
 8009406:	681a      	ldr	r2, [r3, #0]
 8009408:	3201      	adds	r2, #1
 800940a:	601a      	str	r2, [r3, #0]
		for ( i = 0; i < 4; i++ )
 800940c:	2400      	movs	r4, #0
 800940e:	e00d      	b.n	800942c <WaveSampleIf+0x11c>
			MemCim.value++;
 8009410:	4b5a      	ldr	r3, [pc, #360]	; (800957c <WaveSampleIf+0x26c>)
 8009412:	681a      	ldr	r2, [r3, #0]
 8009414:	3201      	adds	r2, #1
 8009416:	601a      	str	r2, [r3, #0]
			PCMDataCount += ( (unsigned long)(MemReadFast(MemCim)) << ( 8 * i ));
 8009418:	6818      	ldr	r0, [r3, #0]
 800941a:	f7ff fd3d 	bl	8008e98 <MemReadFast>
 800941e:	00e3      	lsls	r3, r4, #3
 8009420:	4098      	lsls	r0, r3
 8009422:	4a5a      	ldr	r2, [pc, #360]	; (800958c <WaveSampleIf+0x27c>)
 8009424:	6813      	ldr	r3, [r2, #0]
 8009426:	4418      	add	r0, r3
 8009428:	6010      	str	r0, [r2, #0]
		for ( i = 0; i < 4; i++ )
 800942a:	3401      	adds	r4, #1
 800942c:	2c03      	cmp	r4, #3
 800942e:	d9ef      	bls.n	8009410 <WaveSampleIf+0x100>
		pcmPosStart = MemCim.value+1;
 8009430:	4b52      	ldr	r3, [pc, #328]	; (800957c <WaveSampleIf+0x26c>)
 8009432:	681b      	ldr	r3, [r3, #0]
 8009434:	3301      	adds	r3, #1
 8009436:	4a56      	ldr	r2, [pc, #344]	; (8009590 <WaveSampleIf+0x280>)
 8009438:	6013      	str	r3, [r2, #0]
		if(PCMDataCount > 0 && PCMDataCount <= PCMMaxSize && !PCMLoad)
 800943a:	4b54      	ldr	r3, [pc, #336]	; (800958c <WaveSampleIf+0x27c>)
 800943c:	681b      	ldr	r3, [r3, #0]
 800943e:	b143      	cbz	r3, 8009452 <WaveSampleIf+0x142>
 8009440:	4b52      	ldr	r3, [pc, #328]	; (800958c <WaveSampleIf+0x27c>)
 8009442:	681b      	ldr	r3, [r3, #0]
 8009444:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009448:	d803      	bhi.n	8009452 <WaveSampleIf+0x142>
 800944a:	4b4d      	ldr	r3, [pc, #308]	; (8009580 <WaveSampleIf+0x270>)
 800944c:	781b      	ldrb	r3, [r3, #0]
 800944e:	2b00      	cmp	r3, #0
 8009450:	d029      	beq.n	80094a6 <WaveSampleIf+0x196>
			if(!PCMLoad)
 8009452:	4b4b      	ldr	r3, [pc, #300]	; (8009580 <WaveSampleIf+0x270>)
 8009454:	781b      	ldrb	r3, [r3, #0]
 8009456:	2b00      	cmp	r3, #0
 8009458:	f040 808e 	bne.w	8009578 <WaveSampleIf+0x268>
				pcmPosStart = MemCim.value;
 800945c:	4b47      	ldr	r3, [pc, #284]	; (800957c <WaveSampleIf+0x26c>)
 800945e:	6819      	ldr	r1, [r3, #0]
 8009460:	4a4b      	ldr	r2, [pc, #300]	; (8009590 <WaveSampleIf+0x280>)
 8009462:	6011      	str	r1, [r2, #0]
				PCMMEMADDR.value = pcmPosStart;
 8009464:	6811      	ldr	r1, [r2, #0]
 8009466:	4a4b      	ldr	r2, [pc, #300]	; (8009594 <WaveSampleIf+0x284>)
 8009468:	6011      	str	r1, [r2, #0]
				MemCim.value+=PCMDataCount;
 800946a:	4a48      	ldr	r2, [pc, #288]	; (800958c <WaveSampleIf+0x27c>)
 800946c:	6812      	ldr	r2, [r2, #0]
 800946e:	6819      	ldr	r1, [r3, #0]
 8009470:	440a      	add	r2, r1
 8009472:	601a      	str	r2, [r3, #0]
		return  0;
 8009474:	2000      	movs	r0, #0
 8009476:	bd70      	pop	{r4, r5, r6, pc}
				MemCim.value++;
 8009478:	4b40      	ldr	r3, [pc, #256]	; (800957c <WaveSampleIf+0x26c>)
 800947a:	681a      	ldr	r2, [r3, #0]
 800947c:	3201      	adds	r2, #1
 800947e:	601a      	str	r2, [r3, #0]
				PCMBuff[i] = MemReadFast(MemCim);
 8009480:	6818      	ldr	r0, [r3, #0]
 8009482:	f7ff fd09 	bl	8008e98 <MemReadFast>
 8009486:	4b40      	ldr	r3, [pc, #256]	; (8009588 <WaveSampleIf+0x278>)
 8009488:	5518      	strb	r0, [r3, r4]
			for(i=0; i<PCMDataCount; i++)
 800948a:	3401      	adds	r4, #1
 800948c:	4b3f      	ldr	r3, [pc, #252]	; (800958c <WaveSampleIf+0x27c>)
 800948e:	681b      	ldr	r3, [r3, #0]
 8009490:	429c      	cmp	r4, r3
 8009492:	d3f1      	bcc.n	8009478 <WaveSampleIf+0x168>
			PCMBuffIndex = 0;
 8009494:	2000      	movs	r0, #0
 8009496:	4b3b      	ldr	r3, [pc, #236]	; (8009584 <WaveSampleIf+0x274>)
 8009498:	8018      	strh	r0, [r3, #0]
			PCMLoad = 1;
 800949a:	2201      	movs	r2, #1
 800949c:	4b38      	ldr	r3, [pc, #224]	; (8009580 <WaveSampleIf+0x270>)
 800949e:	701a      	strb	r2, [r3, #0]
			PCMJumpIndex = 0;
 80094a0:	4b3d      	ldr	r3, [pc, #244]	; (8009598 <WaveSampleIf+0x288>)
 80094a2:	8018      	strh	r0, [r3, #0]
 80094a4:	bd70      	pop	{r4, r5, r6, pc}
 80094a6:	2400      	movs	r4, #0
 80094a8:	e7f0      	b.n	800948c <WaveSampleIf+0x17c>
		return  (Sample & 0x0F)+1;
 80094aa:	f000 000f 	and.w	r0, r0, #15
 80094ae:	3001      	adds	r0, #1
 80094b0:	bd70      	pop	{r4, r5, r6, pc}
			PCMMEMADDR.value++;
 80094b2:	4b38      	ldr	r3, [pc, #224]	; (8009594 <WaveSampleIf+0x284>)
 80094b4:	681a      	ldr	r2, [r3, #0]
 80094b6:	3201      	adds	r2, #1
 80094b8:	601a      	str	r2, [r3, #0]
			YM_data = MemReadFast(PCMMEMADDR);
 80094ba:	6818      	ldr	r0, [r3, #0]
 80094bc:	f7ff fcec 	bl	8008e98 <MemReadFast>
 80094c0:	4601      	mov	r1, r0
 80094c2:	e75d      	b.n	8009380 <WaveSampleIf+0x70>
			MemCim.value++;
			VGMStream.Freq += ( (unsigned long)(MemReadFast(MemCim)) << ( 8 * i ));
		}
		return  0;
	}*/
	else if(Sample == 0xE0)
 80094c4:	28e0      	cmp	r0, #224	; 0xe0
 80094c6:	d003      	beq.n	80094d0 <WaveSampleIf+0x1c0>
			}
		}
#endif
		return  0;
	}
	else if(Sample == 0x66)
 80094c8:	2866      	cmp	r0, #102	; 0x66
 80094ca:	d035      	beq.n	8009538 <WaveSampleIf+0x228>
		PCMLoad=0;
		return  0;
	}
	else
	{
		return  0;
 80094cc:	2000      	movs	r0, #0
	}
}
 80094ce:	bd70      	pop	{r4, r5, r6, pc}
		if(PCMLoad)
 80094d0:	4b2b      	ldr	r3, [pc, #172]	; (8009580 <WaveSampleIf+0x270>)
 80094d2:	781b      	ldrb	r3, [r3, #0]
 80094d4:	b1bb      	cbz	r3, 8009506 <WaveSampleIf+0x1f6>
			PCMBuffIndex = 0;
 80094d6:	2400      	movs	r4, #0
 80094d8:	4b2a      	ldr	r3, [pc, #168]	; (8009584 <WaveSampleIf+0x274>)
 80094da:	801c      	strh	r4, [r3, #0]
			for (i = 0; i < 4; i++ )
 80094dc:	e00f      	b.n	80094fe <WaveSampleIf+0x1ee>
				MemCim.value++;
 80094de:	4b27      	ldr	r3, [pc, #156]	; (800957c <WaveSampleIf+0x26c>)
 80094e0:	681a      	ldr	r2, [r3, #0]
 80094e2:	3201      	adds	r2, #1
 80094e4:	601a      	str	r2, [r3, #0]
				PCMBuffIndex += ( (unsigned int)(MemReadFast(MemCim)) << ( 8 * i ));
 80094e6:	6818      	ldr	r0, [r3, #0]
 80094e8:	f7ff fcd6 	bl	8008e98 <MemReadFast>
 80094ec:	00e3      	lsls	r3, r4, #3
 80094ee:	4098      	lsls	r0, r3
 80094f0:	4a24      	ldr	r2, [pc, #144]	; (8009584 <WaveSampleIf+0x274>)
 80094f2:	8813      	ldrh	r3, [r2, #0]
 80094f4:	b29b      	uxth	r3, r3
 80094f6:	4403      	add	r3, r0
 80094f8:	b29b      	uxth	r3, r3
 80094fa:	8013      	strh	r3, [r2, #0]
			for (i = 0; i < 4; i++ )
 80094fc:	3401      	adds	r4, #1
 80094fe:	2c03      	cmp	r4, #3
 8009500:	d9ed      	bls.n	80094de <WaveSampleIf+0x1ce>
		return  0;
 8009502:	2000      	movs	r0, #0
 8009504:	bd70      	pop	{r4, r5, r6, pc}
			PCMMEMADDR.value = pcmPosStart;
 8009506:	4b22      	ldr	r3, [pc, #136]	; (8009590 <WaveSampleIf+0x280>)
 8009508:	681a      	ldr	r2, [r3, #0]
 800950a:	4b22      	ldr	r3, [pc, #136]	; (8009594 <WaveSampleIf+0x284>)
 800950c:	601a      	str	r2, [r3, #0]
			for (i = 0; i < 4; i++ )
 800950e:	2400      	movs	r4, #0
 8009510:	e00e      	b.n	8009530 <WaveSampleIf+0x220>
				MemCim.value++;
 8009512:	4b1a      	ldr	r3, [pc, #104]	; (800957c <WaveSampleIf+0x26c>)
 8009514:	681a      	ldr	r2, [r3, #0]
 8009516:	3201      	adds	r2, #1
 8009518:	601a      	str	r2, [r3, #0]
				PCMMEMADDR.value += ( (unsigned int)(MemReadFast(MemCim)) << ( 8 * i ));
 800951a:	6818      	ldr	r0, [r3, #0]
 800951c:	f7ff fcbc 	bl	8008e98 <MemReadFast>
 8009520:	00e3      	lsls	r3, r4, #3
 8009522:	fa00 f303 	lsl.w	r3, r0, r3
 8009526:	4a1b      	ldr	r2, [pc, #108]	; (8009594 <WaveSampleIf+0x284>)
 8009528:	6810      	ldr	r0, [r2, #0]
 800952a:	4403      	add	r3, r0
 800952c:	6013      	str	r3, [r2, #0]
			for (i = 0; i < 4; i++ )
 800952e:	3401      	adds	r4, #1
 8009530:	2c03      	cmp	r4, #3
 8009532:	d9ee      	bls.n	8009512 <WaveSampleIf+0x202>
		return  0;
 8009534:	2000      	movs	r0, #0
 8009536:	bd70      	pop	{r4, r5, r6, pc}
		MemCim.value = 63;
 8009538:	223f      	movs	r2, #63	; 0x3f
 800953a:	4b10      	ldr	r3, [pc, #64]	; (800957c <WaveSampleIf+0x26c>)
 800953c:	601a      	str	r2, [r3, #0]
		if(VGMVersion==0x151) MemCim.value = 127;
 800953e:	4b17      	ldr	r3, [pc, #92]	; (800959c <WaveSampleIf+0x28c>)
 8009540:	881b      	ldrh	r3, [r3, #0]
 8009542:	b29b      	uxth	r3, r3
 8009544:	f240 1251 	movw	r2, #337	; 0x151
 8009548:	4293      	cmp	r3, r2
 800954a:	d00b      	beq.n	8009564 <WaveSampleIf+0x254>
		PCMMEMADDR.value=0;
 800954c:	2000      	movs	r0, #0
 800954e:	4b11      	ldr	r3, [pc, #68]	; (8009594 <WaveSampleIf+0x284>)
 8009550:	6018      	str	r0, [r3, #0]
		PCMBuffIndex=0;
 8009552:	4b0c      	ldr	r3, [pc, #48]	; (8009584 <WaveSampleIf+0x274>)
 8009554:	8018      	strh	r0, [r3, #0]
		PCMDataCount=0;
 8009556:	4b0d      	ldr	r3, [pc, #52]	; (800958c <WaveSampleIf+0x27c>)
 8009558:	6018      	str	r0, [r3, #0]
		PCMJumpIndex=0;
 800955a:	4b0f      	ldr	r3, [pc, #60]	; (8009598 <WaveSampleIf+0x288>)
 800955c:	8018      	strh	r0, [r3, #0]
		PCMLoad=0;
 800955e:	4b08      	ldr	r3, [pc, #32]	; (8009580 <WaveSampleIf+0x270>)
 8009560:	7018      	strb	r0, [r3, #0]
		return  0;
 8009562:	bd70      	pop	{r4, r5, r6, pc}
		if(VGMVersion==0x151) MemCim.value = 127;
 8009564:	227f      	movs	r2, #127	; 0x7f
 8009566:	4b05      	ldr	r3, [pc, #20]	; (800957c <WaveSampleIf+0x26c>)
 8009568:	601a      	str	r2, [r3, #0]
 800956a:	e7ef      	b.n	800954c <WaveSampleIf+0x23c>
		return  735;
 800956c:	f240 20df 	movw	r0, #735	; 0x2df
 8009570:	bd70      	pop	{r4, r5, r6, pc}
		return  882;
 8009572:	f240 3072 	movw	r0, #882	; 0x372
 8009576:	bd70      	pop	{r4, r5, r6, pc}
		return  0;
 8009578:	2000      	movs	r0, #0
 800957a:	bd70      	pop	{r4, r5, r6, pc}
 800957c:	2000e6e0 	.word	0x2000e6e0
 8009580:	2000e6c0 	.word	0x2000e6c0
 8009584:	2000cac6 	.word	0x2000cac6
 8009588:	20004ac4 	.word	0x20004ac4
 800958c:	2000ccc8 	.word	0x2000ccc8
 8009590:	2000cccc 	.word	0x2000cccc
 8009594:	20004a9c 	.word	0x20004a9c
 8009598:	2000cac4 	.word	0x2000cac4
 800959c:	2000cd58 	.word	0x2000cd58

080095a0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 80095a0:	2100      	movs	r1, #0
  b LoopCopyDataInit
 80095a2:	e003      	b.n	80095ac <LoopCopyDataInit>

080095a4 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 80095a4:	4b0b      	ldr	r3, [pc, #44]	; (80095d4 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 80095a6:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 80095a8:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 80095aa:	3104      	adds	r1, #4

080095ac <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 80095ac:	480a      	ldr	r0, [pc, #40]	; (80095d8 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 80095ae:	4b0b      	ldr	r3, [pc, #44]	; (80095dc <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 80095b0:	1842      	adds	r2, r0, r1
  cmp r2, r3
 80095b2:	429a      	cmp	r2, r3
  bcc CopyDataInit
 80095b4:	d3f6      	bcc.n	80095a4 <CopyDataInit>
  ldr r2, =_sbss
 80095b6:	4a0a      	ldr	r2, [pc, #40]	; (80095e0 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 80095b8:	e002      	b.n	80095c0 <LoopFillZerobss>

080095ba <FillZerobss>:

/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 80095ba:	2300      	movs	r3, #0
  str r3, [r2], #4
 80095bc:	f842 3b04 	str.w	r3, [r2], #4

080095c0 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 80095c0:	4b08      	ldr	r3, [pc, #32]	; (80095e4 <LoopFillZerobss+0x24>)
  cmp r2, r3
 80095c2:	429a      	cmp	r2, r3
  bcc FillZerobss
 80095c4:	d3f9      	bcc.n	80095ba <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80095c6:	f7ff f98d 	bl	80088e4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80095ca:	f000 f815 	bl	80095f8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80095ce:	f7fe fa09 	bl	80079e4 <main>
  bx lr
 80095d2:	4770      	bx	lr
  ldr r3, =_sidata
 80095d4:	0800ad20 	.word	0x0800ad20
  ldr r0, =_sdata
 80095d8:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80095dc:	200001ec 	.word	0x200001ec
  ldr r2, =_sbss
 80095e0:	200001ec 	.word	0x200001ec
  ldr r3, = _ebss
 80095e4:	2000f618 	.word	0x2000f618

080095e8 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80095e8:	e7fe      	b.n	80095e8 <ADC1_2_IRQHandler>
	...

080095ec <__errno>:
 80095ec:	4b01      	ldr	r3, [pc, #4]	; (80095f4 <__errno+0x8>)
 80095ee:	6818      	ldr	r0, [r3, #0]
 80095f0:	4770      	bx	lr
 80095f2:	bf00      	nop
 80095f4:	20000188 	.word	0x20000188

080095f8 <__libc_init_array>:
 80095f8:	b570      	push	{r4, r5, r6, lr}
 80095fa:	2500      	movs	r5, #0
 80095fc:	4e0c      	ldr	r6, [pc, #48]	; (8009630 <__libc_init_array+0x38>)
 80095fe:	4c0d      	ldr	r4, [pc, #52]	; (8009634 <__libc_init_array+0x3c>)
 8009600:	1ba4      	subs	r4, r4, r6
 8009602:	10a4      	asrs	r4, r4, #2
 8009604:	42a5      	cmp	r5, r4
 8009606:	d109      	bne.n	800961c <__libc_init_array+0x24>
 8009608:	f000 fc4e 	bl	8009ea8 <_init>
 800960c:	2500      	movs	r5, #0
 800960e:	4e0a      	ldr	r6, [pc, #40]	; (8009638 <__libc_init_array+0x40>)
 8009610:	4c0a      	ldr	r4, [pc, #40]	; (800963c <__libc_init_array+0x44>)
 8009612:	1ba4      	subs	r4, r4, r6
 8009614:	10a4      	asrs	r4, r4, #2
 8009616:	42a5      	cmp	r5, r4
 8009618:	d105      	bne.n	8009626 <__libc_init_array+0x2e>
 800961a:	bd70      	pop	{r4, r5, r6, pc}
 800961c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009620:	4798      	blx	r3
 8009622:	3501      	adds	r5, #1
 8009624:	e7ee      	b.n	8009604 <__libc_init_array+0xc>
 8009626:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800962a:	4798      	blx	r3
 800962c:	3501      	adds	r5, #1
 800962e:	e7f2      	b.n	8009616 <__libc_init_array+0x1e>
 8009630:	0800ad18 	.word	0x0800ad18
 8009634:	0800ad18 	.word	0x0800ad18
 8009638:	0800ad18 	.word	0x0800ad18
 800963c:	0800ad1c 	.word	0x0800ad1c

08009640 <memcpy>:
 8009640:	b510      	push	{r4, lr}
 8009642:	1e43      	subs	r3, r0, #1
 8009644:	440a      	add	r2, r1
 8009646:	4291      	cmp	r1, r2
 8009648:	d100      	bne.n	800964c <memcpy+0xc>
 800964a:	bd10      	pop	{r4, pc}
 800964c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009650:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009654:	e7f7      	b.n	8009646 <memcpy+0x6>

08009656 <memset>:
 8009656:	4603      	mov	r3, r0
 8009658:	4402      	add	r2, r0
 800965a:	4293      	cmp	r3, r2
 800965c:	d100      	bne.n	8009660 <memset+0xa>
 800965e:	4770      	bx	lr
 8009660:	f803 1b01 	strb.w	r1, [r3], #1
 8009664:	e7f9      	b.n	800965a <memset+0x4>
	...

08009668 <siprintf>:
 8009668:	b40e      	push	{r1, r2, r3}
 800966a:	f44f 7102 	mov.w	r1, #520	; 0x208
 800966e:	b500      	push	{lr}
 8009670:	b09c      	sub	sp, #112	; 0x70
 8009672:	f8ad 1014 	strh.w	r1, [sp, #20]
 8009676:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800967a:	9104      	str	r1, [sp, #16]
 800967c:	9107      	str	r1, [sp, #28]
 800967e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009682:	ab1d      	add	r3, sp, #116	; 0x74
 8009684:	9002      	str	r0, [sp, #8]
 8009686:	9006      	str	r0, [sp, #24]
 8009688:	4808      	ldr	r0, [pc, #32]	; (80096ac <siprintf+0x44>)
 800968a:	f853 2b04 	ldr.w	r2, [r3], #4
 800968e:	f8ad 1016 	strh.w	r1, [sp, #22]
 8009692:	6800      	ldr	r0, [r0, #0]
 8009694:	a902      	add	r1, sp, #8
 8009696:	9301      	str	r3, [sp, #4]
 8009698:	f000 f866 	bl	8009768 <_svfiprintf_r>
 800969c:	2200      	movs	r2, #0
 800969e:	9b02      	ldr	r3, [sp, #8]
 80096a0:	701a      	strb	r2, [r3, #0]
 80096a2:	b01c      	add	sp, #112	; 0x70
 80096a4:	f85d eb04 	ldr.w	lr, [sp], #4
 80096a8:	b003      	add	sp, #12
 80096aa:	4770      	bx	lr
 80096ac:	20000188 	.word	0x20000188

080096b0 <__ssputs_r>:
 80096b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80096b4:	688e      	ldr	r6, [r1, #8]
 80096b6:	4682      	mov	sl, r0
 80096b8:	429e      	cmp	r6, r3
 80096ba:	460c      	mov	r4, r1
 80096bc:	4691      	mov	r9, r2
 80096be:	4698      	mov	r8, r3
 80096c0:	d835      	bhi.n	800972e <__ssputs_r+0x7e>
 80096c2:	898a      	ldrh	r2, [r1, #12]
 80096c4:	f412 6f90 	tst.w	r2, #1152	; 0x480
 80096c8:	d031      	beq.n	800972e <__ssputs_r+0x7e>
 80096ca:	2302      	movs	r3, #2
 80096cc:	6825      	ldr	r5, [r4, #0]
 80096ce:	6909      	ldr	r1, [r1, #16]
 80096d0:	1a6f      	subs	r7, r5, r1
 80096d2:	6965      	ldr	r5, [r4, #20]
 80096d4:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80096d8:	fb95 f5f3 	sdiv	r5, r5, r3
 80096dc:	f108 0301 	add.w	r3, r8, #1
 80096e0:	443b      	add	r3, r7
 80096e2:	429d      	cmp	r5, r3
 80096e4:	bf38      	it	cc
 80096e6:	461d      	movcc	r5, r3
 80096e8:	0553      	lsls	r3, r2, #21
 80096ea:	d531      	bpl.n	8009750 <__ssputs_r+0xa0>
 80096ec:	4629      	mov	r1, r5
 80096ee:	f000 fb3b 	bl	8009d68 <_malloc_r>
 80096f2:	4606      	mov	r6, r0
 80096f4:	b950      	cbnz	r0, 800970c <__ssputs_r+0x5c>
 80096f6:	230c      	movs	r3, #12
 80096f8:	f8ca 3000 	str.w	r3, [sl]
 80096fc:	89a3      	ldrh	r3, [r4, #12]
 80096fe:	f04f 30ff 	mov.w	r0, #4294967295
 8009702:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009706:	81a3      	strh	r3, [r4, #12]
 8009708:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800970c:	463a      	mov	r2, r7
 800970e:	6921      	ldr	r1, [r4, #16]
 8009710:	f7ff ff96 	bl	8009640 <memcpy>
 8009714:	89a3      	ldrh	r3, [r4, #12]
 8009716:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800971a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800971e:	81a3      	strh	r3, [r4, #12]
 8009720:	6126      	str	r6, [r4, #16]
 8009722:	443e      	add	r6, r7
 8009724:	6026      	str	r6, [r4, #0]
 8009726:	4646      	mov	r6, r8
 8009728:	6165      	str	r5, [r4, #20]
 800972a:	1bed      	subs	r5, r5, r7
 800972c:	60a5      	str	r5, [r4, #8]
 800972e:	4546      	cmp	r6, r8
 8009730:	bf28      	it	cs
 8009732:	4646      	movcs	r6, r8
 8009734:	4649      	mov	r1, r9
 8009736:	4632      	mov	r2, r6
 8009738:	6820      	ldr	r0, [r4, #0]
 800973a:	f000 faaf 	bl	8009c9c <memmove>
 800973e:	68a3      	ldr	r3, [r4, #8]
 8009740:	2000      	movs	r0, #0
 8009742:	1b9b      	subs	r3, r3, r6
 8009744:	60a3      	str	r3, [r4, #8]
 8009746:	6823      	ldr	r3, [r4, #0]
 8009748:	441e      	add	r6, r3
 800974a:	6026      	str	r6, [r4, #0]
 800974c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009750:	462a      	mov	r2, r5
 8009752:	f000 fb67 	bl	8009e24 <_realloc_r>
 8009756:	4606      	mov	r6, r0
 8009758:	2800      	cmp	r0, #0
 800975a:	d1e1      	bne.n	8009720 <__ssputs_r+0x70>
 800975c:	6921      	ldr	r1, [r4, #16]
 800975e:	4650      	mov	r0, sl
 8009760:	f000 fab6 	bl	8009cd0 <_free_r>
 8009764:	e7c7      	b.n	80096f6 <__ssputs_r+0x46>
	...

08009768 <_svfiprintf_r>:
 8009768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800976c:	b09d      	sub	sp, #116	; 0x74
 800976e:	9303      	str	r3, [sp, #12]
 8009770:	898b      	ldrh	r3, [r1, #12]
 8009772:	4680      	mov	r8, r0
 8009774:	061c      	lsls	r4, r3, #24
 8009776:	460d      	mov	r5, r1
 8009778:	4616      	mov	r6, r2
 800977a:	d50f      	bpl.n	800979c <_svfiprintf_r+0x34>
 800977c:	690b      	ldr	r3, [r1, #16]
 800977e:	b96b      	cbnz	r3, 800979c <_svfiprintf_r+0x34>
 8009780:	2140      	movs	r1, #64	; 0x40
 8009782:	f000 faf1 	bl	8009d68 <_malloc_r>
 8009786:	6028      	str	r0, [r5, #0]
 8009788:	6128      	str	r0, [r5, #16]
 800978a:	b928      	cbnz	r0, 8009798 <_svfiprintf_r+0x30>
 800978c:	230c      	movs	r3, #12
 800978e:	f8c8 3000 	str.w	r3, [r8]
 8009792:	f04f 30ff 	mov.w	r0, #4294967295
 8009796:	e0c4      	b.n	8009922 <_svfiprintf_r+0x1ba>
 8009798:	2340      	movs	r3, #64	; 0x40
 800979a:	616b      	str	r3, [r5, #20]
 800979c:	2300      	movs	r3, #0
 800979e:	9309      	str	r3, [sp, #36]	; 0x24
 80097a0:	2320      	movs	r3, #32
 80097a2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80097a6:	2330      	movs	r3, #48	; 0x30
 80097a8:	f04f 0b01 	mov.w	fp, #1
 80097ac:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80097b0:	4637      	mov	r7, r6
 80097b2:	463c      	mov	r4, r7
 80097b4:	f814 3b01 	ldrb.w	r3, [r4], #1
 80097b8:	2b00      	cmp	r3, #0
 80097ba:	d13c      	bne.n	8009836 <_svfiprintf_r+0xce>
 80097bc:	ebb7 0a06 	subs.w	sl, r7, r6
 80097c0:	d00b      	beq.n	80097da <_svfiprintf_r+0x72>
 80097c2:	4653      	mov	r3, sl
 80097c4:	4632      	mov	r2, r6
 80097c6:	4629      	mov	r1, r5
 80097c8:	4640      	mov	r0, r8
 80097ca:	f7ff ff71 	bl	80096b0 <__ssputs_r>
 80097ce:	3001      	adds	r0, #1
 80097d0:	f000 80a2 	beq.w	8009918 <_svfiprintf_r+0x1b0>
 80097d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80097d6:	4453      	add	r3, sl
 80097d8:	9309      	str	r3, [sp, #36]	; 0x24
 80097da:	783b      	ldrb	r3, [r7, #0]
 80097dc:	2b00      	cmp	r3, #0
 80097de:	f000 809b 	beq.w	8009918 <_svfiprintf_r+0x1b0>
 80097e2:	2300      	movs	r3, #0
 80097e4:	f04f 32ff 	mov.w	r2, #4294967295
 80097e8:	9304      	str	r3, [sp, #16]
 80097ea:	9307      	str	r3, [sp, #28]
 80097ec:	9205      	str	r2, [sp, #20]
 80097ee:	9306      	str	r3, [sp, #24]
 80097f0:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80097f4:	931a      	str	r3, [sp, #104]	; 0x68
 80097f6:	2205      	movs	r2, #5
 80097f8:	7821      	ldrb	r1, [r4, #0]
 80097fa:	4850      	ldr	r0, [pc, #320]	; (800993c <_svfiprintf_r+0x1d4>)
 80097fc:	f000 fa40 	bl	8009c80 <memchr>
 8009800:	1c67      	adds	r7, r4, #1
 8009802:	9b04      	ldr	r3, [sp, #16]
 8009804:	b9d8      	cbnz	r0, 800983e <_svfiprintf_r+0xd6>
 8009806:	06d9      	lsls	r1, r3, #27
 8009808:	bf44      	itt	mi
 800980a:	2220      	movmi	r2, #32
 800980c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8009810:	071a      	lsls	r2, r3, #28
 8009812:	bf44      	itt	mi
 8009814:	222b      	movmi	r2, #43	; 0x2b
 8009816:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800981a:	7822      	ldrb	r2, [r4, #0]
 800981c:	2a2a      	cmp	r2, #42	; 0x2a
 800981e:	d016      	beq.n	800984e <_svfiprintf_r+0xe6>
 8009820:	2100      	movs	r1, #0
 8009822:	200a      	movs	r0, #10
 8009824:	9a07      	ldr	r2, [sp, #28]
 8009826:	4627      	mov	r7, r4
 8009828:	783b      	ldrb	r3, [r7, #0]
 800982a:	3401      	adds	r4, #1
 800982c:	3b30      	subs	r3, #48	; 0x30
 800982e:	2b09      	cmp	r3, #9
 8009830:	d950      	bls.n	80098d4 <_svfiprintf_r+0x16c>
 8009832:	b1c9      	cbz	r1, 8009868 <_svfiprintf_r+0x100>
 8009834:	e011      	b.n	800985a <_svfiprintf_r+0xf2>
 8009836:	2b25      	cmp	r3, #37	; 0x25
 8009838:	d0c0      	beq.n	80097bc <_svfiprintf_r+0x54>
 800983a:	4627      	mov	r7, r4
 800983c:	e7b9      	b.n	80097b2 <_svfiprintf_r+0x4a>
 800983e:	4a3f      	ldr	r2, [pc, #252]	; (800993c <_svfiprintf_r+0x1d4>)
 8009840:	463c      	mov	r4, r7
 8009842:	1a80      	subs	r0, r0, r2
 8009844:	fa0b f000 	lsl.w	r0, fp, r0
 8009848:	4318      	orrs	r0, r3
 800984a:	9004      	str	r0, [sp, #16]
 800984c:	e7d3      	b.n	80097f6 <_svfiprintf_r+0x8e>
 800984e:	9a03      	ldr	r2, [sp, #12]
 8009850:	1d11      	adds	r1, r2, #4
 8009852:	6812      	ldr	r2, [r2, #0]
 8009854:	9103      	str	r1, [sp, #12]
 8009856:	2a00      	cmp	r2, #0
 8009858:	db01      	blt.n	800985e <_svfiprintf_r+0xf6>
 800985a:	9207      	str	r2, [sp, #28]
 800985c:	e004      	b.n	8009868 <_svfiprintf_r+0x100>
 800985e:	4252      	negs	r2, r2
 8009860:	f043 0302 	orr.w	r3, r3, #2
 8009864:	9207      	str	r2, [sp, #28]
 8009866:	9304      	str	r3, [sp, #16]
 8009868:	783b      	ldrb	r3, [r7, #0]
 800986a:	2b2e      	cmp	r3, #46	; 0x2e
 800986c:	d10d      	bne.n	800988a <_svfiprintf_r+0x122>
 800986e:	787b      	ldrb	r3, [r7, #1]
 8009870:	1c79      	adds	r1, r7, #1
 8009872:	2b2a      	cmp	r3, #42	; 0x2a
 8009874:	d132      	bne.n	80098dc <_svfiprintf_r+0x174>
 8009876:	9b03      	ldr	r3, [sp, #12]
 8009878:	3702      	adds	r7, #2
 800987a:	1d1a      	adds	r2, r3, #4
 800987c:	681b      	ldr	r3, [r3, #0]
 800987e:	9203      	str	r2, [sp, #12]
 8009880:	2b00      	cmp	r3, #0
 8009882:	bfb8      	it	lt
 8009884:	f04f 33ff 	movlt.w	r3, #4294967295
 8009888:	9305      	str	r3, [sp, #20]
 800988a:	4c2d      	ldr	r4, [pc, #180]	; (8009940 <_svfiprintf_r+0x1d8>)
 800988c:	2203      	movs	r2, #3
 800988e:	7839      	ldrb	r1, [r7, #0]
 8009890:	4620      	mov	r0, r4
 8009892:	f000 f9f5 	bl	8009c80 <memchr>
 8009896:	b138      	cbz	r0, 80098a8 <_svfiprintf_r+0x140>
 8009898:	2340      	movs	r3, #64	; 0x40
 800989a:	1b00      	subs	r0, r0, r4
 800989c:	fa03 f000 	lsl.w	r0, r3, r0
 80098a0:	9b04      	ldr	r3, [sp, #16]
 80098a2:	3701      	adds	r7, #1
 80098a4:	4303      	orrs	r3, r0
 80098a6:	9304      	str	r3, [sp, #16]
 80098a8:	7839      	ldrb	r1, [r7, #0]
 80098aa:	2206      	movs	r2, #6
 80098ac:	4825      	ldr	r0, [pc, #148]	; (8009944 <_svfiprintf_r+0x1dc>)
 80098ae:	1c7e      	adds	r6, r7, #1
 80098b0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80098b4:	f000 f9e4 	bl	8009c80 <memchr>
 80098b8:	2800      	cmp	r0, #0
 80098ba:	d035      	beq.n	8009928 <_svfiprintf_r+0x1c0>
 80098bc:	4b22      	ldr	r3, [pc, #136]	; (8009948 <_svfiprintf_r+0x1e0>)
 80098be:	b9fb      	cbnz	r3, 8009900 <_svfiprintf_r+0x198>
 80098c0:	9b03      	ldr	r3, [sp, #12]
 80098c2:	3307      	adds	r3, #7
 80098c4:	f023 0307 	bic.w	r3, r3, #7
 80098c8:	3308      	adds	r3, #8
 80098ca:	9303      	str	r3, [sp, #12]
 80098cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80098ce:	444b      	add	r3, r9
 80098d0:	9309      	str	r3, [sp, #36]	; 0x24
 80098d2:	e76d      	b.n	80097b0 <_svfiprintf_r+0x48>
 80098d4:	fb00 3202 	mla	r2, r0, r2, r3
 80098d8:	2101      	movs	r1, #1
 80098da:	e7a4      	b.n	8009826 <_svfiprintf_r+0xbe>
 80098dc:	2300      	movs	r3, #0
 80098de:	240a      	movs	r4, #10
 80098e0:	4618      	mov	r0, r3
 80098e2:	9305      	str	r3, [sp, #20]
 80098e4:	460f      	mov	r7, r1
 80098e6:	783a      	ldrb	r2, [r7, #0]
 80098e8:	3101      	adds	r1, #1
 80098ea:	3a30      	subs	r2, #48	; 0x30
 80098ec:	2a09      	cmp	r2, #9
 80098ee:	d903      	bls.n	80098f8 <_svfiprintf_r+0x190>
 80098f0:	2b00      	cmp	r3, #0
 80098f2:	d0ca      	beq.n	800988a <_svfiprintf_r+0x122>
 80098f4:	9005      	str	r0, [sp, #20]
 80098f6:	e7c8      	b.n	800988a <_svfiprintf_r+0x122>
 80098f8:	fb04 2000 	mla	r0, r4, r0, r2
 80098fc:	2301      	movs	r3, #1
 80098fe:	e7f1      	b.n	80098e4 <_svfiprintf_r+0x17c>
 8009900:	ab03      	add	r3, sp, #12
 8009902:	9300      	str	r3, [sp, #0]
 8009904:	462a      	mov	r2, r5
 8009906:	4b11      	ldr	r3, [pc, #68]	; (800994c <_svfiprintf_r+0x1e4>)
 8009908:	a904      	add	r1, sp, #16
 800990a:	4640      	mov	r0, r8
 800990c:	f3af 8000 	nop.w
 8009910:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009914:	4681      	mov	r9, r0
 8009916:	d1d9      	bne.n	80098cc <_svfiprintf_r+0x164>
 8009918:	89ab      	ldrh	r3, [r5, #12]
 800991a:	065b      	lsls	r3, r3, #25
 800991c:	f53f af39 	bmi.w	8009792 <_svfiprintf_r+0x2a>
 8009920:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009922:	b01d      	add	sp, #116	; 0x74
 8009924:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009928:	ab03      	add	r3, sp, #12
 800992a:	9300      	str	r3, [sp, #0]
 800992c:	462a      	mov	r2, r5
 800992e:	4b07      	ldr	r3, [pc, #28]	; (800994c <_svfiprintf_r+0x1e4>)
 8009930:	a904      	add	r1, sp, #16
 8009932:	4640      	mov	r0, r8
 8009934:	f000 f884 	bl	8009a40 <_printf_i>
 8009938:	e7ea      	b.n	8009910 <_svfiprintf_r+0x1a8>
 800993a:	bf00      	nop
 800993c:	0800ace4 	.word	0x0800ace4
 8009940:	0800acea 	.word	0x0800acea
 8009944:	0800acee 	.word	0x0800acee
 8009948:	00000000 	.word	0x00000000
 800994c:	080096b1 	.word	0x080096b1

08009950 <_printf_common>:
 8009950:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009954:	4691      	mov	r9, r2
 8009956:	461f      	mov	r7, r3
 8009958:	688a      	ldr	r2, [r1, #8]
 800995a:	690b      	ldr	r3, [r1, #16]
 800995c:	4606      	mov	r6, r0
 800995e:	4293      	cmp	r3, r2
 8009960:	bfb8      	it	lt
 8009962:	4613      	movlt	r3, r2
 8009964:	f8c9 3000 	str.w	r3, [r9]
 8009968:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800996c:	460c      	mov	r4, r1
 800996e:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8009972:	b112      	cbz	r2, 800997a <_printf_common+0x2a>
 8009974:	3301      	adds	r3, #1
 8009976:	f8c9 3000 	str.w	r3, [r9]
 800997a:	6823      	ldr	r3, [r4, #0]
 800997c:	0699      	lsls	r1, r3, #26
 800997e:	bf42      	ittt	mi
 8009980:	f8d9 3000 	ldrmi.w	r3, [r9]
 8009984:	3302      	addmi	r3, #2
 8009986:	f8c9 3000 	strmi.w	r3, [r9]
 800998a:	6825      	ldr	r5, [r4, #0]
 800998c:	f015 0506 	ands.w	r5, r5, #6
 8009990:	d107      	bne.n	80099a2 <_printf_common+0x52>
 8009992:	f104 0a19 	add.w	sl, r4, #25
 8009996:	68e3      	ldr	r3, [r4, #12]
 8009998:	f8d9 2000 	ldr.w	r2, [r9]
 800999c:	1a9b      	subs	r3, r3, r2
 800999e:	429d      	cmp	r5, r3
 80099a0:	db2a      	blt.n	80099f8 <_printf_common+0xa8>
 80099a2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80099a6:	6822      	ldr	r2, [r4, #0]
 80099a8:	3300      	adds	r3, #0
 80099aa:	bf18      	it	ne
 80099ac:	2301      	movne	r3, #1
 80099ae:	0692      	lsls	r2, r2, #26
 80099b0:	d42f      	bmi.n	8009a12 <_printf_common+0xc2>
 80099b2:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80099b6:	4639      	mov	r1, r7
 80099b8:	4630      	mov	r0, r6
 80099ba:	47c0      	blx	r8
 80099bc:	3001      	adds	r0, #1
 80099be:	d022      	beq.n	8009a06 <_printf_common+0xb6>
 80099c0:	6823      	ldr	r3, [r4, #0]
 80099c2:	68e5      	ldr	r5, [r4, #12]
 80099c4:	f003 0306 	and.w	r3, r3, #6
 80099c8:	2b04      	cmp	r3, #4
 80099ca:	bf18      	it	ne
 80099cc:	2500      	movne	r5, #0
 80099ce:	f8d9 2000 	ldr.w	r2, [r9]
 80099d2:	f04f 0900 	mov.w	r9, #0
 80099d6:	bf08      	it	eq
 80099d8:	1aad      	subeq	r5, r5, r2
 80099da:	68a3      	ldr	r3, [r4, #8]
 80099dc:	6922      	ldr	r2, [r4, #16]
 80099de:	bf08      	it	eq
 80099e0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80099e4:	4293      	cmp	r3, r2
 80099e6:	bfc4      	itt	gt
 80099e8:	1a9b      	subgt	r3, r3, r2
 80099ea:	18ed      	addgt	r5, r5, r3
 80099ec:	341a      	adds	r4, #26
 80099ee:	454d      	cmp	r5, r9
 80099f0:	d11b      	bne.n	8009a2a <_printf_common+0xda>
 80099f2:	2000      	movs	r0, #0
 80099f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80099f8:	2301      	movs	r3, #1
 80099fa:	4652      	mov	r2, sl
 80099fc:	4639      	mov	r1, r7
 80099fe:	4630      	mov	r0, r6
 8009a00:	47c0      	blx	r8
 8009a02:	3001      	adds	r0, #1
 8009a04:	d103      	bne.n	8009a0e <_printf_common+0xbe>
 8009a06:	f04f 30ff 	mov.w	r0, #4294967295
 8009a0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009a0e:	3501      	adds	r5, #1
 8009a10:	e7c1      	b.n	8009996 <_printf_common+0x46>
 8009a12:	2030      	movs	r0, #48	; 0x30
 8009a14:	18e1      	adds	r1, r4, r3
 8009a16:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8009a1a:	1c5a      	adds	r2, r3, #1
 8009a1c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8009a20:	4422      	add	r2, r4
 8009a22:	3302      	adds	r3, #2
 8009a24:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8009a28:	e7c3      	b.n	80099b2 <_printf_common+0x62>
 8009a2a:	2301      	movs	r3, #1
 8009a2c:	4622      	mov	r2, r4
 8009a2e:	4639      	mov	r1, r7
 8009a30:	4630      	mov	r0, r6
 8009a32:	47c0      	blx	r8
 8009a34:	3001      	adds	r0, #1
 8009a36:	d0e6      	beq.n	8009a06 <_printf_common+0xb6>
 8009a38:	f109 0901 	add.w	r9, r9, #1
 8009a3c:	e7d7      	b.n	80099ee <_printf_common+0x9e>
	...

08009a40 <_printf_i>:
 8009a40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009a44:	4617      	mov	r7, r2
 8009a46:	7e0a      	ldrb	r2, [r1, #24]
 8009a48:	b085      	sub	sp, #20
 8009a4a:	2a6e      	cmp	r2, #110	; 0x6e
 8009a4c:	4698      	mov	r8, r3
 8009a4e:	4606      	mov	r6, r0
 8009a50:	460c      	mov	r4, r1
 8009a52:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009a54:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 8009a58:	f000 80bc 	beq.w	8009bd4 <_printf_i+0x194>
 8009a5c:	d81a      	bhi.n	8009a94 <_printf_i+0x54>
 8009a5e:	2a63      	cmp	r2, #99	; 0x63
 8009a60:	d02e      	beq.n	8009ac0 <_printf_i+0x80>
 8009a62:	d80a      	bhi.n	8009a7a <_printf_i+0x3a>
 8009a64:	2a00      	cmp	r2, #0
 8009a66:	f000 80c8 	beq.w	8009bfa <_printf_i+0x1ba>
 8009a6a:	2a58      	cmp	r2, #88	; 0x58
 8009a6c:	f000 808a 	beq.w	8009b84 <_printf_i+0x144>
 8009a70:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8009a74:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 8009a78:	e02a      	b.n	8009ad0 <_printf_i+0x90>
 8009a7a:	2a64      	cmp	r2, #100	; 0x64
 8009a7c:	d001      	beq.n	8009a82 <_printf_i+0x42>
 8009a7e:	2a69      	cmp	r2, #105	; 0x69
 8009a80:	d1f6      	bne.n	8009a70 <_printf_i+0x30>
 8009a82:	6821      	ldr	r1, [r4, #0]
 8009a84:	681a      	ldr	r2, [r3, #0]
 8009a86:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009a8a:	d023      	beq.n	8009ad4 <_printf_i+0x94>
 8009a8c:	1d11      	adds	r1, r2, #4
 8009a8e:	6019      	str	r1, [r3, #0]
 8009a90:	6813      	ldr	r3, [r2, #0]
 8009a92:	e027      	b.n	8009ae4 <_printf_i+0xa4>
 8009a94:	2a73      	cmp	r2, #115	; 0x73
 8009a96:	f000 80b4 	beq.w	8009c02 <_printf_i+0x1c2>
 8009a9a:	d808      	bhi.n	8009aae <_printf_i+0x6e>
 8009a9c:	2a6f      	cmp	r2, #111	; 0x6f
 8009a9e:	d02a      	beq.n	8009af6 <_printf_i+0xb6>
 8009aa0:	2a70      	cmp	r2, #112	; 0x70
 8009aa2:	d1e5      	bne.n	8009a70 <_printf_i+0x30>
 8009aa4:	680a      	ldr	r2, [r1, #0]
 8009aa6:	f042 0220 	orr.w	r2, r2, #32
 8009aaa:	600a      	str	r2, [r1, #0]
 8009aac:	e003      	b.n	8009ab6 <_printf_i+0x76>
 8009aae:	2a75      	cmp	r2, #117	; 0x75
 8009ab0:	d021      	beq.n	8009af6 <_printf_i+0xb6>
 8009ab2:	2a78      	cmp	r2, #120	; 0x78
 8009ab4:	d1dc      	bne.n	8009a70 <_printf_i+0x30>
 8009ab6:	2278      	movs	r2, #120	; 0x78
 8009ab8:	496f      	ldr	r1, [pc, #444]	; (8009c78 <_printf_i+0x238>)
 8009aba:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 8009abe:	e064      	b.n	8009b8a <_printf_i+0x14a>
 8009ac0:	681a      	ldr	r2, [r3, #0]
 8009ac2:	f101 0542 	add.w	r5, r1, #66	; 0x42
 8009ac6:	1d11      	adds	r1, r2, #4
 8009ac8:	6019      	str	r1, [r3, #0]
 8009aca:	6813      	ldr	r3, [r2, #0]
 8009acc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009ad0:	2301      	movs	r3, #1
 8009ad2:	e0a3      	b.n	8009c1c <_printf_i+0x1dc>
 8009ad4:	f011 0f40 	tst.w	r1, #64	; 0x40
 8009ad8:	f102 0104 	add.w	r1, r2, #4
 8009adc:	6019      	str	r1, [r3, #0]
 8009ade:	d0d7      	beq.n	8009a90 <_printf_i+0x50>
 8009ae0:	f9b2 3000 	ldrsh.w	r3, [r2]
 8009ae4:	2b00      	cmp	r3, #0
 8009ae6:	da03      	bge.n	8009af0 <_printf_i+0xb0>
 8009ae8:	222d      	movs	r2, #45	; 0x2d
 8009aea:	425b      	negs	r3, r3
 8009aec:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8009af0:	4962      	ldr	r1, [pc, #392]	; (8009c7c <_printf_i+0x23c>)
 8009af2:	220a      	movs	r2, #10
 8009af4:	e017      	b.n	8009b26 <_printf_i+0xe6>
 8009af6:	6820      	ldr	r0, [r4, #0]
 8009af8:	6819      	ldr	r1, [r3, #0]
 8009afa:	f010 0f80 	tst.w	r0, #128	; 0x80
 8009afe:	d003      	beq.n	8009b08 <_printf_i+0xc8>
 8009b00:	1d08      	adds	r0, r1, #4
 8009b02:	6018      	str	r0, [r3, #0]
 8009b04:	680b      	ldr	r3, [r1, #0]
 8009b06:	e006      	b.n	8009b16 <_printf_i+0xd6>
 8009b08:	f010 0f40 	tst.w	r0, #64	; 0x40
 8009b0c:	f101 0004 	add.w	r0, r1, #4
 8009b10:	6018      	str	r0, [r3, #0]
 8009b12:	d0f7      	beq.n	8009b04 <_printf_i+0xc4>
 8009b14:	880b      	ldrh	r3, [r1, #0]
 8009b16:	2a6f      	cmp	r2, #111	; 0x6f
 8009b18:	bf14      	ite	ne
 8009b1a:	220a      	movne	r2, #10
 8009b1c:	2208      	moveq	r2, #8
 8009b1e:	4957      	ldr	r1, [pc, #348]	; (8009c7c <_printf_i+0x23c>)
 8009b20:	2000      	movs	r0, #0
 8009b22:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8009b26:	6865      	ldr	r5, [r4, #4]
 8009b28:	2d00      	cmp	r5, #0
 8009b2a:	60a5      	str	r5, [r4, #8]
 8009b2c:	f2c0 809c 	blt.w	8009c68 <_printf_i+0x228>
 8009b30:	6820      	ldr	r0, [r4, #0]
 8009b32:	f020 0004 	bic.w	r0, r0, #4
 8009b36:	6020      	str	r0, [r4, #0]
 8009b38:	2b00      	cmp	r3, #0
 8009b3a:	d13f      	bne.n	8009bbc <_printf_i+0x17c>
 8009b3c:	2d00      	cmp	r5, #0
 8009b3e:	f040 8095 	bne.w	8009c6c <_printf_i+0x22c>
 8009b42:	4675      	mov	r5, lr
 8009b44:	2a08      	cmp	r2, #8
 8009b46:	d10b      	bne.n	8009b60 <_printf_i+0x120>
 8009b48:	6823      	ldr	r3, [r4, #0]
 8009b4a:	07da      	lsls	r2, r3, #31
 8009b4c:	d508      	bpl.n	8009b60 <_printf_i+0x120>
 8009b4e:	6923      	ldr	r3, [r4, #16]
 8009b50:	6862      	ldr	r2, [r4, #4]
 8009b52:	429a      	cmp	r2, r3
 8009b54:	bfde      	ittt	le
 8009b56:	2330      	movle	r3, #48	; 0x30
 8009b58:	f805 3c01 	strble.w	r3, [r5, #-1]
 8009b5c:	f105 35ff 	addle.w	r5, r5, #4294967295
 8009b60:	ebae 0305 	sub.w	r3, lr, r5
 8009b64:	6123      	str	r3, [r4, #16]
 8009b66:	f8cd 8000 	str.w	r8, [sp]
 8009b6a:	463b      	mov	r3, r7
 8009b6c:	aa03      	add	r2, sp, #12
 8009b6e:	4621      	mov	r1, r4
 8009b70:	4630      	mov	r0, r6
 8009b72:	f7ff feed 	bl	8009950 <_printf_common>
 8009b76:	3001      	adds	r0, #1
 8009b78:	d155      	bne.n	8009c26 <_printf_i+0x1e6>
 8009b7a:	f04f 30ff 	mov.w	r0, #4294967295
 8009b7e:	b005      	add	sp, #20
 8009b80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8009b84:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 8009b88:	493c      	ldr	r1, [pc, #240]	; (8009c7c <_printf_i+0x23c>)
 8009b8a:	6822      	ldr	r2, [r4, #0]
 8009b8c:	6818      	ldr	r0, [r3, #0]
 8009b8e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b92:	f100 0504 	add.w	r5, r0, #4
 8009b96:	601d      	str	r5, [r3, #0]
 8009b98:	d001      	beq.n	8009b9e <_printf_i+0x15e>
 8009b9a:	6803      	ldr	r3, [r0, #0]
 8009b9c:	e002      	b.n	8009ba4 <_printf_i+0x164>
 8009b9e:	0655      	lsls	r5, r2, #25
 8009ba0:	d5fb      	bpl.n	8009b9a <_printf_i+0x15a>
 8009ba2:	8803      	ldrh	r3, [r0, #0]
 8009ba4:	07d0      	lsls	r0, r2, #31
 8009ba6:	bf44      	itt	mi
 8009ba8:	f042 0220 	orrmi.w	r2, r2, #32
 8009bac:	6022      	strmi	r2, [r4, #0]
 8009bae:	b91b      	cbnz	r3, 8009bb8 <_printf_i+0x178>
 8009bb0:	6822      	ldr	r2, [r4, #0]
 8009bb2:	f022 0220 	bic.w	r2, r2, #32
 8009bb6:	6022      	str	r2, [r4, #0]
 8009bb8:	2210      	movs	r2, #16
 8009bba:	e7b1      	b.n	8009b20 <_printf_i+0xe0>
 8009bbc:	4675      	mov	r5, lr
 8009bbe:	fbb3 f0f2 	udiv	r0, r3, r2
 8009bc2:	fb02 3310 	mls	r3, r2, r0, r3
 8009bc6:	5ccb      	ldrb	r3, [r1, r3]
 8009bc8:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8009bcc:	4603      	mov	r3, r0
 8009bce:	2800      	cmp	r0, #0
 8009bd0:	d1f5      	bne.n	8009bbe <_printf_i+0x17e>
 8009bd2:	e7b7      	b.n	8009b44 <_printf_i+0x104>
 8009bd4:	6808      	ldr	r0, [r1, #0]
 8009bd6:	681a      	ldr	r2, [r3, #0]
 8009bd8:	f010 0f80 	tst.w	r0, #128	; 0x80
 8009bdc:	6949      	ldr	r1, [r1, #20]
 8009bde:	d004      	beq.n	8009bea <_printf_i+0x1aa>
 8009be0:	1d10      	adds	r0, r2, #4
 8009be2:	6018      	str	r0, [r3, #0]
 8009be4:	6813      	ldr	r3, [r2, #0]
 8009be6:	6019      	str	r1, [r3, #0]
 8009be8:	e007      	b.n	8009bfa <_printf_i+0x1ba>
 8009bea:	f010 0f40 	tst.w	r0, #64	; 0x40
 8009bee:	f102 0004 	add.w	r0, r2, #4
 8009bf2:	6018      	str	r0, [r3, #0]
 8009bf4:	6813      	ldr	r3, [r2, #0]
 8009bf6:	d0f6      	beq.n	8009be6 <_printf_i+0x1a6>
 8009bf8:	8019      	strh	r1, [r3, #0]
 8009bfa:	2300      	movs	r3, #0
 8009bfc:	4675      	mov	r5, lr
 8009bfe:	6123      	str	r3, [r4, #16]
 8009c00:	e7b1      	b.n	8009b66 <_printf_i+0x126>
 8009c02:	681a      	ldr	r2, [r3, #0]
 8009c04:	1d11      	adds	r1, r2, #4
 8009c06:	6019      	str	r1, [r3, #0]
 8009c08:	6815      	ldr	r5, [r2, #0]
 8009c0a:	2100      	movs	r1, #0
 8009c0c:	6862      	ldr	r2, [r4, #4]
 8009c0e:	4628      	mov	r0, r5
 8009c10:	f000 f836 	bl	8009c80 <memchr>
 8009c14:	b108      	cbz	r0, 8009c1a <_printf_i+0x1da>
 8009c16:	1b40      	subs	r0, r0, r5
 8009c18:	6060      	str	r0, [r4, #4]
 8009c1a:	6863      	ldr	r3, [r4, #4]
 8009c1c:	6123      	str	r3, [r4, #16]
 8009c1e:	2300      	movs	r3, #0
 8009c20:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8009c24:	e79f      	b.n	8009b66 <_printf_i+0x126>
 8009c26:	6923      	ldr	r3, [r4, #16]
 8009c28:	462a      	mov	r2, r5
 8009c2a:	4639      	mov	r1, r7
 8009c2c:	4630      	mov	r0, r6
 8009c2e:	47c0      	blx	r8
 8009c30:	3001      	adds	r0, #1
 8009c32:	d0a2      	beq.n	8009b7a <_printf_i+0x13a>
 8009c34:	6823      	ldr	r3, [r4, #0]
 8009c36:	079b      	lsls	r3, r3, #30
 8009c38:	d507      	bpl.n	8009c4a <_printf_i+0x20a>
 8009c3a:	2500      	movs	r5, #0
 8009c3c:	f104 0919 	add.w	r9, r4, #25
 8009c40:	68e3      	ldr	r3, [r4, #12]
 8009c42:	9a03      	ldr	r2, [sp, #12]
 8009c44:	1a9b      	subs	r3, r3, r2
 8009c46:	429d      	cmp	r5, r3
 8009c48:	db05      	blt.n	8009c56 <_printf_i+0x216>
 8009c4a:	68e0      	ldr	r0, [r4, #12]
 8009c4c:	9b03      	ldr	r3, [sp, #12]
 8009c4e:	4298      	cmp	r0, r3
 8009c50:	bfb8      	it	lt
 8009c52:	4618      	movlt	r0, r3
 8009c54:	e793      	b.n	8009b7e <_printf_i+0x13e>
 8009c56:	2301      	movs	r3, #1
 8009c58:	464a      	mov	r2, r9
 8009c5a:	4639      	mov	r1, r7
 8009c5c:	4630      	mov	r0, r6
 8009c5e:	47c0      	blx	r8
 8009c60:	3001      	adds	r0, #1
 8009c62:	d08a      	beq.n	8009b7a <_printf_i+0x13a>
 8009c64:	3501      	adds	r5, #1
 8009c66:	e7eb      	b.n	8009c40 <_printf_i+0x200>
 8009c68:	2b00      	cmp	r3, #0
 8009c6a:	d1a7      	bne.n	8009bbc <_printf_i+0x17c>
 8009c6c:	780b      	ldrb	r3, [r1, #0]
 8009c6e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8009c72:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009c76:	e765      	b.n	8009b44 <_printf_i+0x104>
 8009c78:	0800ad06 	.word	0x0800ad06
 8009c7c:	0800acf5 	.word	0x0800acf5

08009c80 <memchr>:
 8009c80:	b510      	push	{r4, lr}
 8009c82:	b2c9      	uxtb	r1, r1
 8009c84:	4402      	add	r2, r0
 8009c86:	4290      	cmp	r0, r2
 8009c88:	4603      	mov	r3, r0
 8009c8a:	d101      	bne.n	8009c90 <memchr+0x10>
 8009c8c:	2000      	movs	r0, #0
 8009c8e:	bd10      	pop	{r4, pc}
 8009c90:	781c      	ldrb	r4, [r3, #0]
 8009c92:	3001      	adds	r0, #1
 8009c94:	428c      	cmp	r4, r1
 8009c96:	d1f6      	bne.n	8009c86 <memchr+0x6>
 8009c98:	4618      	mov	r0, r3
 8009c9a:	bd10      	pop	{r4, pc}

08009c9c <memmove>:
 8009c9c:	4288      	cmp	r0, r1
 8009c9e:	b510      	push	{r4, lr}
 8009ca0:	eb01 0302 	add.w	r3, r1, r2
 8009ca4:	d803      	bhi.n	8009cae <memmove+0x12>
 8009ca6:	1e42      	subs	r2, r0, #1
 8009ca8:	4299      	cmp	r1, r3
 8009caa:	d10c      	bne.n	8009cc6 <memmove+0x2a>
 8009cac:	bd10      	pop	{r4, pc}
 8009cae:	4298      	cmp	r0, r3
 8009cb0:	d2f9      	bcs.n	8009ca6 <memmove+0xa>
 8009cb2:	1881      	adds	r1, r0, r2
 8009cb4:	1ad2      	subs	r2, r2, r3
 8009cb6:	42d3      	cmn	r3, r2
 8009cb8:	d100      	bne.n	8009cbc <memmove+0x20>
 8009cba:	bd10      	pop	{r4, pc}
 8009cbc:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8009cc0:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8009cc4:	e7f7      	b.n	8009cb6 <memmove+0x1a>
 8009cc6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009cca:	f802 4f01 	strb.w	r4, [r2, #1]!
 8009cce:	e7eb      	b.n	8009ca8 <memmove+0xc>

08009cd0 <_free_r>:
 8009cd0:	b538      	push	{r3, r4, r5, lr}
 8009cd2:	4605      	mov	r5, r0
 8009cd4:	2900      	cmp	r1, #0
 8009cd6:	d043      	beq.n	8009d60 <_free_r+0x90>
 8009cd8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8009cdc:	1f0c      	subs	r4, r1, #4
 8009cde:	2b00      	cmp	r3, #0
 8009ce0:	bfb8      	it	lt
 8009ce2:	18e4      	addlt	r4, r4, r3
 8009ce4:	f000 f8d4 	bl	8009e90 <__malloc_lock>
 8009ce8:	4a1e      	ldr	r2, [pc, #120]	; (8009d64 <_free_r+0x94>)
 8009cea:	6813      	ldr	r3, [r2, #0]
 8009cec:	4610      	mov	r0, r2
 8009cee:	b933      	cbnz	r3, 8009cfe <_free_r+0x2e>
 8009cf0:	6063      	str	r3, [r4, #4]
 8009cf2:	6014      	str	r4, [r2, #0]
 8009cf4:	4628      	mov	r0, r5
 8009cf6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8009cfa:	f000 b8ca 	b.w	8009e92 <__malloc_unlock>
 8009cfe:	42a3      	cmp	r3, r4
 8009d00:	d90b      	bls.n	8009d1a <_free_r+0x4a>
 8009d02:	6821      	ldr	r1, [r4, #0]
 8009d04:	1862      	adds	r2, r4, r1
 8009d06:	4293      	cmp	r3, r2
 8009d08:	bf01      	itttt	eq
 8009d0a:	681a      	ldreq	r2, [r3, #0]
 8009d0c:	685b      	ldreq	r3, [r3, #4]
 8009d0e:	1852      	addeq	r2, r2, r1
 8009d10:	6022      	streq	r2, [r4, #0]
 8009d12:	6063      	str	r3, [r4, #4]
 8009d14:	6004      	str	r4, [r0, #0]
 8009d16:	e7ed      	b.n	8009cf4 <_free_r+0x24>
 8009d18:	4613      	mov	r3, r2
 8009d1a:	685a      	ldr	r2, [r3, #4]
 8009d1c:	b10a      	cbz	r2, 8009d22 <_free_r+0x52>
 8009d1e:	42a2      	cmp	r2, r4
 8009d20:	d9fa      	bls.n	8009d18 <_free_r+0x48>
 8009d22:	6819      	ldr	r1, [r3, #0]
 8009d24:	1858      	adds	r0, r3, r1
 8009d26:	42a0      	cmp	r0, r4
 8009d28:	d10b      	bne.n	8009d42 <_free_r+0x72>
 8009d2a:	6820      	ldr	r0, [r4, #0]
 8009d2c:	4401      	add	r1, r0
 8009d2e:	1858      	adds	r0, r3, r1
 8009d30:	4282      	cmp	r2, r0
 8009d32:	6019      	str	r1, [r3, #0]
 8009d34:	d1de      	bne.n	8009cf4 <_free_r+0x24>
 8009d36:	6810      	ldr	r0, [r2, #0]
 8009d38:	6852      	ldr	r2, [r2, #4]
 8009d3a:	4401      	add	r1, r0
 8009d3c:	6019      	str	r1, [r3, #0]
 8009d3e:	605a      	str	r2, [r3, #4]
 8009d40:	e7d8      	b.n	8009cf4 <_free_r+0x24>
 8009d42:	d902      	bls.n	8009d4a <_free_r+0x7a>
 8009d44:	230c      	movs	r3, #12
 8009d46:	602b      	str	r3, [r5, #0]
 8009d48:	e7d4      	b.n	8009cf4 <_free_r+0x24>
 8009d4a:	6820      	ldr	r0, [r4, #0]
 8009d4c:	1821      	adds	r1, r4, r0
 8009d4e:	428a      	cmp	r2, r1
 8009d50:	bf01      	itttt	eq
 8009d52:	6811      	ldreq	r1, [r2, #0]
 8009d54:	6852      	ldreq	r2, [r2, #4]
 8009d56:	1809      	addeq	r1, r1, r0
 8009d58:	6021      	streq	r1, [r4, #0]
 8009d5a:	6062      	str	r2, [r4, #4]
 8009d5c:	605c      	str	r4, [r3, #4]
 8009d5e:	e7c9      	b.n	8009cf4 <_free_r+0x24>
 8009d60:	bd38      	pop	{r3, r4, r5, pc}
 8009d62:	bf00      	nop
 8009d64:	2000097c 	.word	0x2000097c

08009d68 <_malloc_r>:
 8009d68:	b570      	push	{r4, r5, r6, lr}
 8009d6a:	1ccd      	adds	r5, r1, #3
 8009d6c:	f025 0503 	bic.w	r5, r5, #3
 8009d70:	3508      	adds	r5, #8
 8009d72:	2d0c      	cmp	r5, #12
 8009d74:	bf38      	it	cc
 8009d76:	250c      	movcc	r5, #12
 8009d78:	2d00      	cmp	r5, #0
 8009d7a:	4606      	mov	r6, r0
 8009d7c:	db01      	blt.n	8009d82 <_malloc_r+0x1a>
 8009d7e:	42a9      	cmp	r1, r5
 8009d80:	d903      	bls.n	8009d8a <_malloc_r+0x22>
 8009d82:	230c      	movs	r3, #12
 8009d84:	6033      	str	r3, [r6, #0]
 8009d86:	2000      	movs	r0, #0
 8009d88:	bd70      	pop	{r4, r5, r6, pc}
 8009d8a:	f000 f881 	bl	8009e90 <__malloc_lock>
 8009d8e:	4a23      	ldr	r2, [pc, #140]	; (8009e1c <_malloc_r+0xb4>)
 8009d90:	6814      	ldr	r4, [r2, #0]
 8009d92:	4621      	mov	r1, r4
 8009d94:	b991      	cbnz	r1, 8009dbc <_malloc_r+0x54>
 8009d96:	4c22      	ldr	r4, [pc, #136]	; (8009e20 <_malloc_r+0xb8>)
 8009d98:	6823      	ldr	r3, [r4, #0]
 8009d9a:	b91b      	cbnz	r3, 8009da4 <_malloc_r+0x3c>
 8009d9c:	4630      	mov	r0, r6
 8009d9e:	f000 f867 	bl	8009e70 <_sbrk_r>
 8009da2:	6020      	str	r0, [r4, #0]
 8009da4:	4629      	mov	r1, r5
 8009da6:	4630      	mov	r0, r6
 8009da8:	f000 f862 	bl	8009e70 <_sbrk_r>
 8009dac:	1c43      	adds	r3, r0, #1
 8009dae:	d126      	bne.n	8009dfe <_malloc_r+0x96>
 8009db0:	230c      	movs	r3, #12
 8009db2:	4630      	mov	r0, r6
 8009db4:	6033      	str	r3, [r6, #0]
 8009db6:	f000 f86c 	bl	8009e92 <__malloc_unlock>
 8009dba:	e7e4      	b.n	8009d86 <_malloc_r+0x1e>
 8009dbc:	680b      	ldr	r3, [r1, #0]
 8009dbe:	1b5b      	subs	r3, r3, r5
 8009dc0:	d41a      	bmi.n	8009df8 <_malloc_r+0x90>
 8009dc2:	2b0b      	cmp	r3, #11
 8009dc4:	d90f      	bls.n	8009de6 <_malloc_r+0x7e>
 8009dc6:	600b      	str	r3, [r1, #0]
 8009dc8:	18cc      	adds	r4, r1, r3
 8009dca:	50cd      	str	r5, [r1, r3]
 8009dcc:	4630      	mov	r0, r6
 8009dce:	f000 f860 	bl	8009e92 <__malloc_unlock>
 8009dd2:	f104 000b 	add.w	r0, r4, #11
 8009dd6:	1d23      	adds	r3, r4, #4
 8009dd8:	f020 0007 	bic.w	r0, r0, #7
 8009ddc:	1ac3      	subs	r3, r0, r3
 8009dde:	d01b      	beq.n	8009e18 <_malloc_r+0xb0>
 8009de0:	425a      	negs	r2, r3
 8009de2:	50e2      	str	r2, [r4, r3]
 8009de4:	bd70      	pop	{r4, r5, r6, pc}
 8009de6:	428c      	cmp	r4, r1
 8009de8:	bf0b      	itete	eq
 8009dea:	6863      	ldreq	r3, [r4, #4]
 8009dec:	684b      	ldrne	r3, [r1, #4]
 8009dee:	6013      	streq	r3, [r2, #0]
 8009df0:	6063      	strne	r3, [r4, #4]
 8009df2:	bf18      	it	ne
 8009df4:	460c      	movne	r4, r1
 8009df6:	e7e9      	b.n	8009dcc <_malloc_r+0x64>
 8009df8:	460c      	mov	r4, r1
 8009dfa:	6849      	ldr	r1, [r1, #4]
 8009dfc:	e7ca      	b.n	8009d94 <_malloc_r+0x2c>
 8009dfe:	1cc4      	adds	r4, r0, #3
 8009e00:	f024 0403 	bic.w	r4, r4, #3
 8009e04:	42a0      	cmp	r0, r4
 8009e06:	d005      	beq.n	8009e14 <_malloc_r+0xac>
 8009e08:	1a21      	subs	r1, r4, r0
 8009e0a:	4630      	mov	r0, r6
 8009e0c:	f000 f830 	bl	8009e70 <_sbrk_r>
 8009e10:	3001      	adds	r0, #1
 8009e12:	d0cd      	beq.n	8009db0 <_malloc_r+0x48>
 8009e14:	6025      	str	r5, [r4, #0]
 8009e16:	e7d9      	b.n	8009dcc <_malloc_r+0x64>
 8009e18:	bd70      	pop	{r4, r5, r6, pc}
 8009e1a:	bf00      	nop
 8009e1c:	2000097c 	.word	0x2000097c
 8009e20:	20000980 	.word	0x20000980

08009e24 <_realloc_r>:
 8009e24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009e26:	4607      	mov	r7, r0
 8009e28:	4614      	mov	r4, r2
 8009e2a:	460e      	mov	r6, r1
 8009e2c:	b921      	cbnz	r1, 8009e38 <_realloc_r+0x14>
 8009e2e:	4611      	mov	r1, r2
 8009e30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8009e34:	f7ff bf98 	b.w	8009d68 <_malloc_r>
 8009e38:	b922      	cbnz	r2, 8009e44 <_realloc_r+0x20>
 8009e3a:	f7ff ff49 	bl	8009cd0 <_free_r>
 8009e3e:	4625      	mov	r5, r4
 8009e40:	4628      	mov	r0, r5
 8009e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009e44:	f000 f826 	bl	8009e94 <_malloc_usable_size_r>
 8009e48:	4284      	cmp	r4, r0
 8009e4a:	d90f      	bls.n	8009e6c <_realloc_r+0x48>
 8009e4c:	4621      	mov	r1, r4
 8009e4e:	4638      	mov	r0, r7
 8009e50:	f7ff ff8a 	bl	8009d68 <_malloc_r>
 8009e54:	4605      	mov	r5, r0
 8009e56:	2800      	cmp	r0, #0
 8009e58:	d0f2      	beq.n	8009e40 <_realloc_r+0x1c>
 8009e5a:	4631      	mov	r1, r6
 8009e5c:	4622      	mov	r2, r4
 8009e5e:	f7ff fbef 	bl	8009640 <memcpy>
 8009e62:	4631      	mov	r1, r6
 8009e64:	4638      	mov	r0, r7
 8009e66:	f7ff ff33 	bl	8009cd0 <_free_r>
 8009e6a:	e7e9      	b.n	8009e40 <_realloc_r+0x1c>
 8009e6c:	4635      	mov	r5, r6
 8009e6e:	e7e7      	b.n	8009e40 <_realloc_r+0x1c>

08009e70 <_sbrk_r>:
 8009e70:	b538      	push	{r3, r4, r5, lr}
 8009e72:	2300      	movs	r3, #0
 8009e74:	4c05      	ldr	r4, [pc, #20]	; (8009e8c <_sbrk_r+0x1c>)
 8009e76:	4605      	mov	r5, r0
 8009e78:	4608      	mov	r0, r1
 8009e7a:	6023      	str	r3, [r4, #0]
 8009e7c:	f7fe fd14 	bl	80088a8 <_sbrk>
 8009e80:	1c43      	adds	r3, r0, #1
 8009e82:	d102      	bne.n	8009e8a <_sbrk_r+0x1a>
 8009e84:	6823      	ldr	r3, [r4, #0]
 8009e86:	b103      	cbz	r3, 8009e8a <_sbrk_r+0x1a>
 8009e88:	602b      	str	r3, [r5, #0]
 8009e8a:	bd38      	pop	{r3, r4, r5, pc}
 8009e8c:	2000f614 	.word	0x2000f614

08009e90 <__malloc_lock>:
 8009e90:	4770      	bx	lr

08009e92 <__malloc_unlock>:
 8009e92:	4770      	bx	lr

08009e94 <_malloc_usable_size_r>:
 8009e94:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8009e98:	2800      	cmp	r0, #0
 8009e9a:	f1a0 0004 	sub.w	r0, r0, #4
 8009e9e:	bfbc      	itt	lt
 8009ea0:	580b      	ldrlt	r3, [r1, r0]
 8009ea2:	18c0      	addlt	r0, r0, r3
 8009ea4:	4770      	bx	lr
	...

08009ea8 <_init>:
 8009ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009eaa:	bf00      	nop
 8009eac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009eae:	bc08      	pop	{r3}
 8009eb0:	469e      	mov	lr, r3
 8009eb2:	4770      	bx	lr

08009eb4 <_fini>:
 8009eb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009eb6:	bf00      	nop
 8009eb8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009eba:	bc08      	pop	{r3}
 8009ebc:	469e      	mov	lr, r3
 8009ebe:	4770      	bx	lr
